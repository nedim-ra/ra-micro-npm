import m from "../utils.js";
import S from "../helpers/buildURL.js";
import q from "./InterceptorManager.js";
import k from "./dispatchRequest.js";
import w from "./mergeConfig.js";
import P from "./buildFullPath.js";
import y from "../helpers/validator.js";
import R from "./AxiosHeaders.js";
const u = y.validators;
class W {
  constructor(r) {
    this.defaults = r, this.interceptors = {
      request: new q(),
      response: new q()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(r, e) {
    try {
      return await this._request(r, e);
    } catch (n) {
      if (n instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(r, e) {
    typeof r == "string" ? (e = e || {}, e.url = r) : e = r || {}, e = w(this.defaults, e);
    const { transitional: n, paramsSerializer: i, headers: s } = e;
    n !== void 0 && y.assertOptions(n, {
      silentJSONParsing: u.transitional(u.boolean),
      forcedJSONParsing: u.transitional(u.boolean),
      clarifyTimeoutError: u.transitional(u.boolean)
    }, !1), i != null && (m.isFunction(i) ? e.paramsSerializer = {
      serialize: i
    } : y.assertOptions(i, {
      encode: u.function,
      serialize: u.function
    }, !0)), e.method = (e.method || this.defaults.method || "get").toLowerCase();
    let E = s && m.merge(
      s.common,
      s[e.method]
    );
    s && m.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (t) => {
        delete s[t];
      }
    ), e.headers = R.concat(E, s);
    const c = [];
    let d = !0;
    this.interceptors.request.forEach(function(o) {
      typeof o.runWhen == "function" && o.runWhen(e) === !1 || (d = d && o.synchronous, c.unshift(o.fulfilled, o.rejected));
    });
    const p = [];
    this.interceptors.response.forEach(function(o) {
      p.push(o.fulfilled, o.rejected);
    });
    let l, a = 0, h;
    if (!d) {
      const t = [k.bind(this), void 0];
      for (t.unshift.apply(t, c), t.push.apply(t, p), h = t.length, l = Promise.resolve(e); a < h; )
        l = l.then(t[a++], t[a++]);
      return l;
    }
    h = c.length;
    let f = e;
    for (a = 0; a < h; ) {
      const t = c[a++], o = c[a++];
      try {
        f = t(f);
      } catch (b) {
        o.call(this, b);
        break;
      }
    }
    try {
      l = k.call(this, f);
    } catch (t) {
      return Promise.reject(t);
    }
    for (a = 0, h = p.length; a < h; )
      l = l.then(p[a++], p[a++]);
    return l;
  }
  getUri(r) {
    r = w(this.defaults, r);
    const e = P(r.baseURL, r.url);
    return S(e, r.params, r.paramsSerializer);
  }
}
export {
  W as default
};
//# sourceMappingURL=Axios.js.map
