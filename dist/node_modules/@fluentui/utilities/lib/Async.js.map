{"version":3,"file":"Async.js","sources":["../../../../../node_modules/@fluentui/utilities/lib/Async.js"],"sourcesContent":["import { getWindow } from './dom/getWindow';\n/**\n * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.\n * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.\n *\n * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a\n * new instance of the class and remember to call dispose() during your code's dispose handler.\n *\n * @public\n */\nvar Async = /** @class */ (function () {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function Async(parent, onError) {\n        this._timeoutIds = null;\n        this._immediateIds = null;\n        this._intervalIds = null;\n        this._animationFrameIds = null;\n        this._isDisposed = false;\n        this._parent = parent || null;\n        this._onErrorHandler = onError;\n        this._noop = function () {\n            /* do nothing */\n        };\n    }\n    /**\n     * Dispose function, clears all async operations.\n     */\n    Async.prototype.dispose = function () {\n        var id;\n        this._isDisposed = true;\n        this._parent = null;\n        // Clear timeouts.\n        if (this._timeoutIds) {\n            for (id in this._timeoutIds) {\n                if (this._timeoutIds.hasOwnProperty(id)) {\n                    this.clearTimeout(parseInt(id, 10));\n                }\n            }\n            this._timeoutIds = null;\n        }\n        // Clear immediates.\n        if (this._immediateIds) {\n            for (id in this._immediateIds) {\n                if (this._immediateIds.hasOwnProperty(id)) {\n                    this.clearImmediate(parseInt(id, 10));\n                }\n            }\n            this._immediateIds = null;\n        }\n        // Clear intervals.\n        if (this._intervalIds) {\n            for (id in this._intervalIds) {\n                if (this._intervalIds.hasOwnProperty(id)) {\n                    this.clearInterval(parseInt(id, 10));\n                }\n            }\n            this._intervalIds = null;\n        }\n        // Clear animation frames.\n        if (this._animationFrameIds) {\n            for (id in this._animationFrameIds) {\n                if (this._animationFrameIds.hasOwnProperty(id)) {\n                    this.cancelAnimationFrame(parseInt(id, 10));\n                }\n            }\n            this._animationFrameIds = null;\n        }\n    };\n    /**\n     * SetTimeout override, which will auto cancel the timeout during dispose.\n     * @param callback - Callback to execute.\n     * @param duration - Duration in milliseconds.\n     * @returns The setTimeout id.\n     */\n    Async.prototype.setTimeout = function (callback, duration) {\n        var _this = this;\n        var timeoutId = 0;\n        if (!this._isDisposed) {\n            if (!this._timeoutIds) {\n                this._timeoutIds = {};\n            }\n            timeoutId = setTimeout(function () {\n                // Time to execute the timeout, enqueue it as a foreground task to be executed.\n                try {\n                    // Now delete the record and call the callback.\n                    if (_this._timeoutIds) {\n                        delete _this._timeoutIds[timeoutId];\n                    }\n                    callback.apply(_this._parent);\n                }\n                catch (e) {\n                    _this._logError(e);\n                }\n            }, duration);\n            this._timeoutIds[timeoutId] = true;\n        }\n        return timeoutId;\n    };\n    /**\n     * Clears the timeout.\n     * @param id - Id to cancel.\n     */\n    Async.prototype.clearTimeout = function (id) {\n        if (this._timeoutIds && this._timeoutIds[id]) {\n            clearTimeout(id);\n            delete this._timeoutIds[id];\n        }\n    };\n    /**\n     * SetImmediate override, which will auto cancel the immediate during dispose.\n     * @param callback - Callback to execute.\n     * @param targetElement - Optional target element to use for identifying the correct window.\n     * @returns The setTimeout id.\n     */\n    Async.prototype.setImmediate = function (callback, targetElement) {\n        var _this = this;\n        var immediateId = 0;\n        var win = getWindow(targetElement);\n        if (!this._isDisposed) {\n            if (!this._immediateIds) {\n                this._immediateIds = {};\n            }\n            var setImmediateCallback = function () {\n                // Time to execute the timeout, enqueue it as a foreground task to be executed.\n                try {\n                    // Now delete the record and call the callback.\n                    if (_this._immediateIds) {\n                        delete _this._immediateIds[immediateId];\n                    }\n                    callback.apply(_this._parent);\n                }\n                catch (e) {\n                    _this._logError(e);\n                }\n            };\n            immediateId = win.setTimeout(setImmediateCallback, 0);\n            this._immediateIds[immediateId] = true;\n        }\n        return immediateId;\n    };\n    /**\n     * Clears the immediate.\n     * @param id - Id to cancel.\n     * @param targetElement - Optional target element to use for identifying the correct window.\n     */\n    Async.prototype.clearImmediate = function (id, targetElement) {\n        var win = getWindow(targetElement);\n        if (this._immediateIds && this._immediateIds[id]) {\n            win.clearTimeout(id);\n            delete this._immediateIds[id];\n        }\n    };\n    /**\n     * SetInterval override, which will auto cancel the timeout during dispose.\n     * @param callback - Callback to execute.\n     * @param duration - Duration in milliseconds.\n     * @returns The setTimeout id.\n     */\n    Async.prototype.setInterval = function (callback, duration) {\n        var _this = this;\n        var intervalId = 0;\n        if (!this._isDisposed) {\n            if (!this._intervalIds) {\n                this._intervalIds = {};\n            }\n            intervalId = setInterval(function () {\n                // Time to execute the interval callback, enqueue it as a foreground task to be executed.\n                try {\n                    callback.apply(_this._parent);\n                }\n                catch (e) {\n                    _this._logError(e);\n                }\n            }, duration);\n            this._intervalIds[intervalId] = true;\n        }\n        return intervalId;\n    };\n    /**\n     * Clears the interval.\n     * @param id - Id to cancel.\n     */\n    Async.prototype.clearInterval = function (id) {\n        if (this._intervalIds && this._intervalIds[id]) {\n            clearInterval(id);\n            delete this._intervalIds[id];\n        }\n    };\n    /**\n     * Creates a function that, when executed, will only call the func function at most once per\n     * every wait milliseconds. Provide an options object to indicate that func should be invoked\n     * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\n     * function will return the result of the last func call.\n     *\n     * Note: If leading and trailing options are true func will be called on the trailing edge of\n     * the timeout only if the throttled function is invoked more than once during the wait timeout.\n     *\n     * @param func - The function to throttle.\n     * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\n     * @param options - The options object.\n     * @returns The new throttled function.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Async.prototype.throttle = function (func, wait, options) {\n        var _this = this;\n        if (this._isDisposed) {\n            return this._noop;\n        }\n        var waitMS = wait || 0;\n        var leading = true;\n        var trailing = true;\n        var lastExecuteTime = 0;\n        var lastResult;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var lastArgs;\n        var timeoutId = null;\n        if (options && typeof options.leading === 'boolean') {\n            leading = options.leading;\n        }\n        if (options && typeof options.trailing === 'boolean') {\n            trailing = options.trailing;\n        }\n        var callback = function (userCall) {\n            var now = Date.now();\n            var delta = now - lastExecuteTime;\n            var waitLength = leading ? waitMS - delta : waitMS;\n            if (delta >= waitMS && (!userCall || leading)) {\n                lastExecuteTime = now;\n                if (timeoutId) {\n                    _this.clearTimeout(timeoutId);\n                    timeoutId = null;\n                }\n                lastResult = func.apply(_this._parent, lastArgs);\n            }\n            else if (timeoutId === null && trailing) {\n                timeoutId = _this.setTimeout(callback, waitLength);\n            }\n            return lastResult;\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var resultFunction = (function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            lastArgs = args;\n            return callback(true);\n        });\n        return resultFunction;\n    };\n    /**\n     * Creates a function that will delay the execution of func until after wait milliseconds have\n     * elapsed since the last time it was invoked. Provide an options object to indicate that func\n     * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\n     * to the debounced function will return the result of the last func call.\n     *\n     * Note: If leading and trailing options are true func will be called on the trailing edge of\n     * the timeout only if the debounced function is invoked more than once during the wait\n     * timeout.\n     *\n     * @param func - The function to debounce.\n     * @param wait - The number of milliseconds to delay.\n     * @param options - The options object.\n     * @returns The new debounced function.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Async.prototype.debounce = function (func, wait, options) {\n        var _this = this;\n        if (this._isDisposed) {\n            var noOpFunction = (function () {\n                /** Do nothing */\n            });\n            noOpFunction.cancel = function () {\n                return;\n            };\n            noOpFunction.flush = (function () { return null; });\n            noOpFunction.pending = function () { return false; };\n            return noOpFunction;\n        }\n        var waitMS = wait || 0;\n        var leading = false;\n        var trailing = true;\n        var maxWait = null;\n        var lastCallTime = 0;\n        var lastExecuteTime = Date.now();\n        var lastResult;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var lastArgs;\n        var timeoutId = null;\n        if (options && typeof options.leading === 'boolean') {\n            leading = options.leading;\n        }\n        if (options && typeof options.trailing === 'boolean') {\n            trailing = options.trailing;\n        }\n        if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\n            maxWait = options.maxWait;\n        }\n        var markExecuted = function (time) {\n            if (timeoutId) {\n                _this.clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n            lastExecuteTime = time;\n        };\n        var invokeFunction = function (time) {\n            markExecuted(time);\n            lastResult = func.apply(_this._parent, lastArgs);\n        };\n        var callback = function (userCall) {\n            var now = Date.now();\n            var executeImmediately = false;\n            if (userCall) {\n                if (leading && now - lastCallTime >= waitMS) {\n                    executeImmediately = true;\n                }\n                lastCallTime = now;\n            }\n            var delta = now - lastCallTime;\n            var waitLength = waitMS - delta;\n            var maxWaitDelta = now - lastExecuteTime;\n            var maxWaitExpired = false;\n            if (maxWait !== null) {\n                // maxWait only matters when there is a pending callback\n                if (maxWaitDelta >= maxWait && timeoutId) {\n                    maxWaitExpired = true;\n                }\n                else {\n                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\n                }\n            }\n            if (delta >= waitMS || maxWaitExpired || executeImmediately) {\n                invokeFunction(now);\n            }\n            else if ((timeoutId === null || !userCall) && trailing) {\n                timeoutId = _this.setTimeout(callback, waitLength);\n            }\n            return lastResult;\n        };\n        var pending = function () {\n            return !!timeoutId;\n        };\n        var cancel = function () {\n            if (pending()) {\n                // Mark the debounced function as having executed\n                markExecuted(Date.now());\n            }\n        };\n        var flush = function () {\n            if (pending()) {\n                invokeFunction(Date.now());\n            }\n            return lastResult;\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var resultFunction = (function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            lastArgs = args;\n            return callback(true);\n        });\n        resultFunction.cancel = cancel;\n        resultFunction.flush = flush;\n        resultFunction.pending = pending;\n        return resultFunction;\n    };\n    Async.prototype.requestAnimationFrame = function (callback, targetElement) {\n        var _this = this;\n        var animationFrameId = 0;\n        var win = getWindow(targetElement);\n        if (!this._isDisposed) {\n            if (!this._animationFrameIds) {\n                this._animationFrameIds = {};\n            }\n            var animationFrameCallback = function () {\n                try {\n                    // Now delete the record and call the callback.\n                    if (_this._animationFrameIds) {\n                        delete _this._animationFrameIds[animationFrameId];\n                    }\n                    callback.apply(_this._parent);\n                }\n                catch (e) {\n                    _this._logError(e);\n                }\n            };\n            animationFrameId = win.requestAnimationFrame\n                ? win.requestAnimationFrame(animationFrameCallback)\n                : win.setTimeout(animationFrameCallback, 0);\n            this._animationFrameIds[animationFrameId] = true;\n        }\n        return animationFrameId;\n    };\n    Async.prototype.cancelAnimationFrame = function (id, targetElement) {\n        var win = getWindow(targetElement);\n        if (this._animationFrameIds && this._animationFrameIds[id]) {\n            win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);\n            delete this._animationFrameIds[id];\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Async.prototype._logError = function (e) {\n        if (this._onErrorHandler) {\n            this._onErrorHandler(e);\n        }\n    };\n    return Async;\n}());\nexport { Async };\n//# sourceMappingURL=Async.js.map"],"names":["Async","parent","onError","id","callback","duration","_this","timeoutId","e","targetElement","immediateId","win","getWindow","setImmediateCallback","intervalId","func","wait","options","waitMS","leading","trailing","lastExecuteTime","lastResult","lastArgs","userCall","now","delta","waitLength","resultFunction","args","_i","noOpFunction","maxWait","lastCallTime","markExecuted","time","invokeFunction","executeImmediately","maxWaitDelta","maxWaitExpired","pending","cancel","flush","animationFrameId","animationFrameCallback"],"mappings":"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","x_google_ignoreList":[0]}