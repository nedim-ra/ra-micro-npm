{"version":3,"file":"focus.js","sources":["../../../../../node_modules/@fluentui/utilities/lib/focus.js"],"sourcesContent":["import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones, includeShadowRoots) {\n    return getNextElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones, undefined, undefined, undefined, includeShadowRoots);\n}\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones, includeShadowRoots) {\n    return getPreviousElement(rootElement, currentElement, true /*checkNode*/, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones, undefined, undefined, includeShadowRoots);\n}\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode, includeShadowRoots) {\n    if (checkNode === void 0) { checkNode = true; }\n    return getNextElement(rootElement, currentElement, checkNode, false /*suppressParentTraversal*/, false /*suppressChildTraversal*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/, undefined, includeShadowRoots);\n}\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode, includeShadowRoots) {\n    if (checkNode === void 0) { checkNode = true; }\n    return getPreviousElement(rootElement, currentElement, checkNode, false /*suppressParentTraversal*/, true /*traverseChildren*/, includeElementsInFocusZones, false /*allowFocusRoot*/, true /*tabbable*/, includeShadowRoots);\n}\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n * @returns True if focus was set, false if it was not.\n */\nexport function focusFirstChild(rootElement, bypassHiddenElements, includeShadowRoots) {\n    var element = getNextElement(rootElement, rootElement, true, false, false, true, undefined, undefined, bypassHiddenElements, includeShadowRoots);\n    if (element) {\n        focusAsync(element);\n        return true;\n    }\n    return false;\n}\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots) {\n    var _a;\n    if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {\n        return null;\n    }\n    var isCurrentElementVisible = isElementVisible(currentElement);\n    // Check its children.\n    if (traverseChildren &&\n        isCurrentElementVisible &&\n        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n        var lastElementChild = (currentElement.lastElementChild ||\n            (includeShadowRoots && ((_a = currentElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.lastElementChild)));\n        var childMatch = getPreviousElement(rootElement, lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n        if (childMatch) {\n            if ((tabbable && isElementTabbable(childMatch, true, includeShadowRoots)) || !tabbable) {\n                return childMatch;\n            }\n            var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n            if (childMatchSiblingMatch) {\n                return childMatchSiblingMatch;\n            }\n            var childMatchParent = childMatch.parentElement;\n            // At this point if we have not found any potential matches\n            // start looking at the rest of the subtree under the currentParent.\n            // NOTE: We do not want to recurse here because doing so could\n            // cause elements to get skipped.\n            while (childMatchParent && childMatchParent !== currentElement) {\n                var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n                if (childMatchParentMatch) {\n                    return childMatchParentMatch;\n                }\n                childMatchParent = childMatchParent.parentElement;\n            }\n        }\n    }\n    // Check the current node, if it's not the first traversal.\n    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n        return currentElement;\n    }\n    // Check its previous sibling.\n    var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n    if (siblingMatch) {\n        return siblingMatch;\n    }\n    // Check its parent.\n    if (!suppressParentTraversal) {\n        return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable, includeShadowRoots);\n    }\n    return null;\n}\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\nexport function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots) {\n    var _a;\n    if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {\n        return null;\n    }\n    var checkElementVisibility = bypassHiddenElements ? isElementVisibleAndNotHidden : isElementVisible;\n    var isCurrentElementVisible = checkElementVisibility(currentElement);\n    // Check the current node, if it's not the first traversal.\n    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable, includeShadowRoots)) {\n        return currentElement;\n    }\n    // Check its children.\n    if (!suppressChildTraversal &&\n        isCurrentElementVisible &&\n        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n        var firstElementchild = (currentElement.firstElementChild ||\n            (includeShadowRoots && ((_a = currentElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.firstElementChild)));\n        var childMatch = getNextElement(rootElement, firstElementchild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots);\n        if (childMatch) {\n            return childMatch;\n        }\n    }\n    if (currentElement === rootElement) {\n        return null;\n    }\n    // Check its sibling.\n    var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots);\n    if (siblingMatch) {\n        return siblingMatch;\n    }\n    if (!suppressParentTraversal) {\n        return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements, includeShadowRoots);\n    }\n    return null;\n}\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element) {\n    // If the element is not valid, return false.\n    if (!element || !element.getAttribute) {\n        return false;\n    }\n    var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n    // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n    if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n        return visibilityAttribute === 'true';\n    }\n    // Fallback to other methods of determining actual visibility.\n    return (element.offsetHeight !== 0 ||\n        element.offsetParent !== null ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        element.isVisible === true); // used as a workaround for testing.\n}\n/**\n * Determines if an element is visible and not hidden\n * @param element - Element to check\n * @returns Returns true if the given element is visible and not hidden\n *\n * @public\n */\nexport function isElementVisibleAndNotHidden(element, win) {\n    var theWin = win !== null && win !== void 0 ? win : getWindow();\n    return (!!element &&\n        isElementVisible(element) &&\n        !element.hidden &&\n        theWin.getComputedStyle(element).visibility !== 'hidden');\n}\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(element, checkTabIndex, checkShadowRoot) {\n    if (checkShadowRoot === void 0) { checkShadowRoot = true; }\n    // If this element is null or is disabled, it is not considered tabbable.\n    if (!element || element.disabled) {\n        return false;\n    }\n    var tabIndex = 0;\n    var tabIndexAttributeValue = null;\n    if (element && element.getAttribute) {\n        tabIndexAttributeValue = element.getAttribute('tabIndex');\n        if (tabIndexAttributeValue) {\n            tabIndex = parseInt(tabIndexAttributeValue, 10);\n        }\n    }\n    var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n    var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n    var delegatesFocus = checkShadowRoot && element.shadowRoot ? !!element.shadowRoot.delegatesFocus : false;\n    var result = !!element &&\n        isFocusableAttribute !== 'false' &&\n        (element.tagName === 'A' ||\n            element.tagName === 'BUTTON' ||\n            element.tagName === 'INPUT' ||\n            element.tagName === 'TEXTAREA' ||\n            element.tagName === 'SELECT' ||\n            isFocusableAttribute === 'true' ||\n            isTabIndexSet ||\n            delegatesFocus);\n    return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element) {\n    return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element) {\n    return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\nexport function doesElementContainFocus(element) {\n    var doc = getDocument(element);\n    var currentActiveElement = doc && doc.activeElement;\n    if (currentActiveElement && elementContains(element, currentActiveElement)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\nexport function shouldWrapFocus(element, noWrapDataAttribute, doc) {\n    var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();\n    return elementContainsAttribute(element, noWrapDataAttribute, theDoc) === 'true' ? false : true;\n}\nvar animationId = undefined;\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element) {\n    if (element) {\n        var win = getWindow(element);\n        if (win) {\n            // cancel any previous focus queues\n            if (animationId !== undefined) {\n                win.cancelAnimationFrame(animationId);\n            }\n            // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n            animationId = win.requestAnimationFrame(function () {\n                element && element.focus();\n                // We are done focusing for this frame, so reset the queued focus element\n                animationId = undefined;\n            });\n        }\n    }\n}\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent, path) {\n    var element = parent;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var index = path_1[_i];\n        var nextChild = element.children[Math.min(index, element.children.length - 1)];\n        if (!nextChild) {\n            break;\n        }\n        element = nextChild;\n    }\n    element =\n        isElementTabbable(element) && isElementVisible(element)\n            ? element\n            : getNextElement(parent, element, true) || getPreviousElement(parent, element);\n    return element;\n}\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement, toElement) {\n    var path = [];\n    while (toElement && fromElement && toElement !== fromElement) {\n        var parent_1 = getParent(toElement, true);\n        if (parent_1 === null) {\n            return [];\n        }\n        path.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));\n        toElement = parent_1;\n    }\n    return path;\n}\n//# sourceMappingURL=focus.js.map"],"names":["IS_FOCUSABLE_ATTRIBUTE","IS_VISIBLE_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","FOCUSZONE_SUB_ATTRIBUTE","getFirstFocusable","rootElement","currentElement","includeElementsInFocusZones","includeShadowRoots","getNextElement","getLastFocusable","getPreviousElement","focusFirstChild","bypassHiddenElements","element","focusAsync","checkNode","suppressParentTraversal","traverseChildren","allowFocusRoot","tabbable","isCurrentElementVisible","isElementVisible","isElementFocusZone","isElementFocusSubZone","lastElementChild","childMatch","isElementTabbable","siblingMatch","suppressChildTraversal","checkElementVisibility","isElementVisibleAndNotHidden","firstElementchild","visibilityAttribute","win","theWin","getWindow","checkTabIndex","checkShadowRoot","tabIndex","tabIndexAttributeValue","isFocusableAttribute","isTabIndexSet","delegatesFocus","result","doesElementContainFocus","doc","getDocument","currentActiveElement","elementContains","shouldWrapFocus","noWrapDataAttribute","theDoc","elementContainsAttribute","animationId","getFocusableByIndexPath","parent","path","_i","path_1","index","nextChild","getElementIndexPath","fromElement","toElement","parent_1","getParent"],"mappings":"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","x_google_ignoreList":[0]}