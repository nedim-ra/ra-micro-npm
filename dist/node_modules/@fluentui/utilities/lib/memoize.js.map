{"version":3,"file":"memoize.js","sources":["../../../../../node_modules/@fluentui/utilities/lib/memoize.js"],"sourcesContent":["import { Stylesheet } from '@fluentui/merge-styles';\nvar _initializedStylesheetResets = false;\nvar _resetCounter = 0;\nvar _emptyObject = { empty: true };\nvar _dictionary = {};\nvar _weakMap = typeof WeakMap === 'undefined' ? null : WeakMap;\n/**\n *  Test utility for providing a custom weakmap.\n *\n * @internal\n * */\nexport function setMemoizeWeakMap(weakMap) {\n    _weakMap = weakMap;\n}\n/**\n * Reset memoizations.\n */\nexport function resetMemoizations() {\n    _resetCounter++;\n}\n/**\n * Memoize decorator to be used on class methods. WARNING: the `this` reference\n * will be inaccessible within a memoized method, given that a cached method's `this`\n * would not be instance-specific.\n *\n * @public\n */\nexport function memoize(_target, _key, descriptor) {\n    // We bind to \"null\" to prevent people from inadvertently pulling values from \"this\",\n    // rather than passing them in as input values which can be memoized.\n    var fn = memoizeFunction(descriptor.value && descriptor.value.bind(null));\n    return {\n        configurable: true,\n        get: function () {\n            return fn;\n        },\n    };\n}\n/**\n * Memoizes a function; when you pass in the same parameters multiple times, it returns a cached result.\n * Be careful when passing in objects, you need to pass in the same INSTANCE for caching to work. Otherwise\n * it will grow the cache unnecessarily. Also avoid using default values that evaluate functions; passing in\n * undefined for a value and relying on a default function will execute it the first time, but will not\n * re-evaluate subsequent times which may have been unexpected.\n *\n * By default, the cache will reset after 100 permutations, to avoid abuse cases where the function is\n * unintendedly called with unique objects. Without a reset, the cache could grow infinitely, so we safeguard\n * by resetting. To override this behavior, pass a value of 0 to the maxCacheSize parameter.\n *\n * @public\n * @param cb - The function to memoize.\n * @param maxCacheSize - Max results to cache. If the cache exceeds this value, it will reset on the next call.\n * @param ignoreNullOrUndefinedResult - Flag to decide whether to cache callback result if it is undefined/null.\n * If the flag is set to true, the callback result is recomputed every time till the callback result is\n * not undefined/null for the first time, and then the non-undefined/null version gets cached.\n * @returns A memoized version of the function.\n */\nexport function memoizeFunction(cb, maxCacheSize, ignoreNullOrUndefinedResult) {\n    if (maxCacheSize === void 0) { maxCacheSize = 100; }\n    if (ignoreNullOrUndefinedResult === void 0) { ignoreNullOrUndefinedResult = false; }\n    // Avoid breaking scenarios which don't have weak map.\n    if (!_weakMap) {\n        return cb;\n    }\n    if (!_initializedStylesheetResets) {\n        var stylesheet = Stylesheet.getInstance();\n        if (stylesheet && stylesheet.onReset) {\n            Stylesheet.getInstance().onReset(resetMemoizations);\n        }\n        _initializedStylesheetResets = true;\n    }\n    var rootNode;\n    var cacheSize = 0;\n    var localResetCounter = _resetCounter;\n    return function memoizedFunction() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var currentNode = rootNode;\n        if (rootNode === undefined ||\n            localResetCounter !== _resetCounter ||\n            (maxCacheSize > 0 && cacheSize > maxCacheSize)) {\n            rootNode = _createNode();\n            cacheSize = 0;\n            localResetCounter = _resetCounter;\n        }\n        currentNode = rootNode;\n        // Traverse the tree until we find the match.\n        for (var i = 0; i < args.length; i++) {\n            var arg = _normalizeArg(args[i]);\n            if (!currentNode.map.has(arg)) {\n                currentNode.map.set(arg, _createNode());\n            }\n            currentNode = currentNode.map.get(arg);\n        }\n        if (!currentNode.hasOwnProperty('value')) {\n            currentNode.value = cb.apply(void 0, args);\n            cacheSize++;\n        }\n        if (ignoreNullOrUndefinedResult && (currentNode.value === null || currentNode.value === undefined)) {\n            currentNode.value = cb.apply(void 0, args);\n        }\n        return currentNode.value;\n    };\n}\n/**\n * Creates a memoizer for a single-value function, backed by a WeakMap.\n * With a WeakMap, the memoized values are only kept as long as the source objects,\n * ensuring that there is no memory leak.\n *\n * This function assumes that the input values passed to the wrapped function will be\n * `function` or `object` types. To memoize functions which accept other inputs, use\n * `memoizeFunction`, which memoizes against arbitrary inputs using a lookup cache.\n *\n * @public\n */\nexport function createMemoizer(getValue) {\n    if (!_weakMap) {\n        // Without a `WeakMap` implementation, memoization is not possible.\n        return getValue;\n    }\n    var cache = new _weakMap();\n    function memoizedGetValue(input) {\n        if (!input || (typeof input !== 'function' && typeof input !== 'object')) {\n            // A WeakMap can only be used to test against reference values, i.e. 'function' and 'object'.\n            // All other inputs cannot be memoized against in this manner.\n            return getValue(input);\n        }\n        if (cache.has(input)) {\n            return cache.get(input);\n        }\n        var value = getValue(input);\n        cache.set(input, value);\n        return value;\n    }\n    return memoizedGetValue;\n}\nfunction _normalizeArg(val) {\n    if (!val) {\n        return _emptyObject;\n    }\n    else if (typeof val === 'object' || typeof val === 'function') {\n        return val;\n    }\n    else if (!_dictionary[val]) {\n        _dictionary[val] = { val: val };\n    }\n    return _dictionary[val];\n}\nfunction _createNode() {\n    return {\n        map: _weakMap ? new _weakMap() : null,\n    };\n}\n//# sourceMappingURL=memoize.js.map"],"names":["_initializedStylesheetResets","_resetCounter","_emptyObject","_dictionary","_weakMap","resetMemoizations","memoizeFunction","cb","maxCacheSize","ignoreNullOrUndefinedResult","stylesheet","Stylesheet","rootNode","cacheSize","localResetCounter","args","_i","currentNode","_createNode","i","arg","_normalizeArg","createMemoizer","getValue","cache","memoizedGetValue","input","value","val"],"mappings":";AACA,IAAIA,IAA+B,IAC/BC,IAAgB,GAChBC,IAAe,EAAE,OAAO,MACxBC,IAAc,CAAA,GACdC,IAAW,OAAO,UAAY,MAAc,OAAO;AAYhD,SAASC,IAAoB;AAChC,EAAAJ;AACJ;AAsCO,SAASK,EAAgBC,GAAIC,GAAcC,GAA6B;AAI3E,MAHID,MAAiB,WAAUA,IAAe,MAC1CC,MAAgC,WAAUA,IAA8B,KAExE,CAACL;AACD,WAAOG;AAEX,MAAI,CAACP,GAA8B;AAC/B,QAAIU,IAAaC,EAAW;AAC5B,IAAID,KAAcA,EAAW,WACzBC,EAAW,YAAW,EAAG,QAAQN,CAAiB,GAEtDL,IAA+B;AAAA,EAClC;AACD,MAAIY,GACAC,IAAY,GACZC,IAAoBb;AACxB,SAAO,WAA4B;AAE/B,aADIc,IAAO,CAAA,GACFC,IAAK,GAAGA,IAAK,UAAU,QAAQA;AACpC,MAAAD,EAAKC,CAAE,IAAI,UAAUA,CAAE;AAE3B,QAAIC,IAAcL;AAClB,KAAIA,MAAa,UACbE,MAAsBb,KACrBO,IAAe,KAAKK,IAAYL,OACjCI,IAAWM,EAAW,GACtBL,IAAY,GACZC,IAAoBb,IAExBgB,IAAcL;AAEd,aAASO,IAAI,GAAGA,IAAIJ,EAAK,QAAQI,KAAK;AAClC,UAAIC,IAAMC,EAAcN,EAAKI,CAAC,CAAC;AAC/B,MAAKF,EAAY,IAAI,IAAIG,CAAG,KACxBH,EAAY,IAAI,IAAIG,GAAKF,EAAa,CAAA,GAE1CD,IAAcA,EAAY,IAAI,IAAIG,CAAG;AAAA,IACxC;AACD,WAAKH,EAAY,eAAe,OAAO,MACnCA,EAAY,QAAQV,EAAG,MAAM,QAAQQ,CAAI,GACzCF,MAEAJ,MAAgCQ,EAAY,UAAU,QAAQA,EAAY,UAAU,YACpFA,EAAY,QAAQV,EAAG,MAAM,QAAQQ,CAAI,IAEtCE,EAAY;AAAA,EAC3B;AACA;AAYO,SAASK,EAAeC,GAAU;AACrC,MAAI,CAACnB;AAED,WAAOmB;AAEX,MAAIC,IAAQ,IAAIpB;AAChB,WAASqB,EAAiBC,GAAO;AAC7B,QAAI,CAACA,KAAU,OAAOA,KAAU,cAAc,OAAOA,KAAU;AAG3D,aAAOH,EAASG,CAAK;AAEzB,QAAIF,EAAM,IAAIE,CAAK;AACf,aAAOF,EAAM,IAAIE,CAAK;AAE1B,QAAIC,IAAQJ,EAASG,CAAK;AAC1B,WAAAF,EAAM,IAAIE,GAAOC,CAAK,GACfA;AAAA,EACV;AACD,SAAOF;AACX;AACA,SAASJ,EAAcO,GAAK;AACxB,MAAKA,GAGA;AAAA,QAAI,OAAOA,KAAQ,YAAY,OAAOA,KAAQ;AAC/C,aAAOA;AAEN,IAAKzB,EAAYyB,CAAG,MACrBzB,EAAYyB,CAAG,IAAI,EAAE,KAAKA,EAAG;AAAA,QAN7B,QAAO1B;AAQX,SAAOC,EAAYyB,CAAG;AAC1B;AACA,SAASV,IAAc;AACnB,SAAO;AAAA,IACH,KAAKd,IAAW,IAAIA,EAAQ,IAAK;AAAA,EACzC;AACA;","x_google_ignoreList":[0]}