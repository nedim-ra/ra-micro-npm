{"version":3,"file":"classNamesFunction.js","sources":["../../../../../node_modules/@fluentui/utilities/lib/classNamesFunction.js"],"sourcesContent":["import { mergeCssSets, Stylesheet } from '@fluentui/merge-styles';\nimport { getRTL } from './rtl';\nimport { getWindow } from './dom';\nvar MAX_CACHE_COUNT = 50;\nvar DEFAULT_SPECIFICITY_MULTIPLIER = 5;\nvar _memoizedClassNames = 0;\nvar stylesheet = Stylesheet.getInstance();\nif (stylesheet && stylesheet.onReset) {\n    stylesheet.onReset(function () { return _memoizedClassNames++; });\n}\n// Note that because of the caching nature within the classNames memoization,\n// I've disabled this rule to simply be able to work with any types.\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// This represents a prop we attach to each Map to indicate the cached return value\n// associated with the graph node.\nvar retVal = '__retval__';\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n *\n * Note that the props you pass in on every render should be in the same order and\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\n * these will cause extra recalcs to occur.\n */\nexport function classNamesFunction(options) {\n    // We build a trie where each node is a Map. The map entry key represents an argument\n    // value, and the entry value is another node (Map). Each node has a `__retval__`\n    // property which is used to hold the cached response.\n    if (options === void 0) { options = {}; }\n    // To derive the response, we can simply ensure the arguments are added or already\n    // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\n    // we call the `getStyles` api to evaluate, cache on the property, and return that.\n    // let map: IRecursiveMemoNode = new Map();\n    var windowMap = new Map();\n    var styleCalcCount = 0;\n    var getClassNamesCount = 0;\n    var currentMemoizedClassNames = _memoizedClassNames;\n    var getClassNames = function (styleFunctionOrObject, styleProps) {\n        var _a;\n        if (styleProps === void 0) { styleProps = {}; }\n        // If useStaticStyles is true, styleFunctionOrObject returns slot to classname mappings.\n        // If there is also no style overrides, we can skip merge styles completely and\n        // simply return the result from the style funcion.\n        if (options.useStaticStyles &&\n            typeof styleFunctionOrObject === 'function' &&\n            styleFunctionOrObject.__noStyleOverride__) {\n            return styleFunctionOrObject(styleProps);\n        }\n        getClassNamesCount++;\n        var shadowConfig = styleFunctionOrObject\n            ? styleFunctionOrObject.__shadowConfig__\n            : undefined;\n        var key = shadowConfig && shadowConfig.window ? shadowConfig.window : '__default__';\n        if (!windowMap.has(key)) {\n            windowMap.set(key, new Map());\n        }\n        var current = windowMap.get(key);\n        // let current: Map<any, any> = map;\n        var theme = styleProps.theme;\n        var rtl = theme && theme.rtl !== undefined ? theme.rtl : getRTL();\n        var disableCaching = options.disableCaching;\n        // On reset of our stylesheet, reset memoized cache.\n        if (currentMemoizedClassNames !== _memoizedClassNames) {\n            currentMemoizedClassNames = _memoizedClassNames;\n            // map = new Map();\n            windowMap.set(key, new Map());\n            current = windowMap.get(key);\n            styleCalcCount = 0;\n        }\n        if (!options.disableCaching) {\n            current = _traverseMap(windowMap.get(key), styleFunctionOrObject);\n            current = _traverseMap(current, styleProps);\n        }\n        if (disableCaching || !current[retVal]) {\n            if (styleFunctionOrObject === undefined) {\n                current[retVal] = {};\n            }\n            else {\n                current[retVal] = mergeCssSets([\n                    (typeof styleFunctionOrObject === 'function'\n                        ? styleFunctionOrObject(styleProps)\n                        : styleFunctionOrObject),\n                ], {\n                    shadowConfig: styleFunctionOrObject.__shadowConfig__,\n                    rtl: !!rtl,\n                    specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : undefined,\n                });\n            }\n            if (!disableCaching) {\n                styleCalcCount++;\n            }\n        }\n        if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {\n            var win = getWindow();\n            if ((_a = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _a === void 0 ? void 0 : _a.enableClassNameCacheFullWarning) {\n                // eslint-disable-next-line no-console\n                console.warn(\"Styles are being recalculated too frequently. Cache miss rate is \".concat(styleCalcCount, \"/\").concat(getClassNamesCount, \".\"));\n                // eslint-disable-next-line no-console\n                console.trace();\n            }\n            windowMap.get(key).clear();\n            styleCalcCount = 0;\n            // Mutate the options passed in, that's all we can do.\n            options.disableCaching = true;\n        }\n        // Note: the retVal is an attached property on the Map; not a key in the Map. We use this attached property to\n        // cache the return value for this branch of the graph.\n        return current[retVal];\n    };\n    return getClassNames;\n}\nfunction _traverseEdge(current, value) {\n    value = _normalizeValue(value);\n    if (!current.has(value)) {\n        current.set(value, new Map());\n    }\n    return current.get(value);\n}\nfunction _traverseMap(current, inputs) {\n    if (typeof inputs === 'function') {\n        var cachedInputsFromStyled = inputs.__cachedInputs__;\n        if (cachedInputsFromStyled) {\n            // The styled helper will generate the styles function and will attach the cached\n            // inputs (consisting of the default styles, customzied styles, and user provided styles.)\n            // These should be used as cache keys for deriving the memoized value.\n            for (var _i = 0, _a = inputs.__cachedInputs__; _i < _a.length; _i++) {\n                var input = _a[_i];\n                current = _traverseEdge(current, input);\n            }\n        }\n        else {\n            current = _traverseEdge(current, inputs);\n        }\n    }\n    else if (typeof inputs === 'object') {\n        for (var propName in inputs) {\n            if (inputs.hasOwnProperty(propName)) {\n                current = _traverseEdge(current, inputs[propName]);\n            }\n        }\n    }\n    return current;\n}\nfunction _normalizeValue(value) {\n    switch (value) {\n        case undefined:\n            return '__undefined__';\n        case null:\n            return '__null__';\n        default:\n            return value;\n    }\n}\n//# sourceMappingURL=classNamesFunction.js.map"],"names":["MAX_CACHE_COUNT","DEFAULT_SPECIFICITY_MULTIPLIER","_memoizedClassNames","retVal","classNamesFunction","options","windowMap","styleCalcCount","getClassNamesCount","currentMemoizedClassNames","getClassNames","styleFunctionOrObject","styleProps","_a","shadowConfig","key","current","theme","rtl","getRTL","disableCaching","_traverseMap","mergeCssSets","win","getWindow","_traverseEdge","value","_normalizeValue","inputs","cachedInputsFromStyled","_i","input","propName"],"mappings":"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","x_google_ignoreList":[0]}