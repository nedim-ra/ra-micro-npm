{"version":3,"file":"scroll.js","sources":["../../../../../node_modules/@fluentui/utilities/lib/scroll.js"],"sourcesContent":["import { getDocument } from './dom/getDocument';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getWindow } from './dom/getWindow';\nvar _scrollbarWidth;\nvar _bodyScrollDisabledCount = 0;\nvar DisabledScrollClassName = mergeStyles({\n    overflow: 'hidden !important',\n});\n/**\n * Placing this attribute on scrollable divs optimizes detection to know\n * if the div is scrollable or not (given we can avoid expensive operations\n * like getComputedStyle.)\n *\n * @public\n */\nexport var DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';\n/**\n * Allows the user to scroll within a element,\n * while preventing the user from scrolling the body\n */\nexport var allowScrollOnElement = function (element, events) {\n    var window = getWindow(element);\n    if (!element || !window) {\n        return;\n    }\n    var _previousClientY = 0;\n    var _element = null;\n    var computedStyles = window.getComputedStyle(element);\n    // remember the clientY for future calls of _preventOverscrolling\n    var _saveClientY = function (event) {\n        if (event.targetTouches.length === 1) {\n            _previousClientY = event.targetTouches[0].clientY;\n        }\n    };\n    // prevent the body from scrolling when the user attempts\n    // to scroll past the top or bottom of the element\n    var _preventOverscrolling = function (event) {\n        // only respond to a single-finger touch\n        if (event.targetTouches.length !== 1) {\n            return;\n        }\n        // prevent the body touchmove handler from firing\n        // so that scrolling is allowed within the element\n        event.stopPropagation();\n        if (!_element) {\n            return;\n        }\n        var clientY = event.targetTouches[0].clientY - _previousClientY;\n        var scrollableParent = findScrollableParent(event.target);\n        if (scrollableParent && _element !== scrollableParent) {\n            _element = scrollableParent;\n            computedStyles = window.getComputedStyle(_element);\n        }\n        var scrollTop = _element.scrollTop;\n        var isColumnReverse = (computedStyles === null || computedStyles === void 0 ? void 0 : computedStyles.flexDirection) === 'column-reverse';\n        // if the element is scrolled to the top,\n        // prevent the user from scrolling up\n        if (scrollTop === 0 && (isColumnReverse ? clientY < 0 : clientY > 0)) {\n            event.preventDefault();\n        }\n        // if the element is scrolled to the bottom,\n        // prevent the user from scrolling down\n        if (_element.scrollHeight - Math.abs(Math.ceil(scrollTop)) <= _element.clientHeight &&\n            (isColumnReverse ? clientY > 0 : clientY < 0)) {\n            event.preventDefault();\n        }\n    };\n    events.on(element, 'touchstart', _saveClientY, { passive: false });\n    events.on(element, 'touchmove', _preventOverscrolling, { passive: false });\n    _element = element;\n};\n/**\n * Same as allowScrollOnElement but does not prevent overscrolling.\n */\nexport var allowOverscrollOnElement = function (element, events) {\n    if (!element) {\n        return;\n    }\n    var _allowElementScroll = function (event) {\n        event.stopPropagation();\n    };\n    events.on(element, 'touchmove', _allowElementScroll, { passive: false });\n};\nvar _disableIosBodyScroll = function (event) {\n    event.preventDefault();\n};\n/**\n * Disables the body scrolling.\n *\n * @public\n */\nexport function disableBodyScroll() {\n    var doc = getDocument();\n    if (doc && doc.body && !_bodyScrollDisabledCount) {\n        doc.body.classList.add(DisabledScrollClassName);\n        doc.body.addEventListener('touchmove', _disableIosBodyScroll, { passive: false, capture: false });\n    }\n    _bodyScrollDisabledCount++;\n}\n/**\n * Enables the body scrolling.\n *\n * @public\n */\nexport function enableBodyScroll() {\n    if (_bodyScrollDisabledCount > 0) {\n        var doc = getDocument();\n        if (doc && doc.body && _bodyScrollDisabledCount === 1) {\n            doc.body.classList.remove(DisabledScrollClassName);\n            doc.body.removeEventListener('touchmove', _disableIosBodyScroll);\n        }\n        _bodyScrollDisabledCount--;\n    }\n}\n/**\n * Calculates the width of a scrollbar for the browser/os.\n *\n * @public\n */\nexport function getScrollbarWidth(doc) {\n    if (_scrollbarWidth === undefined) {\n        var theDoc = doc !== null && doc !== void 0 ? doc : getDocument();\n        var scrollDiv = theDoc.createElement('div');\n        scrollDiv.style.setProperty('width', '100px');\n        scrollDiv.style.setProperty('height', '100px');\n        scrollDiv.style.setProperty('overflow', 'scroll');\n        scrollDiv.style.setProperty('position', 'absolute');\n        scrollDiv.style.setProperty('top', '-9999px');\n        theDoc.body.appendChild(scrollDiv);\n        // Get the scrollbar width\n        _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n        // Delete the DIV\n        theDoc.body.removeChild(scrollDiv);\n    }\n    return _scrollbarWidth;\n}\n/**\n * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns\n * document.body.\n *\n * @public\n */\nexport function findScrollableParent(startingElement) {\n    var el = startingElement;\n    var doc = getDocument(startingElement);\n    // First do a quick scan for the scrollable attribute.\n    while (el && el !== doc.body) {\n        if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {\n            return el;\n        }\n        el = el.parentElement;\n    }\n    // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.\n    el = startingElement;\n    while (el && el !== doc.body) {\n        if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {\n            var computedStyles = getComputedStyle(el);\n            var overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';\n            if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {\n                return el;\n            }\n        }\n        el = el.parentElement;\n    }\n    // Fall back to window scroll.\n    if (!el || el === doc.body) {\n        el = getWindow(startingElement);\n    }\n    return el;\n}\n//# sourceMappingURL=scroll.js.map"],"names":["_scrollbarWidth","DATA_IS_SCROLLABLE_ATTRIBUTE","getScrollbarWidth","doc","theDoc","getDocument","scrollDiv","findScrollableParent","startingElement","el","computedStyles","overflowY","getWindow"],"mappings":";;;AAGA,IAAIA,GAYOC,IAA+B;AAwGnC,SAASC,EAAkBC,GAAK;AACnC,MAAIH,MAAoB,QAAW;AAC/B,QAAII,IAAgDC,KAChDC,IAAYF,EAAO,cAAc,KAAK;AAC1C,IAAAE,EAAU,MAAM,YAAY,SAAS,OAAO,GAC5CA,EAAU,MAAM,YAAY,UAAU,OAAO,GAC7CA,EAAU,MAAM,YAAY,YAAY,QAAQ,GAChDA,EAAU,MAAM,YAAY,YAAY,UAAU,GAClDA,EAAU,MAAM,YAAY,OAAO,SAAS,GAC5CF,EAAO,KAAK,YAAYE,CAAS,GAEjCN,IAAkBM,EAAU,cAAcA,EAAU,aAEpDF,EAAO,KAAK,YAAYE,CAAS;AAAA,EACpC;AACD,SAAON;AACX;AAOO,SAASO,EAAqBC,GAAiB;AAIlD,WAHIC,IAAKD,GACLL,IAAME,EAAYG,CAAe,GAE9BC,KAAMA,MAAON,EAAI,QAAM;AAC1B,QAAIM,EAAG,aAAaR,CAA4B,MAAM;AAClD,aAAOQ;AAEX,IAAAA,IAAKA,EAAG;AAAA,EACX;AAGD,OADAA,IAAKD,GACEC,KAAMA,MAAON,EAAI,QAAM;AAC1B,QAAIM,EAAG,aAAaR,CAA4B,MAAM,SAAS;AAC3D,UAAIS,IAAiB,iBAAiBD,CAAE,GACpCE,IAAYD,IAAiBA,EAAe,iBAAiB,YAAY,IAAI;AACjF,UAAIC,MAAcA,MAAc,YAAYA,MAAc;AACtD,eAAOF;AAAA,IAEd;AACD,IAAAA,IAAKA,EAAG;AAAA,EACX;AAED,UAAI,CAACA,KAAMA,MAAON,EAAI,UAClBM,IAAKG,EAAUJ,CAAe,IAE3BC;AACX;","x_google_ignoreList":[0]}