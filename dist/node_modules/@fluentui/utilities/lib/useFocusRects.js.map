{"version":3,"file":"useFocusRects.js","sources":["../../../../../node_modules/@fluentui/utilities/lib/useFocusRects.js"],"sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\nvar mountCounters = new WeakMap();\nvar callbackMap = new WeakMap();\nfunction setMountCounters(key, delta) {\n    var newValue;\n    var currValue = mountCounters.get(key);\n    if (currValue) {\n        newValue = currValue + delta;\n    }\n    else {\n        newValue = 1;\n    }\n    mountCounters.set(key, newValue);\n    return newValue;\n}\nfunction setCallbackMap(context) {\n    var callbacks = callbackMap.get(context);\n    if (callbacks) {\n        return callbacks;\n    }\n    var onMouseDown = function (ev) { return _onMouseDown(ev, context.registeredProviders); };\n    var onPointerDown = function (ev) { return _onPointerDown(ev, context.registeredProviders); };\n    var onKeyDown = function (ev) { return _onKeyDown(ev, context.registeredProviders); };\n    var onKeyUp = function (ev) { return _onKeyUp(ev, context.registeredProviders); };\n    callbacks = { onMouseDown: onMouseDown, onPointerDown: onPointerDown, onKeyDown: onKeyDown, onKeyUp: onKeyUp };\n    callbackMap.set(context, callbacks);\n    return callbacks;\n}\nexport var FocusRectsContext = React.createContext(undefined);\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown, keyup, mousedown and pointerdown events. (It will only do it once for the current element of\n *    the FocusRectsContext providerRef or once per window if no such element is provided via context, so it's safe to\n *    call this method multiple times.)\n * 2. When the user presses triggers a keydown or keyup event via directional keyboard keys, adds the\n *    'ms-Fabric--isFocusVisible' classname to the current element of the FocusRectsContext providerRef or the document\n *    body if no such element is provided via context, and removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user triggers a mousedown or pointerdown event, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    current element of the FocusRectsContext providerRef or the document body if no such element is provided via\n *    context, and removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef) {\n    var context = React.useContext(FocusRectsContext);\n    React.useEffect(function () {\n        var _a, _b, _c, _d;\n        var win = getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);\n        if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n            return undefined;\n        }\n        var el = win;\n        var onMouseDown;\n        var onPointerDown;\n        var onKeyDown;\n        var onKeyUp;\n        if (((_b = context === null || context === void 0 ? void 0 : context.providerRef) === null || _b === void 0 ? void 0 : _b.current) &&\n            ((_d = (_c = context === null || context === void 0 ? void 0 : context.providerRef) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.addEventListener)) {\n            el = context.providerRef.current;\n            // The NOINLINE directive tells terser not to move the setCallbackMap implementation into the call site during\n            // minification.\n            // This prevents the function from capturing additional variables in the closure, which can cause memory leaks.\n            var callbacks = /*@__NOINLINE__*/ setCallbackMap(context);\n            onMouseDown = callbacks.onMouseDown;\n            onPointerDown = callbacks.onPointerDown;\n            onKeyDown = callbacks.onKeyDown;\n            onKeyUp = callbacks.onKeyUp;\n        }\n        else {\n            onMouseDown = _onMouseDown;\n            onPointerDown = _onPointerDown;\n            onKeyDown = _onKeyDown;\n            onKeyUp = _onKeyUp;\n        }\n        var count = setMountCounters(el, 1);\n        if (count <= 1) {\n            el.addEventListener('mousedown', onMouseDown, true);\n            el.addEventListener('pointerdown', onPointerDown, true);\n            el.addEventListener('keydown', onKeyDown, true);\n            el.addEventListener('keyup', onKeyUp, true);\n        }\n        return function () {\n            var _a;\n            if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n                return;\n            }\n            count = setMountCounters(el, -1);\n            if (count === 0) {\n                el.removeEventListener('mousedown', onMouseDown, true);\n                el.removeEventListener('pointerdown', onPointerDown, true);\n                el.removeEventListener('keydown', onKeyDown, true);\n                el.removeEventListener('keyup', onKeyUp, true);\n            }\n        };\n    }, [context, rootRef]);\n}\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport var FocusRects = function (props) {\n    useFocusRects(props.rootRef);\n    return null;\n};\nfunction _onMouseDown(ev, registeredProviders) {\n    setFocusVisibility(false, ev.target, registeredProviders);\n}\nfunction _onPointerDown(ev, registeredProviders) {\n    if (ev.pointerType !== 'mouse') {\n        setFocusVisibility(false, ev.target, registeredProviders);\n    }\n}\n// You need both a keydown and a keyup listener that sets focus visibility to true to handle two distinct scenarios when\n// attaching the listeners and classnames to the provider instead of the document body.\n// If you only have a keydown listener, then the focus rectangles will not show when moving from outside of the provider\n// to inside it. That is why a keyup listener is needed, since it will always trigger after the focus event is fired.\n// If you only have a keyup listener, then the focus rectangles will not show moving between different tabbable elements\n// if the tab key is pressed without being released. That's is why we need a keydown listener, since it will trigger for\n// every element that is being tabbed into.\n// This works because `classList.add` is smart and will not duplicate a classname that already exists on the classList\n// when focus visibility is turned on.\nfunction _onKeyDown(ev, registeredProviders) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (isDirectionalKeyCode(ev.which)) {\n        setFocusVisibility(true, ev.target, registeredProviders);\n    }\n}\nfunction _onKeyUp(ev, registeredProviders) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (isDirectionalKeyCode(ev.which)) {\n        setFocusVisibility(true, ev.target, registeredProviders);\n    }\n}\n//# sourceMappingURL=useFocusRects.js.map"],"names":["mountCounters","callbackMap","setMountCounters","key","delta","newValue","currValue","setCallbackMap","context","callbacks","onMouseDown","ev","_onMouseDown","onPointerDown","_onPointerDown","onKeyDown","_onKeyDown","onKeyUp","_onKeyUp","FocusRectsContext","React","useFocusRects","rootRef","_a","_b","_c","_d","win","getWindow","el","count","FocusRects","props","registeredProviders","setFocusVisibility","isDirectionalKeyCode"],"mappings":";;;;AAIA,IAAIA,IAAgB,oBAAI,WACpBC,IAAc,oBAAI;AACtB,SAASC,EAAiBC,GAAKC,GAAO;AAClC,MAAIC,GACAC,IAAYN,EAAc,IAAIG,CAAG;AACrC,SAAIG,IACAD,IAAWC,IAAYF,IAGvBC,IAAW,GAEfL,EAAc,IAAIG,GAAKE,CAAQ,GACxBA;AACX;AACA,SAASE,EAAeC,GAAS;AAC7B,MAAIC,IAAYR,EAAY,IAAIO,CAAO;AACvC,MAAIC;AACA,WAAOA;AAEX,MAAIC,IAAc,SAAUC,GAAI;AAAE,WAAOC,EAAaD,GAAIH,EAAQ,mBAAmB;AAAA,KACjFK,IAAgB,SAAUF,GAAI;AAAE,WAAOG,EAAeH,GAAIH,EAAQ,mBAAmB;AAAA,KACrFO,IAAY,SAAUJ,GAAI;AAAE,WAAOK,EAAWL,GAAIH,EAAQ,mBAAmB;AAAA,KAC7ES,IAAU,SAAUN,GAAI;AAAE,WAAOO,EAASP,GAAIH,EAAQ,mBAAmB;AAAA;AAC7E,SAAAC,IAAY,EAAE,aAAaC,GAAa,eAAeG,GAAe,WAAWE,GAAW,SAASE,KACrGhB,EAAY,IAAIO,GAASC,CAAS,GAC3BA;AACX;AACU,IAACU,IAAoB,gBAAAC,EAAM,cAAc,MAAS;AAmBrD,SAASC,EAAcC,GAAS;AACnC,MAAId,IAAUY,EAAM,WAAWD,CAAiB;AAChD,EAAAC,EAAM,UAAU,WAAY;AACxB,QAAIG,GAAIC,GAAIC,GAAIC,GACZC,IAAMC,EAAUN,KAAY,OAA6B,SAASA,EAAQ,OAAO;AACrF,QAAI,GAACK,OAASJ,IAAKI,EAAI,kBAAkB,QAAQJ,MAAO,SAAS,SAASA,EAAG,uBAAuB,KAGpG;AAAA,UAAIM,IAAKF,GACLjB,GACAG,GACAE,GACAE;AACJ,UAAM,GAAAO,IAAKhB,KAAY,OAA6B,SAASA,EAAQ,iBAAiB,QAAQgB,MAAO,WAAkBA,EAAG,YACpH,GAAAE,KAAMD,IAAKjB,KAAY,OAA6B,SAASA,EAAQ,iBAAiB,QAAQiB,MAAO,SAAS,SAASA,EAAG,aAAa,QAAQC,MAAO,WAAkBA,EAAG,mBAAmB;AAChM,QAAAG,IAAKrB,EAAQ,YAAY;AAIzB,YAAIC;AAAA;AAAA,UAA8BF,EAAeC,CAAO;AAAA;AACxD,QAAAE,IAAcD,EAAU,aACxBI,IAAgBJ,EAAU,eAC1BM,IAAYN,EAAU,WACtBQ,IAAUR,EAAU;AAAA,MACvB;AAEG,QAAAC,IAAcE,GACdC,IAAgBC,GAChBC,IAAYC,GACZC,IAAUC;AAEd,UAAIY,IAAQ5B,EAAiB2B,GAAI,CAAC;AAClC,aAAIC,KAAS,MACTD,EAAG,iBAAiB,aAAanB,GAAa,EAAI,GAClDmB,EAAG,iBAAiB,eAAehB,GAAe,EAAI,GACtDgB,EAAG,iBAAiB,WAAWd,GAAW,EAAI,GAC9Cc,EAAG,iBAAiB,SAASZ,GAAS,EAAI,IAEvC,WAAY;AACf,YAAIM;AACJ,QAAI,CAACI,OAASJ,IAAKI,EAAI,kBAAkB,QAAQJ,MAAO,SAAS,SAASA,EAAG,uBAAuB,OAGpGO,IAAQ5B,EAAiB2B,GAAI,EAAE,GAC3BC,MAAU,MACVD,EAAG,oBAAoB,aAAanB,GAAa,EAAI,GACrDmB,EAAG,oBAAoB,eAAehB,GAAe,EAAI,GACzDgB,EAAG,oBAAoB,WAAWd,GAAW,EAAI,GACjDc,EAAG,oBAAoB,SAASZ,GAAS,EAAI;AAAA,MAE7D;AAAA;AAAA,EACA,GAAO,CAACT,GAASc,CAAO,CAAC;AACzB;AAKU,IAACS,IAAa,SAAUC,GAAO;AACrC,SAAAX,EAAcW,EAAM,OAAO,GACpB;AACX;AACA,SAASpB,EAAaD,GAAIsB,GAAqB;AAC3C,EAAAC,EAAmB,IAAOvB,EAAG,QAAQsB,CAAmB;AAC5D;AACA,SAASnB,EAAeH,GAAIsB,GAAqB;AAC7C,EAAItB,EAAG,gBAAgB,WACnBuB,EAAmB,IAAOvB,EAAG,QAAQsB,CAAmB;AAEhE;AAUA,SAASjB,EAAWL,GAAIsB,GAAqB;AAEzC,EAAIE,EAAqBxB,EAAG,KAAK,KAC7BuB,EAAmB,IAAMvB,EAAG,QAAQsB,CAAmB;AAE/D;AACA,SAASf,EAASP,GAAIsB,GAAqB;AAEvC,EAAIE,EAAqBxB,EAAG,KAAK,KAC7BuB,EAAmB,IAAMvB,EAAG,QAAQsB,CAAmB;AAE/D;","x_google_ignoreList":[0]}