{"version":3,"file":"ComboBox.js","sources":["../../../../../../../node_modules/@fluentui/react/lib/components/ComboBox/ComboBox.js"],"sourcesContent":["import { __assign, __decorate, __extends, __rest, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { Autofill } from '../../Autofill';\nimport { initializeComponentRef, css, customizable, divProperties, findElementRecursive, findIndex, focusAsync, getId, getNativeProps, isIOS, isMac, KeyCodes, shallowCompare, mergeAriaAttributeValues, warnMutuallyExclusive, Async, EventGroup, getPropsWithDefaults, } from '../../Utilities';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames } from './ComboBox.classNames';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../SelectableOption';\nimport { CommandButton, IconButton } from '../../Button';\nimport { useMergedRefs } from '@fluentui/react-hooks';\nimport { getChildren } from '@fluentui/utilities';\nimport { WindowContext } from '@fluentui/react-window-provider';\nimport { getDocumentEx } from '../../utilities/dom';\nvar SearchDirection;\n(function (SearchDirection) {\n    SearchDirection[SearchDirection[\"backward\"] = -1] = \"backward\";\n    SearchDirection[SearchDirection[\"none\"] = 0] = \"none\";\n    SearchDirection[SearchDirection[\"forward\"] = 1] = \"forward\";\n})(SearchDirection || (SearchDirection = {}));\nvar HoverStatus;\n(function (HoverStatus) {\n    /** Used when the user was hovering and has since moused out of the menu items */\n    HoverStatus[HoverStatus[\"clearAll\"] = -2] = \"clearAll\";\n    /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n    HoverStatus[HoverStatus[\"default\"] = -1] = \"default\";\n})(HoverStatus || (HoverStatus = {}));\nvar ScrollIdleDelay = 250; /* ms */\nvar TouchIdleDelay = 500; /* ms */\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\nvar ReadOnlyPendingAutoCompleteTimeout = 1000; /* ms */\n/**\n * Internal component that is used to wrap all ComboBox options.\n * This is used to customize when we want to re-render components,\n * so we don't re-render every option every time render is executed.\n */\nvar ComboBoxOptionWrapper = React.memo(function (_a) {\n    var render = _a.render;\n    return render();\n}, function (_a, _b) {\n    var oldRender = _a.render, oldProps = __rest(_a, [\"render\"]);\n    var newRender = _b.render, newProps = __rest(_b, [\"render\"]);\n    // The render function will always be different, so we ignore that prop\n    return shallowCompare(oldProps, newProps);\n});\nvar COMPONENT_NAME = 'ComboBox';\nvar DEFAULT_PROPS = {\n    options: [],\n    allowFreeform: false,\n    allowParentArrowNavigation: false,\n    autoComplete: 'on',\n    buttonIconProps: { iconName: 'ChevronDown' },\n};\nfunction useOptionsState(_a) {\n    var options = _a.options, defaultSelectedKey = _a.defaultSelectedKey, selectedKey = _a.selectedKey;\n    /** The currently selected indices */\n    var _b = React.useState(function () {\n        return getSelectedIndices(options, buildDefaultSelectedKeys(defaultSelectedKey, selectedKey));\n    }), selectedIndices = _b[0], setSelectedIndices = _b[1];\n    /** The options currently available for the callout */\n    var _c = React.useState(options), currentOptions = _c[0], setCurrentOptions = _c[1];\n    /** This value is used for the autocomplete hint value */\n    var _d = React.useState(), suggestedDisplayValue = _d[0], setSuggestedDisplayValue = _d[1];\n    React.useEffect(function () {\n        if (selectedKey !== undefined) {\n            var selectedKeys = buildSelectedKeys(selectedKey);\n            var indices = getSelectedIndices(options, selectedKeys);\n            setSelectedIndices(indices);\n        }\n        setCurrentOptions(options);\n    }, [options, selectedKey]);\n    React.useEffect(function () {\n        if (selectedKey === null) {\n            setSuggestedDisplayValue(undefined);\n        }\n    }, [selectedKey]);\n    return [\n        selectedIndices,\n        setSelectedIndices,\n        currentOptions,\n        setCurrentOptions,\n        suggestedDisplayValue,\n        setSuggestedDisplayValue,\n    ];\n}\nexport var ComboBox = React.forwardRef(function (propsWithoutDefaults, forwardedRef) {\n    var _a = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults), ref = _a.ref, props = __rest(_a, [\"ref\"]);\n    var rootRef = React.useRef(null);\n    var mergedRootRef = useMergedRefs(rootRef, forwardedRef);\n    var _b = useOptionsState(props), selectedIndices = _b[0], setSelectedIndices = _b[1], currentOptions = _b[2], setCurrentOptions = _b[3], suggestedDisplayValue = _b[4], setSuggestedDisplayValue = _b[5];\n    return (React.createElement(ComboBoxInternal, __assign({}, props, { hoisted: {\n            mergedRootRef: mergedRootRef,\n            rootRef: rootRef,\n            selectedIndices: selectedIndices,\n            setSelectedIndices: setSelectedIndices,\n            currentOptions: currentOptions,\n            setCurrentOptions: setCurrentOptions,\n            suggestedDisplayValue: suggestedDisplayValue,\n            setSuggestedDisplayValue: setSuggestedDisplayValue,\n        } })));\n});\nComboBox.displayName = COMPONENT_NAME;\n/**\n * Depth-first search to find the first descendant element where the match function returns true.\n * @param element - element to start searching at\n * @param match - the function that determines if the element is a match\n * @returns the matched element or null no match was found\n */\nfunction findFirstDescendant(element, match) {\n    var children = getChildren(element);\n    // For loop is used because forEach cannot be stopped.\n    for (var index = 0; index < children.length; index++) {\n        var child = children[index];\n        if (match(child)) {\n            return child;\n        }\n        var candidate = findFirstDescendant(child, match);\n        if (candidate) {\n            return candidate;\n        }\n    }\n    return null;\n}\nvar ComboBoxInternal = /** @class */ (function (_super) {\n    __extends(ComboBoxInternal, _super);\n    function ComboBoxInternal(props) {\n        var _this = _super.call(this, props) || this;\n        /** The input aspect of the combo box */\n        _this._autofill = React.createRef();\n        /** The wrapping div of the input and button */\n        _this._comboBoxWrapper = React.createRef();\n        /** The callout element */\n        _this._comboBoxMenu = React.createRef();\n        /** The menu item element that is currently selected */\n        _this._selectedElement = React.createRef();\n        // props to prevent dismiss on scroll/resize immediately after opening\n        _this._overrideScrollDismiss = false;\n        /**\n         * {@inheritdoc}\n         */\n        _this.focus = function (shouldOpenOnFocus, useFocusAsync) {\n            if (_this.props.disabled) {\n                return;\n            }\n            if (_this._autofill.current) {\n                if (useFocusAsync) {\n                    focusAsync(_this._autofill.current);\n                }\n                else {\n                    _this._autofill.current.focus();\n                }\n                if (shouldOpenOnFocus) {\n                    _this.setState({\n                        isOpen: true,\n                    });\n                }\n            }\n            // Programmatically setting focus means that there is nothing else that needs to be done\n            // Focus is now contained\n            if (!_this._hasFocus()) {\n                _this.setState({ focusState: 'focused' });\n            }\n        };\n        /**\n         * Close menu callout if it is open\n         */\n        _this.dismissMenu = function () {\n            var isOpen = _this.state.isOpen;\n            isOpen && _this.setState({ isOpen: false });\n        };\n        /**\n         * componentWillReceiveProps handler for the auto fill component\n         * Checks/updates the input value to set, if needed\n         * @param defaultVisibleValue - the defaultVisibleValue that got passed\n         *  in to the auto fill's componentWillReceiveProps\n         * @returns - the updated value to set, if needed\n         */\n        _this._onUpdateValueInAutofillWillReceiveProps = function () {\n            var comboBox = _this._autofill.current;\n            if (!comboBox) {\n                return null;\n            }\n            if (comboBox.value === null || comboBox.value === undefined) {\n                return null;\n            }\n            return normalizeToString(_this._currentVisibleValue);\n        };\n        _this._renderComboBoxWrapper = function (multiselectAccessibleText, errorMessageId) {\n            var _a = _this.props, label = _a.label, disabled = _a.disabled, ariaLabel = _a.ariaLabel, _b = _a.ariaDescribedBy, ariaDescribedBy = _b === void 0 ? _this.props['aria-describedby'] : _b, required = _a.required, errorMessage = _a.errorMessage, buttonIconProps = _a.buttonIconProps, isButtonAriaHidden = _a.isButtonAriaHidden, title = _a.title, placeholderProp = _a.placeholder, tabIndex = _a.tabIndex, autofill = _a.autofill, iconButtonProps = _a.iconButtonProps, suggestedDisplayValue = _a.hoisted.suggestedDisplayValue;\n            var _c = _this.state, ariaActiveDescendantValue = _c.ariaActiveDescendantValue, isOpen = _c.isOpen;\n            // If the combo box has focus, is multiselect, and has a display string, then use that placeholder\n            // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n            // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n            // should be removed and the multiselect combo box should behave like a picker.\n            var placeholder = _this._hasFocus() && _this.props.multiSelect && multiselectAccessibleText\n                ? multiselectAccessibleText\n                : placeholderProp;\n            var labelledBy = [_this.props['aria-labelledby'], label && _this._id + '-label'].join(' ').trim();\n            var labelProps = {\n                'aria-labelledby': labelledBy ? labelledBy : undefined,\n                'aria-label': ariaLabel && !label ? ariaLabel : undefined,\n            };\n            return (React.createElement(\"div\", { \"data-ktp-target\": true, ref: _this._comboBoxWrapper, id: _this._id + 'wrapper', className: _this._classNames.root, \"aria-owns\": isOpen ? _this._id + '-list' : undefined },\n                React.createElement(Autofill, __assign({ \"data-ktp-execute-target\": true, \"data-is-interactable\": !disabled, componentRef: _this._autofill, id: _this._id + '-input', className: _this._classNames.input, type: \"text\", onFocus: _this._onFocus, onBlur: _this._onBlur, onKeyDown: _this._onInputKeyDown, onKeyUp: _this._onInputKeyUp, onClick: _this._onAutofillClick, onTouchStart: _this._onTouchStart, onInputValueChange: _this._onInputChange, \"aria-expanded\": isOpen, \"aria-autocomplete\": _this._getAriaAutoCompleteValue(), role: \"combobox\", readOnly: disabled }, labelProps, { \"aria-describedby\": errorMessage !== undefined ? mergeAriaAttributeValues(ariaDescribedBy, errorMessageId) : ariaDescribedBy, \"aria-activedescendant\": ariaActiveDescendantValue, \"aria-required\": required, \"aria-disabled\": disabled, \"aria-controls\": isOpen ? _this._id + '-list' : undefined, spellCheck: false, defaultVisibleValue: _this._currentVisibleValue, suggestedDisplayValue: suggestedDisplayValue, updateValueInWillReceiveProps: _this._onUpdateValueInAutofillWillReceiveProps, shouldSelectFullInputValueInComponentDidUpdate: _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate, title: title, preventValueSelection: !_this._hasFocus(), placeholder: placeholder, tabIndex: disabled ? -1 : tabIndex }, autofill)),\n                React.createElement(IconButton, __assign({ className: 'ms-ComboBox-CaretDown-button', styles: _this._getCaretButtonStyles(), role: isButtonAriaHidden ? 'presentation' : undefined, \"aria-hidden\": isButtonAriaHidden }, (!isButtonAriaHidden ? labelProps : undefined), { \"data-is-focusable\": false, tabIndex: -1, onClick: _this._onComboBoxClick, onBlur: _this._onBlur, iconProps: buttonIconProps, disabled: disabled, checked: isOpen }, iconButtonProps))));\n        };\n        /**\n         * componentDidUpdate handler for the auto fill component\n         *\n         * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n         * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n         * @returns - should the full value of the input be selected?\n         * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n         */\n        _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate = function () {\n            return _this._currentVisibleValue === _this.props.hoisted.suggestedDisplayValue;\n        };\n        /**\n         * Get the correct value to pass to the input\n         * to show to the user based off of the current props and state\n         * @returns the value to pass to the input\n         */\n        _this._getVisibleValue = function () {\n            var _a = _this.props, text = _a.text, allowFreeform = _a.allowFreeform, allowFreeInput = _a.allowFreeInput, autoComplete = _a.autoComplete, _b = _a.hoisted, suggestedDisplayValue = _b.suggestedDisplayValue, selectedIndices = _b.selectedIndices, currentOptions = _b.currentOptions;\n            var _c = _this.state, currentPendingValueValidIndex = _c.currentPendingValueValidIndex, currentPendingValue = _c.currentPendingValue, isOpen = _c.isOpen;\n            var currentPendingIndexValid = indexWithinBounds(currentOptions, currentPendingValueValidIndex);\n            // If the user passed is a value prop, use that\n            // unless we are open and have a valid current pending index\n            if (!(isOpen && currentPendingIndexValid) &&\n                (text || text === '') &&\n                (currentPendingValue === null || currentPendingValue === undefined)) {\n                return text;\n            }\n            if (_this.props.multiSelect) {\n                // Multi-select\n                if (_this._hasFocus()) {\n                    var index = -1;\n                    if (autoComplete === 'on' && currentPendingIndexValid) {\n                        index = currentPendingValueValidIndex;\n                    }\n                    return _this._getPendingString(currentPendingValue, currentOptions, index);\n                }\n                else {\n                    return _this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n                }\n            }\n            else {\n                // Single-select\n                var index = _this._getFirstSelectedIndex();\n                if (allowFreeform || allowFreeInput) {\n                    // If we are allowing freeform/free input and autocomplete is also true\n                    // and we've got a pending value that matches an option, remember\n                    // the matched option's index\n                    if (autoComplete === 'on' && currentPendingIndexValid) {\n                        index = currentPendingValueValidIndex;\n                    }\n                    // Since we are allowing freeform, if there is currently a pending value, use that\n                    // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n                    return _this._getPendingString(currentPendingValue, currentOptions, index);\n                }\n                else {\n                    // If we are not allowing freeform and have a valid index that matches the pending value,\n                    // we know we will need some version of the pending value\n                    if (currentPendingIndexValid && autoComplete === 'on') {\n                        // If autoComplete is on, return the raw pending value, otherwise remember\n                        // the matched option's index\n                        index = currentPendingValueValidIndex;\n                        return normalizeToString(currentPendingValue);\n                    }\n                    else if (!_this.state.isOpen && currentPendingValue) {\n                        return indexWithinBounds(currentOptions, index)\n                            ? currentPendingValue\n                            : normalizeToString(suggestedDisplayValue);\n                    }\n                    else {\n                        return indexWithinBounds(currentOptions, index)\n                            ? getPreviewText(currentOptions[index])\n                            : normalizeToString(suggestedDisplayValue);\n                    }\n                }\n            }\n        };\n        /**\n         * Handler for typing changes on the input\n         * @param updatedValue - the newly changed value\n         */\n        _this._onInputChange = function (updatedValue) {\n            if (_this.props.disabled) {\n                _this._handleInputWhenDisabled(null /* event */);\n                return;\n            }\n            if (_this.props.onInputValueChange) {\n                _this.props.onInputValueChange(updatedValue);\n            }\n            _this.props.allowFreeform || _this.props.allowFreeInput\n                ? _this._processInputChangeWithFreeform(updatedValue)\n                : _this._processInputChangeWithoutFreeform(updatedValue);\n        };\n        /**\n         * Focus (and select) the content of the input\n         * and set the focused state\n         */\n        _this._onFocus = function () {\n            var _a, _b;\n            (_b = (_a = _this._autofill.current) === null || _a === void 0 ? void 0 : _a.inputElement) === null || _b === void 0 ? void 0 : _b.select();\n            if (!_this._hasFocus()) {\n                _this.setState({ focusState: 'focusing' });\n            }\n        };\n        /**\n         * Callback issued when the options should be resolved, if they have been updated or\n         * if they need to be passed in the first time. This only does work if an onResolveOptions\n         * callback was passed in\n         */\n        _this._onResolveOptions = function () {\n            if (_this.props.onResolveOptions) {\n                // get the options\n                var newOptions_1 = _this.props.onResolveOptions(__spreadArray([], _this.props.hoisted.currentOptions, true));\n                // Check to see if the returned value is an array, if it is update the state\n                // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n                // If it is then resolve it asynchronously.\n                if (Array.isArray(newOptions_1)) {\n                    _this.props.hoisted.setCurrentOptions(newOptions_1);\n                }\n                else if (newOptions_1 && newOptions_1.then) {\n                    // Ensure that the promise will only use the callback if it was the most recent one\n                    // and update the state when the promise returns\n                    _this._currentPromise = newOptions_1;\n                    newOptions_1.then(function (newOptionsFromPromise) {\n                        if (newOptions_1 === _this._currentPromise) {\n                            _this.props.hoisted.setCurrentOptions(newOptionsFromPromise);\n                        }\n                    });\n                }\n            }\n        };\n        /**\n         * OnBlur handler. Set the focused state to false\n         * and submit any pending value\n         */\n        // eslint-disable-next-line deprecation/deprecation\n        _this._onBlur = function (event) {\n            var _a, _b;\n            var doc = getDocumentEx(_this.context);\n            // Do nothing if the blur is coming from something\n            // inside the comboBox root or the comboBox menu since\n            // it we are not really blurring from the whole comboBox\n            var relatedTarget = event.relatedTarget;\n            if (event.relatedTarget === null) {\n                // In IE11, due to lack of support, event.relatedTarget is always\n                // null making every onBlur call to be \"outside\" of the ComboBox\n                // even when it's not. Using document.activeElement is another way\n                // for us to be able to get what the relatedTarget without relying\n                // on the event\n                relatedTarget = doc === null || doc === void 0 ? void 0 : doc.activeElement;\n            }\n            if (relatedTarget) {\n                var isBlurFromComboBoxTitle = (_a = _this.props.hoisted.rootRef.current) === null || _a === void 0 ? void 0 : _a.contains(relatedTarget);\n                var isBlurFromComboBoxMenu = (_b = _this._comboBoxMenu.current) === null || _b === void 0 ? void 0 : _b.contains(relatedTarget);\n                var isBlurFromComboBoxMenuAncestor = _this._comboBoxMenu.current &&\n                    findElementRecursive(_this._comboBoxMenu.current, function (element) { return element === relatedTarget; }, doc);\n                if (isBlurFromComboBoxTitle || isBlurFromComboBoxMenu || isBlurFromComboBoxMenuAncestor) {\n                    if (isBlurFromComboBoxMenuAncestor &&\n                        _this._hasFocus() &&\n                        (!_this.props.multiSelect || _this.props.allowFreeform)) {\n                        _this._submitPendingValue(event);\n                    }\n                    event.preventDefault();\n                    event.stopPropagation();\n                    return;\n                }\n            }\n            if (_this._hasFocus()) {\n                _this.setState({ focusState: 'none' });\n                if (!_this.props.multiSelect || _this.props.allowFreeform) {\n                    _this._submitPendingValue(event);\n                }\n            }\n        };\n        // Render Callout container and pass in list\n        _this._onRenderContainer = function (props, defaultRender) {\n            var onRenderList = props.onRenderList, calloutProps = props.calloutProps, dropdownWidth = props.dropdownWidth, dropdownMaxWidth = props.dropdownMaxWidth, _a = props.onRenderUpperContent, onRenderUpperContent = _a === void 0 ? _this._onRenderUpperContent : _a, _b = props.onRenderLowerContent, onRenderLowerContent = _b === void 0 ? _this._onRenderLowerContent : _b, useComboBoxAsMenuWidth = props.useComboBoxAsMenuWidth, persistMenu = props.persistMenu, _c = props.shouldRestoreFocus, shouldRestoreFocus = _c === void 0 ? true : _c;\n            var isOpen = _this.state.isOpen;\n            var id = _this._id;\n            var comboBoxMenuWidth = useComboBoxAsMenuWidth && _this._comboBoxWrapper.current\n                ? _this._comboBoxWrapper.current.clientWidth + 2\n                : undefined;\n            return (React.createElement(Callout, __assign({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHint: DirectionalHint.bottomLeftEdge, directionalHintFixed: false }, calloutProps, { onLayerMounted: _this._onLayerMounted, className: css(_this._classNames.callout, calloutProps === null || calloutProps === void 0 ? void 0 : calloutProps.className), target: _this._comboBoxWrapper.current, onDismiss: _this._onDismiss, onMouseDown: _this._onCalloutMouseDown, onScroll: _this._onScroll, setInitialFocus: false, calloutWidth: useComboBoxAsMenuWidth && _this._comboBoxWrapper.current\n                    ? comboBoxMenuWidth && comboBoxMenuWidth\n                    : dropdownWidth, calloutMaxWidth: dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth, hidden: persistMenu ? !isOpen : undefined, shouldRestoreFocus: shouldRestoreFocus, \n                // eslint-disable-next-line react/jsx-no-bind\n                preventDismissOnEvent: function (ev) { return _this._preventDismissOnScrollOrResize(ev); } }),\n                onRenderUpperContent(_this.props, _this._onRenderUpperContent),\n                React.createElement(\"div\", { className: _this._classNames.optionsContainerWrapper, ref: _this._comboBoxMenu }, onRenderList === null || onRenderList === void 0 ? void 0 : onRenderList(__assign(__assign({}, props), { id: id }), _this._onRenderList)),\n                onRenderLowerContent(_this.props, _this._onRenderLowerContent)));\n        };\n        _this._onLayerMounted = function () {\n            _this._onCalloutLayerMounted();\n            // need to call this again here to get the correct scroll parent dimensions\n            // when the callout is first opened\n            _this._async.setTimeout(function () {\n                _this._scrollIntoView();\n            }, 0);\n            if (_this.props.calloutProps && _this.props.calloutProps.onLayerMounted) {\n                _this.props.calloutProps.onLayerMounted();\n            }\n        };\n        _this._onRenderLabel = function (onRenderLabelProps) {\n            var _a = onRenderLabelProps.props, label = _a.label, disabled = _a.disabled, required = _a.required;\n            if (label) {\n                return (React.createElement(Label, { id: _this._id + '-label', disabled: disabled, required: required, className: _this._classNames.label },\n                    label,\n                    onRenderLabelProps.multiselectAccessibleText && (React.createElement(\"span\", { className: _this._classNames.screenReaderText }, onRenderLabelProps.multiselectAccessibleText))));\n            }\n            return null;\n        };\n        // Render List of items\n        _this._onRenderList = function (props) {\n            var _a = props.onRenderItem, onRenderItem = _a === void 0 ? _this._onRenderItem : _a, label = props.label, ariaLabel = props.ariaLabel, multiSelect = props.multiSelect;\n            var queue = { items: [] };\n            var renderedList = [];\n            var emptyQueue = function () {\n                var newGroup = queue.id\n                    ? [\n                        React.createElement(\"div\", { role: \"group\", key: queue.id, \"aria-labelledby\": queue.id }, queue.items),\n                    ]\n                    : queue.items;\n                renderedList = __spreadArray(__spreadArray([], renderedList, true), newGroup, true);\n                // Flush items and id\n                queue = { items: [] };\n            };\n            var placeRenderedOptionIntoQueue = function (item, index) {\n                /*\n                  Case Header\n                    empty queue if it's not already empty\n                    ensure unique ID for header and set queue ID\n                    push header into queue\n                  Case Divider\n                    push divider into queue if not first item\n                    empty queue if not already empty\n                  Default\n                    push item into queue\n                */\n                switch (item.itemType) {\n                    case SelectableOptionMenuItemType.Header:\n                        queue.items.length > 0 && emptyQueue();\n                        var id_1 = _this._id + item.key;\n                        queue.items.push(onRenderItem(__assign(__assign({ id: id_1 }, item), { index: index }), _this._onRenderItem));\n                        queue.id = id_1;\n                        break;\n                    case SelectableOptionMenuItemType.Divider:\n                        index > 0 && queue.items.push(onRenderItem(__assign(__assign({}, item), { index: index }), _this._onRenderItem));\n                        queue.items.length > 0 && emptyQueue();\n                        break;\n                    default:\n                        queue.items.push(onRenderItem(__assign(__assign({}, item), { index: index }), _this._onRenderItem));\n                }\n            };\n            // Place options into the queue. Queue will be emptied anytime a Header or Divider is encountered\n            props.options.forEach(function (item, index) {\n                placeRenderedOptionIntoQueue(item, index);\n            });\n            // Push remaining items into all renderedList\n            queue.items.length > 0 && emptyQueue();\n            var id = _this._id;\n            return (React.createElement(\"div\", { id: id + '-list', className: _this._classNames.optionsContainer, \"aria-labelledby\": label && id + '-label', \"aria-label\": ariaLabel && !label ? ariaLabel : undefined, \"aria-multiselectable\": multiSelect ? 'true' : undefined, role: \"listbox\" }, renderedList));\n        };\n        // Render items\n        _this._onRenderItem = function (item) {\n            switch (item.itemType) {\n                case SelectableOptionMenuItemType.Divider:\n                    return _this._renderSeparator(item);\n                case SelectableOptionMenuItemType.Header:\n                    return _this._renderHeader(item);\n                default:\n                    return _this._renderOption(item);\n            }\n        };\n        // Default _onRenderLowerContent function returns nothing\n        _this._onRenderLowerContent = function () {\n            return null;\n        };\n        // Default _onRenderUpperContent function returns nothing\n        _this._onRenderUpperContent = function () {\n            return null;\n        };\n        _this._renderOption = function (item) {\n            var _a;\n            var _b = _this.props.onRenderOption, onRenderOption = _b === void 0 ? _this._onRenderOptionContent : _b;\n            var id = (_a = item.id) !== null && _a !== void 0 ? _a : _this._id + '-list' + item.index;\n            var isSelected = _this._isOptionSelected(item.index);\n            var isChecked = _this._isOptionChecked(item.index);\n            var isIndeterminate = _this._isOptionIndeterminate(item.index);\n            var optionStyles = _this._getCurrentOptionStyles(item);\n            var optionClassNames = getComboBoxOptionClassNames(optionStyles);\n            var title = item.title;\n            var getOptionComponent = function () {\n                return !_this.props.multiSelect ? (React.createElement(CommandButton, { id: id, key: item.key, \"data-index\": item.index, styles: optionStyles, checked: isSelected, className: 'ms-ComboBox-option', onClick: _this._onItemClick(item), \n                    // eslint-disable-next-line react/jsx-no-bind\n                    onMouseEnter: _this._onOptionMouseEnter.bind(_this, item.index), \n                    // eslint-disable-next-line react/jsx-no-bind\n                    onMouseMove: _this._onOptionMouseMove.bind(_this, item.index), onMouseLeave: _this._onOptionMouseLeave, role: \"option\", \"aria-selected\": isSelected ? 'true' : 'false', ariaLabel: item.ariaLabel, disabled: item.disabled, title: title }, React.createElement(\"span\", { className: optionClassNames.optionTextWrapper, ref: isSelected ? _this._selectedElement : undefined }, onRenderOption(item, _this._onRenderOptionContent)))) : (React.createElement(Checkbox, { id: id, ariaLabel: item.ariaLabel, ariaLabelledBy: item.ariaLabel ? undefined : id + '-label', key: item.key, styles: optionStyles, className: 'ms-ComboBox-option', onChange: _this._onItemClick(item), label: item.text, checked: isChecked, indeterminate: isIndeterminate, title: title, disabled: item.disabled, \n                    // eslint-disable-next-line react/jsx-no-bind\n                    onRenderLabel: _this._renderCheckboxLabel.bind(_this, __assign(__assign({}, item), { id: id + '-label' })), inputProps: __assign({ \n                        // aria-selected should only be applied to checked items, not hovered items\n                        'aria-selected': isChecked ? 'true' : 'false', role: 'option' }, {\n                        'data-index': item.index,\n                        'data-is-focusable': true,\n                    }) }));\n            };\n            return (React.createElement(ComboBoxOptionWrapper, { key: item.key, index: item.index, disabled: item.disabled, isSelected: isSelected, isChecked: isChecked, isIndeterminate: isIndeterminate, text: item.text, \n                // eslint-disable-next-line react/jsx-no-bind\n                render: getOptionComponent, data: item.data }));\n        };\n        /**\n         * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n         */\n        _this._onCalloutMouseDown = function (ev) {\n            ev.preventDefault();\n        };\n        /**\n         * Scroll handler for the callout to make sure the mouse events\n         * for updating focus are not interacting during scroll\n         */\n        _this._onScroll = function () {\n            var _a;\n            if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n                _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n                _this._scrollIdleTimeoutId = undefined;\n            }\n            else {\n                _this._isScrollIdle = false;\n            }\n            if ((_a = _this.props.calloutProps) === null || _a === void 0 ? void 0 : _a.onScroll) {\n                _this.props.calloutProps.onScroll();\n            }\n            _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n                _this._isScrollIdle = true;\n            }, ScrollIdleDelay);\n        };\n        _this._onRenderOptionContent = function (item) {\n            var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n            return React.createElement(\"span\", { className: optionClassNames.optionText }, item.text);\n        };\n        /*\n         * Render content of a multiselect item label.\n         * Text within the label is aria-hidden, to prevent duplicate input/label exposure\n         */\n        _this._onRenderMultiselectOptionContent = function (item) {\n            var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));\n            return (React.createElement(\"span\", { id: item.id, \"aria-hidden\": \"true\", className: optionClassNames.optionText }, item.text));\n        };\n        /**\n         * Handles dismissing (cancelling) the menu\n         */\n        _this._onDismiss = function () {\n            var onMenuDismiss = _this.props.onMenuDismiss;\n            if (onMenuDismiss) {\n                onMenuDismiss();\n            }\n            // In persistMode we need to simulate callout layer mount\n            // since that only happens once. We do it on dismiss since\n            // it works either way.\n            if (_this.props.persistMenu) {\n                _this._onCalloutLayerMounted();\n            }\n            // close the menu\n            _this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);\n            // reset the selected index\n            // to the last value state\n            _this._resetSelectedIndex();\n        };\n        _this._onAfterClearPendingInfo = function () {\n            _this._processingClearPendingInfo = false;\n        };\n        /**\n         * Handle keydown on the input\n         * @param ev - The keyboard event that was fired\n         */\n        _this._onInputKeyDown = function (ev) {\n            var _a = _this.props, disabled = _a.disabled, allowFreeform = _a.allowFreeform, allowFreeInput = _a.allowFreeInput, allowParentArrowNavigation = _a.allowParentArrowNavigation, autoComplete = _a.autoComplete, currentOptions = _a.hoisted.currentOptions;\n            var _b = _this.state, isOpen = _b.isOpen, currentPendingValueValidIndexOnHover = _b.currentPendingValueValidIndexOnHover;\n            // Take note if we are processing an alt (option) or meta (command) keydown.\n            // See comment in _onInputKeyUp for reasoning.\n            _this._lastKeyDownWasAltOrMeta = isAltOrMeta(ev);\n            if (disabled) {\n                _this._handleInputWhenDisabled(ev);\n                return;\n            }\n            var index = _this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\n            // eslint-disable-next-line deprecation/deprecation\n            switch (ev.which) {\n                case KeyCodes.enter:\n                    if (_this._autofill.current && _this._autofill.current.inputElement) {\n                        _this._autofill.current.inputElement.select();\n                    }\n                    _this._submitPendingValue(ev);\n                    if (_this.props.multiSelect && isOpen) {\n                        _this.setState({\n                            currentPendingValueValidIndex: index,\n                        });\n                    }\n                    else {\n                        // On enter submit the pending value\n                        if (isOpen ||\n                            ((!allowFreeform ||\n                                _this.state.currentPendingValue === undefined ||\n                                _this.state.currentPendingValue === null ||\n                                _this.state.currentPendingValue.length <= 0) &&\n                                _this.state.currentPendingValueValidIndex < 0)) {\n                            // if we are open or\n                            // if we are not allowing freeform or\n                            // our we have no pending value\n                            // and no valid pending index\n                            // flip the open state\n                            _this.setState({\n                                isOpen: !isOpen,\n                            });\n                        }\n                    }\n                    break;\n                case KeyCodes.tab:\n                    // On enter submit the pending value\n                    if (!_this.props.multiSelect) {\n                        _this._submitPendingValue(ev);\n                    }\n                    // If we are not allowing freeform\n                    // or the combo box is open, flip the open state\n                    if (isOpen) {\n                        _this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n                    }\n                    // Allow TAB to propagate\n                    return;\n                case KeyCodes.escape:\n                    // reset the selected index\n                    _this._resetSelectedIndex();\n                    // Close the menu if opened\n                    if (isOpen) {\n                        _this.setState({\n                            isOpen: false,\n                        });\n                    }\n                    else {\n                        return;\n                    }\n                    break;\n                case KeyCodes.up:\n                    // if we are in clearAll state (e.g. the user as hovering\n                    // and has since mousedOut of the menu items),\n                    // go to the last index\n                    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n                        index = _this.props.hoisted.currentOptions.length;\n                    }\n                    if (ev.altKey || ev.metaKey) {\n                        // Close the menu if it is open and break so\n                        // that the event get stopPropagation and prevent default.\n                        // Otherwise, we need to let the event continue to propagate\n                        if (isOpen) {\n                            _this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n                            break;\n                        }\n                        return;\n                    }\n                    // do not scroll page\n                    ev.preventDefault();\n                    // Go to the previous option\n                    _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n                    break;\n                case KeyCodes.down:\n                    // Expand the combo box on ALT + DownArrow\n                    if (ev.altKey || ev.metaKey) {\n                        _this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\n                    }\n                    else {\n                        // if we are in clearAll state (e.g. the user as hovering\n                        // and has since mousedOut of the menu items),\n                        // go to the first index\n                        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n                            index = -1;\n                        }\n                        // do not scroll page\n                        ev.preventDefault();\n                        // Got to the next option\n                        _this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n                    }\n                    break;\n                case KeyCodes.home:\n                case KeyCodes.end:\n                    if (allowFreeform || allowFreeInput) {\n                        return;\n                    }\n                    // Set the initial values to respond to HOME\n                    // which goes to the first selectable option\n                    index = -1;\n                    var directionToSearch = SearchDirection.forward;\n                    // If end, update the values to respond to END\n                    // which goes to the last selectable option\n                    // eslint-disable-next-line deprecation/deprecation\n                    if (ev.which === KeyCodes.end) {\n                        index = currentOptions.length;\n                        directionToSearch = SearchDirection.backward;\n                    }\n                    _this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n                    break;\n                /* eslint-disable no-fallthrough */\n                case KeyCodes.space:\n                    // event handled in _onComboBoxKeyUp\n                    if (!allowFreeform && !allowFreeInput && autoComplete === 'off') {\n                        break;\n                    }\n                default:\n                    /* eslint-enable no-fallthrough */\n                    // are we processing a function key? if so bail out\n                    // eslint-disable-next-line deprecation/deprecation\n                    if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\n                        return;\n                    }\n                    // If we get here and we got either and ALT key\n                    // or meta key, let the event propagate\n                    // eslint-disable-next-line deprecation/deprecation\n                    if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta' /* && isOpen */) {\n                        return;\n                    }\n                    // eslint-disable-next-line deprecation/deprecation\n                    if (allowParentArrowNavigation && (ev.keyCode === KeyCodes.left || ev.keyCode === KeyCodes.right)) {\n                        return;\n                    }\n                    // If we are not allowing freeform or free input and\n                    // allowing autoComplete, handle the input here\n                    if (!allowFreeform && !allowFreeInput && autoComplete === 'on') {\n                        _this._onInputChange(ev.key);\n                        break;\n                    }\n                    // allow the key to propagate by default\n                    return;\n            }\n            ev.stopPropagation();\n            ev.preventDefault();\n        };\n        /**\n         * Handle keyup on the input\n         * @param ev - the keyboard event that was fired\n         */\n        _this._onInputKeyUp = function (ev) {\n            var _a = _this.props, disabled = _a.disabled, allowFreeform = _a.allowFreeform, allowFreeInput = _a.allowFreeInput, autoComplete = _a.autoComplete;\n            var isOpen = _this.state.isOpen;\n            // We close the menu on key up only if ALL of the following are true:\n            // - Most recent key down was alt or meta (command)\n            // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n            //   expand/collapse the menu)\n            // - We're not on a Mac (or iOS)\n            // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n            // closing any open context menus. There is not a similar behavior on Macs.\n            var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && isAltOrMeta(ev);\n            _this._lastKeyDownWasAltOrMeta = false;\n            var shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n            if (disabled) {\n                _this._handleInputWhenDisabled(ev);\n                return;\n            }\n            // eslint-disable-next-line deprecation/deprecation\n            switch (ev.which) {\n                case KeyCodes.space:\n                    // If we are not allowing freeform or free input, and autoComplete is off\n                    // make space expand/collapse the combo box\n                    // and allow the event to propagate\n                    if (!allowFreeform && !allowFreeInput && autoComplete === 'off') {\n                        _this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n                    }\n                    return;\n                default:\n                    if (shouldHandleKey && isOpen) {\n                        _this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n                    }\n                    else {\n                        if (_this.state.focusState === 'focusing' && _this.props.openOnKeyboardFocus) {\n                            _this.setState({ isOpen: true });\n                        }\n                        if (_this.state.focusState !== 'focused') {\n                            _this.setState({ focusState: 'focused' });\n                        }\n                    }\n                    return;\n            }\n        };\n        _this._onOptionMouseLeave = function () {\n            if (_this._shouldIgnoreMouseEvent()) {\n                return;\n            }\n            // Ignore the event in persistMenu mode if the callout has\n            // closed. This is to avoid clearing the visuals on item click.\n            if (_this.props.persistMenu && !_this.state.isOpen) {\n                return;\n            }\n            _this.setState({\n                currentPendingValueValidIndexOnHover: HoverStatus.clearAll,\n            });\n        };\n        /**\n         * Click handler for the button of the combo box and the input when not allowing freeform.\n         * This toggles the expand/collapse state of the combo box (if enabled).\n         */\n        _this._onComboBoxClick = function () {\n            var disabled = _this.props.disabled;\n            var isOpen = _this.state.isOpen;\n            if (!disabled) {\n                _this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n                _this.setState({ focusState: 'focused' });\n            }\n        };\n        /**\n         * Click handler for the autofill.\n         */\n        _this._onAutofillClick = function () {\n            var _a = _this.props, disabled = _a.disabled, allowFreeform = _a.allowFreeform;\n            if (allowFreeform && !disabled) {\n                _this.focus(_this.state.isOpen || _this._processingTouch);\n            }\n            else {\n                _this._onComboBoxClick();\n            }\n        };\n        _this._onTouchStart = function () {\n            if (_this._comboBoxWrapper.current && !('onpointerdown' in _this._comboBoxWrapper)) {\n                _this._handleTouchAndPointerEvent();\n            }\n        };\n        _this._onPointerDown = function (ev) {\n            if (ev.pointerType === 'touch') {\n                _this._handleTouchAndPointerEvent();\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n            }\n        };\n        initializeComponentRef(_this);\n        _this._async = new Async(_this);\n        _this._events = new EventGroup(_this);\n        warnMutuallyExclusive(COMPONENT_NAME, props, {\n            defaultSelectedKey: 'selectedKey',\n            text: 'defaultSelectedKey',\n            selectedKey: 'value',\n            dropdownWidth: 'useComboBoxAsMenuWidth',\n            ariaLabel: 'label',\n        });\n        _this._id = props.id || getId('ComboBox');\n        _this._isScrollIdle = true;\n        _this._processingTouch = false;\n        _this._gotMouseMove = false;\n        _this._processingClearPendingInfo = false;\n        _this.state = {\n            isOpen: false,\n            focusState: 'none',\n            currentPendingValueValidIndex: -1,\n            currentPendingValue: undefined,\n            currentPendingValueValidIndexOnHover: HoverStatus.default,\n        };\n        return _this;\n    }\n    Object.defineProperty(ComboBoxInternal.prototype, \"selectedOptions\", {\n        /**\n         * All selected options\n         */\n        get: function () {\n            var _a = this.props.hoisted, currentOptions = _a.currentOptions, selectedIndices = _a.selectedIndices;\n            return getAllSelectedOptions(currentOptions, selectedIndices);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ComboBoxInternal.prototype.componentDidMount = function () {\n        if (this._comboBoxWrapper.current && !this.props.disabled) {\n            // hook up resolving the options if needed on focus\n            this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n            if ('onpointerdown' in this._comboBoxWrapper.current) {\n                // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n                // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n                // does not support Pointer events yet.\n                this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n            }\n        }\n    };\n    ComboBoxInternal.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _this = this;\n        var _a, _b, _c;\n        var _d = this.props, allowFreeform = _d.allowFreeform, allowFreeInput = _d.allowFreeInput, text = _d.text, onMenuOpen = _d.onMenuOpen, onMenuDismissed = _d.onMenuDismissed, _e = _d.hoisted, currentOptions = _e.currentOptions, selectedIndices = _e.selectedIndices;\n        var _f = this.state, currentPendingValue = _f.currentPendingValue, currentPendingValueValidIndex = _f.currentPendingValueValidIndex, isOpen = _f.isOpen;\n        // If we are newly open or are open and the pending valid index changed,\n        // make sure the currently selected/pending option is scrolled into view\n        if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n            // Need this timeout so that the selectedElement ref is correctly updated\n            this._async.setTimeout(function () { return _this._scrollIntoView(); }, 0);\n        }\n        var doc = getDocumentEx(this.context);\n        // if an action is taken that put focus in the ComboBox\n        // and If we are open or we are just closed, shouldFocusAfterClose is set,\n        // but we are not the activeElement set focus on the input\n        if (this._hasFocus() &&\n            (isOpen ||\n                (prevState.isOpen &&\n                    !isOpen &&\n                    this._focusInputAfterClose &&\n                    this._autofill.current &&\n                    (doc === null || doc === void 0 ? void 0 : doc.activeElement) !== this._autofill.current.inputElement))) {\n            this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);\n        }\n        // If we should focusAfterClose AND\n        //   just opened/closed the menu OR\n        //   are focused AND\n        //     updated the selectedIndex with the menu closed OR\n        //     are not allowing freeform or free input OR\n        //     the value changed\n        // we need to set selection\n        if (this._focusInputAfterClose &&\n            ((prevState.isOpen && !isOpen) ||\n                (this._hasFocus() &&\n                    ((!isOpen &&\n                        !this.props.multiSelect &&\n                        prevProps.hoisted.selectedIndices &&\n                        selectedIndices &&\n                        prevProps.hoisted.selectedIndices[0] !== selectedIndices[0]) ||\n                        (!allowFreeform && !allowFreeInput) ||\n                        text !== prevProps.text)))) {\n            this._onFocus();\n        }\n        this._notifyPendingValueChanged(prevState);\n        if (isOpen && !prevState.isOpen) {\n            // handle dismiss buffer after suggestions are opened\n            this._overrideScrollDismiss = true;\n            this._async.clearTimeout(this._overrideScrollDimissTimeout);\n            this._overrideScrollDimissTimeout = this._async.setTimeout(function () {\n                _this._overrideScrollDismiss = false;\n            }, 100);\n            onMenuOpen === null || onMenuOpen === void 0 ? void 0 : onMenuOpen();\n        }\n        if (!isOpen && prevState.isOpen && onMenuDismissed) {\n            onMenuDismissed();\n        }\n        var newCurrentPendingValueValidIndex = currentPendingValueValidIndex;\n        var options = currentOptions.map(function (item, index) { return (__assign(__assign({}, item), { index: index })); });\n        // If currentOptions differs from the previous currentOptions we need to update the currentPendingValueValidIndex\n        // otherwise, it will be out of sync with the currentOptions. This can happen when the options are filtered.\n        if (!shallowCompare(prevProps.hoisted.currentOptions, currentOptions) && currentPendingValue) {\n            newCurrentPendingValueValidIndex =\n                this.props.allowFreeform || this.props.allowFreeInput\n                    ? this._processInputChangeWithFreeform(currentPendingValue)\n                    : this._updateAutocompleteIndexWithoutFreeform(currentPendingValue);\n        }\n        var descendantText = undefined;\n        if (isOpen && this._hasFocus() && newCurrentPendingValueValidIndex !== -1) {\n            descendantText =\n                (_a = options[newCurrentPendingValueValidIndex].id) !== null && _a !== void 0 ? _a : this._id + '-list' + newCurrentPendingValueValidIndex;\n        }\n        else if (isOpen && selectedIndices.length) {\n            descendantText = (_c = (_b = options[selectedIndices[0]]) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : this._id + '-list' + selectedIndices[0];\n        }\n        if (descendantText !== this.state.ariaActiveDescendantValue) {\n            this.setState({\n                ariaActiveDescendantValue: descendantText,\n            });\n        }\n    };\n    ComboBoxInternal.prototype.componentWillUnmount = function () {\n        this._async.dispose();\n        this._events.dispose();\n    };\n    // Primary Render\n    ComboBoxInternal.prototype.render = function () {\n        var id = this._id;\n        var errorMessageId = id + '-error';\n        var _a = this.props, className = _a.className, disabled = _a.disabled, required = _a.required, errorMessage = _a.errorMessage, _b = _a.onRenderContainer, onRenderContainer = _b === void 0 ? this._onRenderContainer : _b, _c = _a.onRenderLabel, onRenderLabel = _c === void 0 ? this._onRenderLabel : _c, _d = _a.onRenderList, onRenderList = _d === void 0 ? this._onRenderList : _d, _e = _a.onRenderItem, onRenderItem = _e === void 0 ? this._onRenderItem : _e, _f = _a.onRenderOption, onRenderOption = _f === void 0 ? this._onRenderOptionContent : _f, allowFreeform = _a.allowFreeform, customStyles = _a.styles, theme = _a.theme, persistMenu = _a.persistMenu, multiSelect = _a.multiSelect, _g = _a.hoisted, suggestedDisplayValue = _g.suggestedDisplayValue, selectedIndices = _g.selectedIndices, currentOptions = _g.currentOptions;\n        var isOpen = this.state.isOpen;\n        this._currentVisibleValue = this._getVisibleValue();\n        // Single select is already accessible since the whole text is selected\n        // when focus enters the input. Since multiselect appears to clear the input\n        // it needs special accessible text\n        var multiselectAccessibleText = multiSelect\n            ? this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue)\n            : undefined;\n        var divProps = getNativeProps(this.props, divProperties, [\n            'onChange',\n            'value',\n            'aria-describedby',\n            'aria-labelledby',\n        ]);\n        var hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n        this._classNames = this.props.getClassNames\n            ? this.props.getClassNames(theme, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage, className)\n            : getClassNames(getStyles(theme, customStyles), className, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage);\n        var comboBoxWrapper = this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId);\n        return (React.createElement(\"div\", __assign({}, divProps, { ref: this.props.hoisted.mergedRootRef, className: this._classNames.container }),\n            onRenderLabel({ props: this.props, multiselectAccessibleText: multiselectAccessibleText }, this._onRenderLabel),\n            comboBoxWrapper,\n            (persistMenu || isOpen) &&\n                onRenderContainer(__assign(__assign({}, this.props), { onRenderList: onRenderList, onRenderItem: onRenderItem, onRenderOption: onRenderOption, options: currentOptions.map(function (item, index) { return (__assign(__assign({}, item), { index: index })); }), onDismiss: this._onDismiss }), this._onRenderContainer),\n            hasErrorMessage && (React.createElement(\"div\", { role: \"alert\", id: errorMessageId, className: this._classNames.errorMessage }, errorMessage))));\n    };\n    ComboBoxInternal.prototype._getPendingString = function (currentPendingValue, currentOptions, index) {\n        return currentPendingValue !== null && currentPendingValue !== undefined\n            ? currentPendingValue\n            : indexWithinBounds(currentOptions, index)\n                ? getPreviewText(currentOptions[index])\n                : '';\n    };\n    /**\n     * Returns a string that concatenates all of the selected values\n     * for multiselect combo box.\n     */\n    ComboBoxInternal.prototype._getMultiselectDisplayString = function (selectedIndices, currentOptions, suggestedDisplayValue) {\n        var displayValues = [];\n        for (var idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n            var index = selectedIndices[idx];\n            if (currentOptions[index].itemType !== SelectableOptionMenuItemType.SelectAll) {\n                displayValues.push(indexWithinBounds(currentOptions, index)\n                    ? currentOptions[index].text\n                    : normalizeToString(suggestedDisplayValue));\n            }\n        }\n        var _a = this.props.multiSelectDelimiter, multiSelectDelimiter = _a === void 0 ? ', ' : _a;\n        return displayValues.join(multiSelectDelimiter);\n    };\n    /**\n     * Do not dismiss if the window resizes or scrolls within 100ms of opening\n     * This prevents the Android issue where pickers immediately dismiss on open, because the keyboard appears\n     * @param ev - the event triggering the dismiss check\n     * @returns a boolean indicating whether the callout dismissal should be prevented\n     */\n    ComboBoxInternal.prototype._preventDismissOnScrollOrResize = function (ev) {\n        // default to passed-in preventDismiss\n        var calloutProps = this.props.calloutProps;\n        if (calloutProps === null || calloutProps === void 0 ? void 0 : calloutProps.preventDismissOnEvent) {\n            return calloutProps.preventDismissOnEvent(ev);\n        }\n        if (this._overrideScrollDismiss && (ev.type === 'scroll' || ev.type === 'resize')) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Process the new input's new value when the combo box allows freeform entry\n     * @param updatedValue - the input's newly changed value\n     * @returns the index of the matched option, -1 if no match was found\n     */\n    ComboBoxInternal.prototype._processInputChangeWithFreeform = function (updatedValue) {\n        var _this = this;\n        var currentOptions = this.props.hoisted.currentOptions;\n        var newCurrentPendingValueValidIndex = -1;\n        // if the new value is empty, see if we have an exact match and then set the pending info\n        if (updatedValue === '') {\n            var items = currentOptions\n                .map(function (item, index) { return (__assign(__assign({}, item), { index: index })); })\n                .filter(function (option) { return isNormalOption(option) && !option.disabled && getPreviewText(option) === updatedValue; });\n            // if we found a match remember the index\n            if (items.length === 1) {\n                newCurrentPendingValueValidIndex = items[0].index;\n            }\n            this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n            return newCurrentPendingValueValidIndex;\n        }\n        // Remember the original value and then make the value lowercase for comparison\n        var originalUpdatedValue = updatedValue;\n        // Make the value lowercase for comparison if caseSensitive is false\n        updatedValue = this._adjustForCaseSensitivity(updatedValue);\n        var newSuggestedDisplayValue = '';\n        // If autoComplete is on, attempt to find a match from the available options\n        if (this.props.autoComplete === 'on') {\n            // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n            var items = currentOptions\n                .map(function (item, index) { return (__assign(__assign({}, item), { index: index })); })\n                .filter(function (option) {\n                return isNormalOption(option) &&\n                    !option.disabled &&\n                    _this._adjustForCaseSensitivity(getPreviewText(option)).indexOf(updatedValue) === 0;\n            });\n            if (items.length > 0) {\n                // use ariaLabel as the value when the option is set\n                var text = getPreviewText(items[0]);\n                // If the user typed out the complete option text, we don't need any suggested display text anymore\n                newSuggestedDisplayValue = this._adjustForCaseSensitivity(text) !== updatedValue ? text : '';\n                // remember the index of the match we found\n                newCurrentPendingValueValidIndex = items[0].index;\n            }\n        }\n        else {\n            // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n            var items = currentOptions\n                .map(function (item, index) { return (__assign(__assign({}, item), { index: index })); })\n                .filter(function (option) {\n                return isNormalOption(option) &&\n                    !option.disabled &&\n                    _this._adjustForCaseSensitivity(getPreviewText(option)) === updatedValue;\n            });\n            // if we found a match remember the index\n            if (items.length === 1) {\n                newCurrentPendingValueValidIndex = items[0].index;\n            }\n        }\n        // Set the updated state\n        this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n        return newCurrentPendingValueValidIndex;\n    };\n    /**\n     * Process the new input's new value when the combo box does not allow freeform entry\n     * @param updatedValue - the input's newly changed value\n     * @returns the index of the matched option\n     */\n    ComboBoxInternal.prototype._processInputChangeWithoutFreeform = function (updatedValue) {\n        var _this = this;\n        var _a = this.state, currentPendingValue = _a.currentPendingValue, currentPendingValueValidIndex = _a.currentPendingValueValidIndex;\n        if (this.props.autoComplete === 'on') {\n            // If autoComplete is on while allow freeform is off,\n            // we will remember the key press and build up a string to attempt to match\n            // as long as characters are typed within a the timeout span of each other,\n            // otherwise we will clear the string and start building a new one on the next keypress.\n            // Also, only do this processing if we have a non-empty value\n            if (updatedValue !== '') {\n                // If we have a pending autocomplete clearing task,\n                // we know that the user is typing with key press happening\n                // within the timeout of each other so remove the clearing task\n                // and continue building the pending value with the updated value\n                if (this._autoCompleteTimeout) {\n                    this._async.clearTimeout(this._autoCompleteTimeout);\n                    this._autoCompleteTimeout = undefined;\n                    updatedValue = normalizeToString(currentPendingValue) + updatedValue;\n                }\n                var matchingIndex = this._updateAutocompleteIndexWithoutFreeform(updatedValue);\n                // Schedule a timeout to clear the pending value after the timeout span\n                this._autoCompleteTimeout = this._async.setTimeout(function () {\n                    _this._autoCompleteTimeout = undefined;\n                }, ReadOnlyPendingAutoCompleteTimeout);\n                return matchingIndex;\n            }\n        }\n        // If we get here, autoComplete is off.\n        // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n        // use that; otherwise use the selectedIndex\n        var index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\n        // Since we are not allowing freeform, we need to\n        // set both the pending and suggested values/index\n        // to allow us to select all content in the input to\n        // give the illusion that we are readonly (e.g. freeform off)\n        this._setPendingInfoFromIndex(index);\n        return index;\n    };\n    ComboBoxInternal.prototype._updateAutocompleteIndexWithoutFreeform = function (updatedValue) {\n        var _this = this;\n        var currentOptions = this.props.hoisted.currentOptions;\n        var originalUpdatedValue = updatedValue;\n        updatedValue = this._adjustForCaseSensitivity(updatedValue);\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n        var items = currentOptions\n            .map(function (item, i) { return (__assign(__assign({}, item), { index: i })); })\n            .filter(function (option) {\n            return isNormalOption(option) &&\n                !option.disabled &&\n                _this._adjustForCaseSensitivity(option.text).indexOf(updatedValue) === 0;\n        });\n        // If we found a match, update the state\n        if (items.length > 0) {\n            this._setPendingInfo(originalUpdatedValue, items[0].index, getPreviewText(items[0]));\n            return items[0].index;\n        }\n        return -1;\n    };\n    ComboBoxInternal.prototype._getFirstSelectedIndex = function () {\n        var selectedIndices = this.props.hoisted.selectedIndices;\n        return (selectedIndices === null || selectedIndices === void 0 ? void 0 : selectedIndices.length) ? selectedIndices[0] : -1;\n    };\n    /**\n     * Walk along the options starting at the index, stepping by the delta (positive or negative)\n     * looking for the next valid selectable index (e.g. skipping headings and dividers)\n     * @param index - the index to get the next selectable index from\n     * @param delta - optional delta to step by when finding the next index, defaults to 0\n     * @returns - the next valid selectable index. If the new index is outside of the bounds,\n     * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n     */\n    ComboBoxInternal.prototype._getNextSelectableIndex = function (index, searchDirection) {\n        var currentOptions = this.props.hoisted.currentOptions;\n        var newIndex = index + searchDirection;\n        newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n        if (!indexWithinBounds(currentOptions, newIndex)) {\n            return -1;\n        }\n        var option = currentOptions[newIndex];\n        if (!isSelectableOption(option) || option.hidden === true) {\n            // Should we continue looking for an index to select?\n            if (searchDirection !== SearchDirection.none &&\n                ((newIndex > 0 && searchDirection < SearchDirection.none) ||\n                    (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))) {\n                newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n            }\n            else {\n                // If we cannot perform a useful search just return the index we were given\n                return index;\n            }\n        }\n        // We have the next valid selectable index, return it\n        return newIndex;\n    };\n    /**\n     * Set the selected index. Note, this is\n     * the \"real\" selected index, not the pending selected index\n     * @param index - the index to set (or the index to set from if a search direction is provided)\n     * @param searchDirection - the direction to search along the options from the given index\n     */\n    ComboBoxInternal.prototype._setSelectedIndex = function (index, submitPendingValueEvent, searchDirection) {\n        if (searchDirection === void 0) { searchDirection = SearchDirection.none; }\n        var _a = this.props, onChange = _a.onChange, onPendingValueChanged = _a.onPendingValueChanged, _b = _a.hoisted, initialIndices = _b.selectedIndices, currentOptions = _b.currentOptions;\n        // Clone currentOptions and selectedIndices so we don't mutate state\n        var selectedIndices = initialIndices ? initialIndices.slice() : [];\n        var changedOptions = currentOptions.slice();\n        // Find the next selectable index, if searchDirection is none\n        // we will get our starting index back\n        index = this._getNextSelectableIndex(index, searchDirection);\n        if (!indexWithinBounds(currentOptions, index)) {\n            return;\n        }\n        // Are we at a new index? If so, update the state, otherwise\n        // there is nothing to do\n        if (this.props.multiSelect ||\n            selectedIndices.length < 1 ||\n            (selectedIndices.length === 1 && selectedIndices[0] !== index)) {\n            var option = __assign({}, currentOptions[index]);\n            // if option doesn't existing, or option is disabled, we noop\n            if (!option || option.disabled) {\n                return;\n            }\n            if (this.props.multiSelect) {\n                // Setting the initial state of option.selected in Multi-select combo box by checking the\n                // selectedIndices array and overriding the undefined issue\n                option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;\n                // handle changing all options if SelectAll is changed\n                if (option.itemType === SelectableOptionMenuItemType.SelectAll) {\n                    selectedIndices = [];\n                    // if select all is set to checked, push all selectable option indices\n                    if (option.selected) {\n                        currentOptions.forEach(function (currentOption, i) {\n                            if (!currentOption.disabled && isSelectableOption(currentOption)) {\n                                selectedIndices.push(i);\n                                changedOptions[i] = __assign(__assign({}, currentOption), { selected: true });\n                            }\n                        });\n                    }\n                    // otherwise un-check all options\n                    else {\n                        changedOptions = currentOptions.map(function (currentOption) { return (__assign(__assign({}, currentOption), { selected: false })); });\n                    }\n                }\n                // otherwise update the individual option\n                else {\n                    if (option.selected && selectedIndices.indexOf(index) < 0) {\n                        selectedIndices.push(index);\n                    }\n                    else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\n                        selectedIndices = selectedIndices.filter(function (value) { return value !== index; });\n                    }\n                    changedOptions[index] = option;\n                    // If SelectAll exists and another option was toggled, update the SelectAll option's state\n                    var selectAllOption = changedOptions.filter(function (o) { return o.itemType === SelectableOptionMenuItemType.SelectAll; })[0];\n                    if (selectAllOption) {\n                        var selectAllState = this._isSelectAllChecked(selectedIndices);\n                        var selectAllIndex_1 = changedOptions.indexOf(selectAllOption);\n                        if (selectAllState) {\n                            selectedIndices.push(selectAllIndex_1);\n                            changedOptions[selectAllIndex_1] = __assign(__assign({}, selectAllOption), { selected: true });\n                        }\n                        else {\n                            selectedIndices = selectedIndices.filter(function (value) { return value !== selectAllIndex_1; });\n                            changedOptions[selectAllIndex_1] = __assign(__assign({}, selectAllOption), { selected: false });\n                        }\n                    }\n                }\n            }\n            else {\n                selectedIndices[0] = index;\n            }\n            submitPendingValueEvent.persist();\n            // Only setState if combo box is uncontrolled.\n            if (this.props.selectedKey || this.props.selectedKey === null) {\n                // If combo box value is changed, revert preview first\n                if (this._hasPendingValue && onPendingValueChanged) {\n                    onPendingValueChanged();\n                    this._hasPendingValue = false;\n                }\n            }\n            else {\n                this.props.hoisted.setSelectedIndices(selectedIndices);\n                this.props.hoisted.setCurrentOptions(changedOptions);\n                // If ComboBox value is changed, revert preview first\n                if (this._hasPendingValue && onPendingValueChanged) {\n                    onPendingValueChanged();\n                    this._hasPendingValue = false;\n                }\n            }\n            // Call onChange after state is updated\n            if (onChange) {\n                onChange(submitPendingValueEvent, option, index, getPreviewText(option));\n            }\n        }\n        if (this.props.multiSelect && this.state.isOpen) {\n            return;\n        }\n        // clear all of the pending info\n        this._clearPendingInfo();\n    };\n    /**\n     * Submit a pending value if there is one\n     */\n    ComboBoxInternal.prototype._submitPendingValue = function (submitPendingValueEvent) {\n        var _a;\n        var _b = this.props, onChange = _b.onChange, allowFreeform = _b.allowFreeform, autoComplete = _b.autoComplete, multiSelect = _b.multiSelect, hoisted = _b.hoisted;\n        var currentOptions = hoisted.currentOptions;\n        var _c = this.state, currentPendingValue = _c.currentPendingValue, currentPendingValueValidIndex = _c.currentPendingValueValidIndex, currentPendingValueValidIndexOnHover = _c.currentPendingValueValidIndexOnHover;\n        var selectedIndices = this.props.hoisted.selectedIndices;\n        // Do not submit any pending value if we\n        // have already initiated clearing the pending info\n        if (this._processingClearPendingInfo) {\n            return;\n        }\n        // If we allow freeform we need to handle that\n        if (allowFreeform) {\n            // if currentPendingValue is null or undefined the user did not submit anything\n            // (not even empty because we would have stored that as the pending value)\n            if (currentPendingValue === null || currentPendingValue === undefined) {\n                // if a user did not type anything they may just hovered over an item\n                if (currentPendingValueValidIndexOnHover >= 0) {\n                    this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n                    this._clearPendingInfo();\n                }\n                return;\n            }\n            // Check to see if the user typed an exact match\n            if (indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n                var pendingOptionText = this._adjustForCaseSensitivity(getPreviewText(currentOptions[currentPendingValueValidIndex]));\n                var autofill = this._autofill.current;\n                // By exact match, that means: our pending value is the same as the pending option text OR\n                // the pending option starts with the pending value and we have an \"autoComplete\" selection\n                // where the total length is equal to pending option length OR\n                // the live value in the underlying input matches the pending option; update the state\n                var adjustedCurrentPendingValue = this._adjustForCaseSensitivity(currentPendingValue);\n                if (adjustedCurrentPendingValue === pendingOptionText ||\n                    (autoComplete &&\n                        pendingOptionText.indexOf(adjustedCurrentPendingValue) === 0 &&\n                        (autofill === null || autofill === void 0 ? void 0 : autofill.isValueSelected) &&\n                        currentPendingValue.length + (autofill.selectionEnd - autofill.selectionStart) ===\n                            pendingOptionText.length) ||\n                    (((_a = autofill === null || autofill === void 0 ? void 0 : autofill.inputElement) === null || _a === void 0 ? void 0 : _a.value) !== undefined &&\n                        this._adjustForCaseSensitivity(autofill.inputElement.value) === pendingOptionText)) {\n                    this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n                    if (multiSelect && this.state.isOpen) {\n                        return;\n                    }\n                    this._clearPendingInfo();\n                    return;\n                }\n            }\n            if (onChange) {\n                if (onChange) {\n                    // trigger onChange to clear value\n                    onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n                }\n            }\n            else {\n                // If we are not controlled, create a new selected option\n                var newOption = {\n                    key: currentPendingValue || getId(),\n                    text: normalizeToString(currentPendingValue),\n                };\n                // If it's multiselect, set selected state to true\n                if (multiSelect) {\n                    newOption.selected = true;\n                }\n                var newOptions = currentOptions.concat([newOption]);\n                if (selectedIndices) {\n                    if (!multiSelect) {\n                        selectedIndices = [];\n                    }\n                    selectedIndices.push(newOptions.length - 1);\n                }\n                hoisted.setCurrentOptions(newOptions);\n                hoisted.setSelectedIndices(selectedIndices);\n            }\n        }\n        else if (currentPendingValueValidIndex >= 0) {\n            // Since we are not allowing freeform, we must have a matching\n            // to be able to update state\n            this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n        }\n        else if (currentPendingValueValidIndexOnHover >= 0) {\n            // If all else failed and we were hovering over an item, select it\n            this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n        }\n        // Finally, clear the pending info\n        this._clearPendingInfo();\n    };\n    ComboBoxInternal.prototype._onCalloutLayerMounted = function () {\n        // In persistMenu mode _onLayerMounted is only called once for the lifetime\n        // of the component. Any functionality required for callout \"on mount\" can\n        // go here so that we can also call it again during callout dismissal to reset\n        // object state.\n        this._gotMouseMove = false;\n    };\n    // Render separator\n    ComboBoxInternal.prototype._renderSeparator = function (item) {\n        var index = item.index, key = item.key;\n        if (index && index > 0) {\n            return React.createElement(\"div\", { role: \"presentation\", key: key, className: this._classNames.divider });\n        }\n        return null;\n    };\n    ComboBoxInternal.prototype._renderHeader = function (item) {\n        var _a = this.props.onRenderOption, onRenderOption = _a === void 0 ? this._onRenderOptionContent : _a;\n        return (React.createElement(\"div\", { id: item.id, key: item.key, className: this._classNames.header }, onRenderOption(item, this._onRenderOptionContent)));\n    };\n    ComboBoxInternal.prototype._renderCheckboxLabel = function (item) {\n        var _a = this.props.onRenderOption, onRenderOption = _a === void 0 ? this._onRenderMultiselectOptionContent : _a;\n        return onRenderOption(item, this._onRenderMultiselectOptionContent);\n    };\n    /**\n     * If we are coming from a mouseOut:\n     * there is no visible selected option.\n     *\n     * Else if We are hovering over an item:\n     * that gets the selected look.\n     *\n     * Else:\n     * Use the current valid pending index if it exists OR\n     * we do not have a valid index and we currently have a pending input value,\n     * otherwise use the selected index\n     * */\n    ComboBoxInternal.prototype._isOptionHighlighted = function (index) {\n        var currentPendingValueValidIndexOnHover = this.state.currentPendingValueValidIndexOnHover;\n        // If the hover state is set to clearAll, don't show a selected index.\n        // Note, this happens when the user moused out of the menu items\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            return false;\n        }\n        return currentPendingValueValidIndexOnHover >= 0\n            ? currentPendingValueValidIndexOnHover === index\n            : this._isOptionSelected(index);\n    };\n    ComboBoxInternal.prototype._isOptionSelected = function (index) {\n        return this._getPendingSelectedIndex(true /* includePendingValue */) === index;\n    };\n    ComboBoxInternal.prototype._isOptionChecked = function (index) {\n        if (this.props.multiSelect && index !== undefined && this.props.hoisted.selectedIndices) {\n            var idxOfSelectedIndex = -1;\n            idxOfSelectedIndex = this.props.hoisted.selectedIndices.indexOf(index);\n            return idxOfSelectedIndex >= 0;\n        }\n        return false;\n    };\n    ComboBoxInternal.prototype._isOptionIndeterminate = function (index) {\n        var _a = this.props, multiSelect = _a.multiSelect, hoisted = _a.hoisted;\n        if (multiSelect && index !== undefined && hoisted.selectedIndices && hoisted.currentOptions) {\n            var option = hoisted.currentOptions[index];\n            if (option && option.itemType === SelectableOptionMenuItemType.SelectAll) {\n                return hoisted.selectedIndices.length > 0 && !this._isSelectAllChecked();\n            }\n        }\n        return false;\n    };\n    ComboBoxInternal.prototype._isSelectAllChecked = function (testIndices) {\n        var _a = this.props, multiSelect = _a.multiSelect, hoisted = _a.hoisted;\n        var selectAllOption = hoisted.currentOptions.find(function (option) { return option.itemType === SelectableOptionMenuItemType.SelectAll; });\n        var selectedIndices = testIndices || hoisted.selectedIndices;\n        if (!multiSelect || !selectedIndices || !selectAllOption) {\n            return false;\n        }\n        // start by not including the select all option itself\n        var selectAllIndex = hoisted.currentOptions.indexOf(selectAllOption);\n        var compareSelectedIndices = selectedIndices.filter(function (value) { return value !== selectAllIndex; });\n        // get array of selectable options, excluding disabled options, headers, and dividers\n        var selectableOptions = hoisted.currentOptions.filter(function (option) {\n            return !option.disabled && option.itemType !== SelectableOptionMenuItemType.SelectAll && isSelectableOption(option);\n        });\n        return compareSelectedIndices.length === selectableOptions.length;\n    };\n    /**\n     * Gets the pending selected index taking into account valueValidIndex and selectedIndex\n     * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n     * finding the index\n     */\n    ComboBoxInternal.prototype._getPendingSelectedIndex = function (includeCurrentPendingValue) {\n        var _a = this.state, currentPendingValueValidIndex = _a.currentPendingValueValidIndex, currentPendingValue = _a.currentPendingValue;\n        return currentPendingValueValidIndex >= 0 ||\n            (includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined)\n            ? currentPendingValueValidIndex\n            : this.props.multiSelect\n                ? -1\n                : this._getFirstSelectedIndex();\n    };\n    /**\n     * Scroll the selected element into view\n     */\n    ComboBoxInternal.prototype._scrollIntoView = function () {\n        var _a = this.props, onScrollToItem = _a.onScrollToItem, scrollSelectedToTop = _a.scrollSelectedToTop;\n        var currentPendingSelectedIndex = this._getPendingSelectedIndex(true);\n        if (onScrollToItem) {\n            // Use the custom scroll handler\n            onScrollToItem(currentPendingSelectedIndex >= 0 ? currentPendingSelectedIndex : this._getFirstSelectedIndex());\n            return;\n        }\n        var scrollToElement = this._selectedElement.current;\n        // in multi-select there are multiple selected elements, so we use the pending select index\n        // to locate the option to scroll to.\n        if (this.props.multiSelect && this._comboBoxMenu.current) {\n            scrollToElement = findFirstDescendant(this._comboBoxMenu.current, function (element) {\n                var _a;\n                return ((_a = element.dataset) === null || _a === void 0 ? void 0 : _a.index) === currentPendingSelectedIndex.toString();\n            });\n        }\n        if (scrollToElement && scrollToElement.offsetParent) {\n            var alignToTop = true;\n            // We are using refs, scroll the ref into view\n            if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n                var scrollableParent = this._comboBoxMenu.current.offsetParent;\n                var selectedElement = scrollToElement.offsetParent;\n                var _b = selectedElement, offsetHeight = _b.offsetHeight, offsetTop = _b.offsetTop;\n                var _c = scrollableParent, parentOffsetHeight = _c.offsetHeight, scrollTop = _c.scrollTop;\n                var isAbove = offsetTop < scrollTop;\n                var isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;\n                if (isAbove || scrollSelectedToTop) {\n                    alignToTop = false;\n                    scrollableParent.scrollTo(0, offsetTop);\n                }\n                else if (isBelow) {\n                    scrollableParent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);\n                }\n            }\n            // if _comboboxMenu doesn't exist, fall back to scrollIntoView\n            else {\n                scrollToElement.offsetParent.scrollIntoView(alignToTop);\n            }\n        }\n    };\n    /**\n     * Click handler for the menu items\n     * to select the item and also close the menu\n     * @param index - the index of the item that was clicked\n     */\n    ComboBoxInternal.prototype._onItemClick = function (item) {\n        var _this = this;\n        var onItemClick = this.props.onItemClick;\n        var index = item.index;\n        return function (ev) {\n            // only close the callout when it's in single-select mode\n            if (!_this.props.multiSelect) {\n                // ensure that focus returns to the input, not the button\n                _this._autofill.current && _this._autofill.current.focus();\n                _this.setState({\n                    isOpen: false,\n                });\n            }\n            // Continue processing the click only after\n            // performing menu close / control focus(inner working)\n            onItemClick && onItemClick(ev, item, index);\n            _this._setSelectedIndex(index, ev);\n        };\n    };\n    /**\n     * Reset the selected index by clearing the\n     * input (of any pending text), clearing the pending state,\n     * and setting the suggested display value to the last\n     * selected state text\n     */\n    ComboBoxInternal.prototype._resetSelectedIndex = function () {\n        var currentOptions = this.props.hoisted.currentOptions;\n        this._clearPendingInfo();\n        var selectedIndex = this._getFirstSelectedIndex();\n        if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n            this.props.hoisted.setSuggestedDisplayValue(currentOptions[selectedIndex].text);\n        }\n        else if (this.props.text) {\n            // If we had a value initially, restore it\n            this.props.hoisted.setSuggestedDisplayValue(this.props.text);\n        }\n    };\n    /**\n     * Clears the pending info state\n     */\n    ComboBoxInternal.prototype._clearPendingInfo = function () {\n        this._processingClearPendingInfo = true;\n        this.props.hoisted.setSuggestedDisplayValue(undefined);\n        this.setState({\n            currentPendingValue: undefined,\n            currentPendingValueValidIndex: -1,\n            currentPendingValueValidIndexOnHover: HoverStatus.default,\n        }, this._onAfterClearPendingInfo);\n    };\n    /**\n     * Set the pending info\n     * @param currentPendingValue - new pending value to set\n     * @param currentPendingValueValidIndex - new pending value index to set\n     * @param suggestedDisplayValue - new suggest display value to set\n     */\n    ComboBoxInternal.prototype._setPendingInfo = function (currentPendingValue, currentPendingValueValidIndex, suggestedDisplayValue) {\n        if (currentPendingValueValidIndex === void 0) { currentPendingValueValidIndex = -1; }\n        if (this._processingClearPendingInfo) {\n            return;\n        }\n        this.props.hoisted.setSuggestedDisplayValue(suggestedDisplayValue);\n        this.setState({\n            currentPendingValue: normalizeToString(currentPendingValue),\n            currentPendingValueValidIndex: currentPendingValueValidIndex,\n            currentPendingValueValidIndexOnHover: HoverStatus.default,\n        });\n    };\n    /**\n     * Set the pending info from the given index\n     * @param index - the index to set the pending info from\n     */\n    ComboBoxInternal.prototype._setPendingInfoFromIndex = function (index) {\n        var currentOptions = this.props.hoisted.currentOptions;\n        if (index >= 0 && index < currentOptions.length) {\n            var option = currentOptions[index];\n            this._setPendingInfo(getPreviewText(option), index, getPreviewText(option));\n        }\n        else {\n            this._clearPendingInfo();\n        }\n    };\n    /**\n     * Sets the pending info for the combo box\n     * @param index - the index to search from\n     * @param searchDirection - the direction to search\n     */\n    ComboBoxInternal.prototype._setPendingInfoFromIndexAndDirection = function (index, searchDirection) {\n        var currentOptions = this.props.hoisted.currentOptions;\n        // update index to allow content to wrap\n        if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n            index = -1;\n        }\n        else if (searchDirection === SearchDirection.backward && index <= 0) {\n            index = currentOptions.length;\n        }\n        // get the next \"valid\" index\n        var indexUpdate = this._getNextSelectableIndex(index, searchDirection);\n        // if the two indices are equal we didn't move and\n        // we should attempt to get  get the first/last \"valid\" index to use\n        // (Note, this takes care of the potential cases where the first/last\n        // item is not focusable), otherwise use the updated index\n        if (index === indexUpdate) {\n            if (searchDirection === SearchDirection.forward) {\n                index = this._getNextSelectableIndex(-1, searchDirection);\n            }\n            else if (searchDirection === SearchDirection.backward) {\n                index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n            }\n        }\n        else {\n            index = indexUpdate;\n        }\n        if (indexWithinBounds(currentOptions, index)) {\n            this._setPendingInfoFromIndex(index);\n        }\n    };\n    ComboBoxInternal.prototype._notifyPendingValueChanged = function (prevState) {\n        var onPendingValueChanged = this.props.onPendingValueChanged;\n        if (!onPendingValueChanged) {\n            return;\n        }\n        var currentOptions = this.props.hoisted.currentOptions;\n        var _a = this.state, currentPendingValue = _a.currentPendingValue, currentPendingValueValidIndex = _a.currentPendingValueValidIndex, currentPendingValueValidIndexOnHover = _a.currentPendingValueValidIndexOnHover;\n        var newPendingIndex = undefined;\n        var newPendingValue = undefined;\n        if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&\n            indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {\n            // Set new pending index if hover index was changed\n            newPendingIndex = currentPendingValueValidIndexOnHover;\n        }\n        else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&\n            indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n            // Set new pending index if currentPendingValueValidIndex was changed\n            newPendingIndex = currentPendingValueValidIndex;\n        }\n        else if (currentPendingValue !== prevState.currentPendingValue) {\n            // Set pendingValue in the case it was changed and no index was changed\n            newPendingValue = currentPendingValue;\n        }\n        // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n        if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n            onPendingValueChanged(newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);\n            this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n        }\n    };\n    /**\n     * Sets the isOpen state and updates focusInputAfterClose\n     */\n    ComboBoxInternal.prototype._setOpenStateAndFocusOnClose = function (isOpen, focusInputAfterClose) {\n        this._focusInputAfterClose = focusInputAfterClose;\n        this.setState({ isOpen: isOpen });\n    };\n    ComboBoxInternal.prototype._onOptionMouseEnter = function (index) {\n        if (this._shouldIgnoreMouseEvent()) {\n            return;\n        }\n        this.setState({\n            currentPendingValueValidIndexOnHover: index,\n        });\n    };\n    ComboBoxInternal.prototype._onOptionMouseMove = function (index) {\n        this._gotMouseMove = true;\n        if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n            return;\n        }\n        this.setState({\n            currentPendingValueValidIndexOnHover: index,\n        });\n    };\n    ComboBoxInternal.prototype._shouldIgnoreMouseEvent = function () {\n        return !this._isScrollIdle || !this._gotMouseMove;\n    };\n    /**\n     * Handle dismissing the menu and eating the required key event when disabled\n     * @param ev - the keyboard event that was fired\n     */\n    ComboBoxInternal.prototype._handleInputWhenDisabled = function (ev) {\n        // If we are disabled, close the menu (if needed)\n        // and eat all keystrokes other than TAB or ESC\n        if (this.props.disabled) {\n            if (this.state.isOpen) {\n                this.setState({ isOpen: false });\n            }\n            // When disabled stop propagation and prevent default\n            // of the event unless we have a tab, escape, or function key\n            if (ev !== null &&\n                // eslint-disable-next-line deprecation/deprecation\n                ev.which !== KeyCodes.tab &&\n                // eslint-disable-next-line deprecation/deprecation\n                ev.which !== KeyCodes.escape &&\n                // eslint-disable-next-line deprecation/deprecation\n                (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */) {\n                ev.stopPropagation();\n                ev.preventDefault();\n            }\n        }\n    };\n    ComboBoxInternal.prototype._handleTouchAndPointerEvent = function () {\n        var _this = this;\n        // If we already have an existing timeout from a previous touch and pointer event\n        // cancel that timeout so we can set a nwe one.\n        if (this._lastTouchTimeoutId !== undefined) {\n            this._async.clearTimeout(this._lastTouchTimeoutId);\n            this._lastTouchTimeoutId = undefined;\n        }\n        this._processingTouch = true;\n        this._lastTouchTimeoutId = this._async.setTimeout(function () {\n            _this._processingTouch = false;\n            _this._lastTouchTimeoutId = undefined;\n        }, TouchIdleDelay);\n    };\n    /**\n     * Get the styles for the current option.\n     * @param item - Item props for the current option\n     */\n    ComboBoxInternal.prototype._getCaretButtonStyles = function () {\n        var customCaretDownButtonStyles = this.props.caretDownButtonStyles;\n        return getCaretDownButtonStyles(this.props.theme, customCaretDownButtonStyles);\n    };\n    /**\n     * Get the styles for the current option.\n     * @param item - Item props for the current option\n     */\n    ComboBoxInternal.prototype._getCurrentOptionStyles = function (item) {\n        var _a;\n        var customStylesForAllOptions = this.props.comboBoxOptionStyles;\n        var customStylesForCurrentOption = item.styles;\n        var optionStyles = getOptionStyles(this.props.theme, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item), item.hidden, this._isOptionHighlighted(item.index));\n        // TODO: fix this for multi-window scenarios\n        optionStyles.__shadowConfig__ = (_a = this.props.styles) === null || _a === void 0 ? void 0 : _a.__shadowConfig__;\n        return optionStyles;\n    };\n    /**\n     * Get the aria autocomplete value for the combo box\n     * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n     * and can dynamically populate input, and 'list' if auto-complete is not enabled as selection is the only option.\n     * Ideally, this should be 'none' if auto-complete is not enabled, but there is a known bug in Edge\n     * where the callout may appear over the combo box if this attribute is set to 'none'\n     */\n    ComboBoxInternal.prototype._getAriaAutoCompleteValue = function () {\n        var autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n        return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'list';\n    };\n    ComboBoxInternal.prototype._isPendingOption = function (item) {\n        return item && item.index === this.state.currentPendingValueValidIndex;\n    };\n    /**\n     * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n     */\n    ComboBoxInternal.prototype._hasFocus = function () {\n        return this.state.focusState !== 'none';\n    };\n    ComboBoxInternal.prototype._adjustForCaseSensitivity = function (text) {\n        return this.props.caseSensitive ? text : text.toLowerCase();\n    };\n    ComboBoxInternal.contextType = WindowContext;\n    ComboBoxInternal = __decorate([\n        customizable('ComboBox', ['theme', 'styles'], true)\n    ], ComboBoxInternal);\n    return ComboBoxInternal;\n}(React.Component));\n/**\n * Get the indices of the options that are marked as selected\n * @param options - the combo box options\n * @param selectedKeys - the known selected keys to find\n * @returns - an array of the indices of the selected options, empty array if nothing is selected\n */\nfunction getSelectedIndices(options, selectedKeys) {\n    if (!options || !selectedKeys) {\n        return [];\n    }\n    var selectedIndices = {};\n    options.forEach(function (option, index) {\n        if (option.selected) {\n            selectedIndices[index] = true;\n        }\n    });\n    var _loop_1 = function (selectedKey) {\n        var index = findIndex(options, function (option) { return option.key === selectedKey; });\n        if (index > -1) {\n            selectedIndices[index] = true;\n        }\n    };\n    for (var _i = 0, selectedKeys_1 = selectedKeys; _i < selectedKeys_1.length; _i++) {\n        var selectedKey = selectedKeys_1[_i];\n        _loop_1(selectedKey);\n    }\n    return Object.keys(selectedIndices).map(Number).sort();\n}\n/**\n * Given default selected key(s) and selected key(s), return the selected keys(s).\n * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n *\n * @returns No matter what specific types the input parameters are, always return an array of\n *  either strings or numbers instead of primitive type.  This normalization makes caller's logic easier.\n */\nfunction buildDefaultSelectedKeys(defaultSelectedKey, selectedKey) {\n    var selectedKeys = buildSelectedKeys(defaultSelectedKey);\n    if (selectedKeys.length) {\n        return selectedKeys;\n    }\n    return buildSelectedKeys(selectedKey);\n}\nfunction buildSelectedKeys(selectedKey) {\n    if (selectedKey === undefined) {\n        return [];\n    }\n    // need to cast here so typescript does not complain\n    return (selectedKey instanceof Array ? selectedKey : [selectedKey]);\n}\nfunction normalizeToString(value) {\n    return value || '';\n}\n/**\n * Is the index within the bounds of the array?\n * @param options - options to check if the index is valid for\n * @param index - the index to check\n * @returns - true if the index is valid for the given options, false otherwise\n */\nfunction indexWithinBounds(options, index) {\n    return !!options && index >= 0 && index < options.length;\n}\n/** Whether this is a normal option, not a header or divider or select all. */\nfunction isNormalOption(option) {\n    return (option.itemType !== SelectableOptionMenuItemType.Header &&\n        option.itemType !== SelectableOptionMenuItemType.Divider &&\n        option.itemType !== SelectableOptionMenuItemType.SelectAll);\n}\n/** Whether this is a selectable option, not a header or divider. */\nfunction isSelectableOption(option) {\n    return (option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider);\n}\n/**\n * For scenarios where the option's `text` prop contains embedded styles, we use the option's\n * `ariaLabel` value as the text in the input and for autocomplete matching. We know to use this\n * when the `useAriaLabelAsText` prop is set to true.\n */\nfunction getPreviewText(item) {\n    return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n}\n/**\n * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n */\nfunction isAltOrMeta(ev) {\n    // eslint-disable-next-line deprecation/deprecation\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n}\n//# sourceMappingURL=ComboBox.js.map"],"names":["SearchDirection","HoverStatus","ScrollIdleDelay","TouchIdleDelay","ReadOnlyPendingAutoCompleteTimeout","ComboBoxOptionWrapper","React","_a","render","_b","oldProps","__rest","newProps","shallowCompare","COMPONENT_NAME","DEFAULT_PROPS","useOptionsState","options","defaultSelectedKey","selectedKey","getSelectedIndices","buildDefaultSelectedKeys","selectedIndices","setSelectedIndices","_c","currentOptions","setCurrentOptions","_d","suggestedDisplayValue","setSuggestedDisplayValue","selectedKeys","buildSelectedKeys","indices","ComboBox","propsWithoutDefaults","forwardedRef","getPropsWithDefaults","props","rootRef","mergedRootRef","useMergedRefs","ComboBoxInternal","__assign","findFirstDescendant","element","match","children","getChildren","index","child","candidate","_super","__extends","_this","shouldOpenOnFocus","useFocusAsync","focusAsync","isOpen","comboBox","normalizeToString","multiselectAccessibleText","errorMessageId","label","disabled","ariaLabel","ariaDescribedBy","required","errorMessage","buttonIconProps","isButtonAriaHidden","title","placeholderProp","tabIndex","autofill","iconButtonProps","ariaActiveDescendantValue","placeholder","labelledBy","labelProps","Autofill","mergeAriaAttributeValues","IconButton","text","allowFreeform","allowFreeInput","autoComplete","currentPendingValueValidIndex","currentPendingValue","currentPendingIndexValid","indexWithinBounds","getPreviewText","updatedValue","newOptions_1","__spreadArray","newOptionsFromPromise","event","doc","getDocumentEx","relatedTarget","isBlurFromComboBoxTitle","isBlurFromComboBoxMenu","isBlurFromComboBoxMenuAncestor","findElementRecursive","defaultRender","onRenderList","calloutProps","dropdownWidth","dropdownMaxWidth","onRenderUpperContent","onRenderLowerContent","useComboBoxAsMenuWidth","persistMenu","shouldRestoreFocus","id","comboBoxMenuWidth","Callout","DirectionalHint","css","ev","onRenderLabelProps","Label","onRenderItem","multiSelect","queue","renderedList","emptyQueue","newGroup","placeRenderedOptionIntoQueue","item","SelectableOptionMenuItemType","id_1","onRenderOption","isSelected","isChecked","isIndeterminate","optionStyles","optionClassNames","getComboBoxOptionClassNames","getOptionComponent","Checkbox","CommandButton","onMenuDismiss","allowParentArrowNavigation","currentPendingValueValidIndexOnHover","isAltOrMeta","KeyCodes","directionToSearch","keyPressIsAltOrMetaAlone","shouldHandleKey","isMac","isIOS","initializeComponentRef","Async","EventGroup","warnMutuallyExclusive","getId","getAllSelectedOptions","prevProps","prevState","onMenuOpen","onMenuDismissed","_e","_f","newCurrentPendingValueValidIndex","descendantText","className","onRenderContainer","onRenderLabel","customStyles","theme","_g","divProps","getNativeProps","divProperties","hasErrorMessage","getClassNames","getStyles","comboBoxWrapper","displayValues","idx","multiSelectDelimiter","items","option","isNormalOption","originalUpdatedValue","newSuggestedDisplayValue","matchingIndex","i","searchDirection","newIndex","isSelectableOption","submitPendingValueEvent","onChange","onPendingValueChanged","initialIndices","changedOptions","currentOption","value","selectAllOption","o","selectAllState","selectAllIndex_1","hoisted","pendingOptionText","adjustedCurrentPendingValue","newOption","newOptions","key","idxOfSelectedIndex","testIndices","selectAllIndex","compareSelectedIndices","selectableOptions","includeCurrentPendingValue","onScrollToItem","scrollSelectedToTop","currentPendingSelectedIndex","scrollToElement","alignToTop","scrollableParent","selectedElement","offsetHeight","offsetTop","parentOffsetHeight","scrollTop","isAbove","isBelow","onItemClick","selectedIndex","indexUpdate","newPendingIndex","newPendingValue","focusInputAfterClose","customCaretDownButtonStyles","getCaretDownButtonStyles","customStylesForAllOptions","customStylesForCurrentOption","getOptionStyles","WindowContext","__decorate","customizable","_loop_1","findIndex","_i","selectedKeys_1"],"mappings":"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","x_google_ignoreList":[0]}