import { __assign as w } from "../../../../../tslib/tslib.es6.js";
import "../../../../style-utilities/lib/index.js";
import { getGlobalClassNames as oo } from "../../../../style-utilities/lib/styles/getGlobalClassNames.js";
import { IsFocusVisibleClassName as F } from "../../../../utilities/lib/setFocusVisibility.js";
import { HighContrastSelector as r, getHighContrastNoAdjustStyle as I } from "../../../../style-utilities/lib/styles/CommonStyles.js";
var eo = {
  root: "ms-Checkbox",
  label: "ms-Checkbox-label",
  checkbox: "ms-Checkbox-checkbox",
  checkmark: "ms-Checkbox-checkmark",
  text: "ms-Checkbox-text"
}, L = "20px", z = "200ms", A = "cubic-bezier(.4, 0, .23, 1)", io = function(c) {
  var k, l, u, x, b, a, h, C, g, m, v, f, p, _, y, H, T, B, j = c.className, n = c.theme, s = c.reversed, i = c.checked, t = c.disabled, M = c.isUsingCustomLabelRender, d = c.indeterminate, e = n.semanticColors, N = n.effects, W = n.palette, K = n.fonts, o = oo(eo, n), P = e.inputForegroundChecked, U = W.neutralSecondary, X = W.neutralPrimary, R = e.inputBackgroundChecked, q = e.inputBackgroundChecked, S = e.disabledBodySubtext, D = e.inputBorderHovered, G = e.inputBackgroundCheckedHovered, V = e.inputBackgroundChecked, O = e.inputBackgroundCheckedHovered, E = e.inputBackgroundCheckedHovered, Z = e.inputTextHovered, J = e.disabledBodySubtext, Q = e.bodyText, Y = e.disabledText, $ = [
    (k = {
      content: '""',
      borderRadius: N.roundedCorner2,
      position: "absolute",
      width: 10,
      height: 10,
      top: 4,
      left: 4,
      boxSizing: "border-box",
      borderWidth: 5,
      borderStyle: "solid",
      borderColor: t ? S : R,
      transitionProperty: "border-width, border, border-color",
      transitionDuration: z,
      transitionTimingFunction: A
    }, k[r] = {
      borderColor: "WindowText"
    }, k)
  ];
  return {
    root: [
      o.root,
      {
        position: "relative",
        display: "flex"
      },
      s && "reversed",
      i && "is-checked",
      !t && "is-enabled",
      t && "is-disabled",
      !t && [
        !i && (l = {}, l[":hover .".concat(o.checkbox)] = (u = {
          borderColor: D
        }, u[r] = {
          borderColor: "Highlight"
        }, u), l[":focus .".concat(o.checkbox)] = { borderColor: D }, l[":hover .".concat(o.checkmark)] = (x = {
          color: U,
          opacity: "1"
        }, x[r] = {
          color: "Highlight"
        }, x), l),
        i && !d && (b = {}, b[":hover .".concat(o.checkbox)] = {
          background: O,
          borderColor: E
        }, b[":focus .".concat(o.checkbox)] = {
          background: O,
          borderColor: E
        }, b[r] = (a = {}, a[":hover .".concat(o.checkbox)] = {
          background: "Highlight",
          borderColor: "Highlight"
        }, a[":focus .".concat(o.checkbox)] = {
          background: "Highlight"
        }, a[":focus:hover .".concat(o.checkbox)] = {
          background: "Highlight"
        }, a[":focus:hover .".concat(o.checkmark)] = {
          color: "Window"
        }, a[":hover .".concat(o.checkmark)] = {
          color: "Window"
        }, a), b),
        d && (h = {}, h[":hover .".concat(o.checkbox, ", :hover .").concat(o.checkbox, ":after")] = (C = {
          borderColor: G
        }, C[r] = {
          borderColor: "WindowText"
        }, C), h[":focus .".concat(o.checkbox)] = {
          borderColor: G
        }, h[":hover .".concat(o.checkmark)] = {
          opacity: "0"
        }, h),
        (g = {}, g[":hover .".concat(o.text, ", :focus .").concat(o.text)] = (m = {
          color: Z
        }, m[r] = {
          color: t ? "GrayText" : "WindowText"
        }, m), g)
      ],
      j
    ],
    input: (v = {
      position: "absolute",
      background: "none",
      opacity: 0
    }, // eslint-disable-next-line @fluentui/max-len
    v[".".concat(F, " &:focus + label::before, :host(.").concat(F, ") &:focus + label::before")] = (f = {
      outline: "1px solid " + n.palette.neutralSecondary,
      outlineOffset: "2px"
    }, f[r] = {
      outline: "1px solid WindowText"
    }, f), v),
    label: [
      o.label,
      n.fonts.medium,
      {
        display: "flex",
        alignItems: M ? "center" : "flex-start",
        cursor: t ? "default" : "pointer",
        position: "relative",
        userSelect: "none"
      },
      s && {
        flexDirection: "row-reverse",
        justifyContent: "flex-end"
      },
      {
        "&::before": {
          position: "absolute",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          content: '""',
          pointerEvents: "none"
        }
      }
    ],
    checkbox: [
      o.checkbox,
      (p = {
        position: "relative",
        display: "flex",
        flexShrink: 0,
        alignItems: "center",
        justifyContent: "center",
        height: L,
        width: L,
        border: "1px solid ".concat(X),
        borderRadius: N.roundedCorner2,
        boxSizing: "border-box",
        transitionProperty: "background, border, border-color",
        transitionDuration: z,
        transitionTimingFunction: A,
        /* in case the icon is bigger than the box */
        overflow: "hidden",
        ":after": d ? $ : null
      }, p[r] = w({ borderColor: "WindowText" }, I()), p),
      d && {
        borderColor: R
      },
      s ? {
        marginLeft: 4
      } : (
        // This margin on the checkbox is for backwards compat. Notably it has the effect where a customRender
        // is used, there will be only a 4px margin from checkbox to label. The label by default would have
        // another 4px margin for a total of 8px margin between checkbox and label. We don't combine the two
        // (and move it into the text) to not incur a breaking change for everyone using custom render atm.
        {
          marginRight: 4
        }
      ),
      !t && !d && i && (_ = {
        background: V,
        borderColor: q
      }, _[r] = {
        background: "Highlight",
        borderColor: "Highlight"
      }, _),
      t && (y = {
        borderColor: S
      }, y[r] = {
        borderColor: "GrayText"
      }, y),
      i && t && (H = {
        background: J,
        borderColor: S
      }, H[r] = {
        background: "Window"
      }, H)
    ],
    checkmark: [
      o.checkmark,
      (T = {
        opacity: i && !d ? "1" : "0",
        color: P
      }, T[r] = w({ color: t ? "GrayText" : "Window" }, I()), T)
    ],
    text: [
      o.text,
      (B = {
        color: t ? Y : Q,
        fontSize: K.medium.fontSize,
        lineHeight: "20px"
      }, B[r] = w({ color: t ? "GrayText" : "WindowText" }, I()), B),
      s ? {
        marginRight: 4
      } : {
        marginLeft: 4
      }
    ]
  };
};
export {
  io as getStyles
};
//# sourceMappingURL=Checkbox.styles.js.map
