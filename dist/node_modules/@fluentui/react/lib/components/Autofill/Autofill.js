import { __extends as y, __assign as p } from "../../../../../tslib/tslib.es6.js";
import * as d from "react";
import { isIE11 as m } from "../../../../utilities/lib/ie11Detector.js";
import { KeyCodes as c } from "../../../../utilities/lib/KeyCodes.js";
import { initializeComponentRef as C } from "../../../../utilities/lib/initializeComponentRef.js";
import { Async as b } from "../../../../utilities/lib/Async.js";
import { getDocument as V } from "../../../../utilities/lib/dom/getDocument.js";
import { getNativeProps as S, inputProperties as D } from "../../../../utilities/lib/properties.js";
import { WindowContext as F } from "../../../../react-window-provider/lib/WindowProvider.js";
var I = "forward", _ = "backward", w = (
  /** @class */
  /* @__PURE__ */ function(u) {
    y(i, u);
    function i(t) {
      var e = u.call(this, t) || this;
      return e._inputElement = d.createRef(), e._autoFillEnabled = !0, e._onCompositionStart = function(n) {
        e.setState({ isComposing: !0 }), e._autoFillEnabled = !1;
      }, e._onCompositionUpdate = function() {
        m() && e._updateValue(e._getCurrentInputValue(), !0);
      }, e._onCompositionEnd = function(n) {
        var o = e._getCurrentInputValue();
        e._tryEnableAutofill(o, e.value, !1, !0), e.setState({ isComposing: !1 }), e._async.setTimeout(function() {
          e._updateValue(e._getCurrentInputValue(), !1);
        }, 0);
      }, e._onClick = function() {
        e.value && e.value !== "" && e._autoFillEnabled && (e._autoFillEnabled = !1);
      }, e._onKeyDown = function(n) {
        if (e.props.onKeyDown && e.props.onKeyDown(n), !n.nativeEvent.isComposing)
          switch (n.which) {
            case c.backspace:
              e._autoFillEnabled = !1;
              break;
            case c.left:
            case c.right:
              e._autoFillEnabled && (e.setState(function(o) {
                return {
                  inputValue: e.props.suggestedDisplayValue || o.inputValue
                };
              }), e._autoFillEnabled = !1);
              break;
            default:
              e._autoFillEnabled || e.props.enableAutofillOnKeyPress.indexOf(n.which) !== -1 && (e._autoFillEnabled = !0);
              break;
          }
      }, e._onInputChanged = function(n) {
        var o = e._getCurrentInputValue(n);
        if (e.state.isComposing || e._tryEnableAutofill(o, e.value, n.nativeEvent.isComposing), !(m() && e.state.isComposing)) {
          var l = n.nativeEvent.isComposing, r = l === void 0 ? e.state.isComposing : l;
          e._updateValue(o, r);
        }
      }, e._onChanged = function() {
      }, e._updateValue = function(n, o) {
        var l;
        if (!(!n && n === e.value)) {
          var r = (l = e.props, l.onInputChange), a = l.onInputValueChange;
          r && (n = (r == null ? void 0 : r(n, o)) || ""), e.setState({ inputValue: n }, function() {
            return a == null ? void 0 : a(n, o);
          });
        }
      }, C(e), e._async = new b(e), e.state = {
        inputValue: t.defaultVisibleValue || "",
        isComposing: !1
      }, e;
    }
    return i.getDerivedStateFromProps = function(t, e) {
      if (t.updateValueInWillReceiveProps) {
        var n = t.updateValueInWillReceiveProps();
        if (n !== null && n !== e.inputValue && !e.isComposing)
          return p(p({}, e), { inputValue: n });
      }
      return null;
    }, Object.defineProperty(i.prototype, "cursorLocation", {
      get: function() {
        if (this._inputElement.current) {
          var t = this._inputElement.current;
          return t.selectionDirection !== I ? t.selectionEnd : t.selectionStart;
        } else
          return -1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "isValueSelected", {
      get: function() {
        return !!(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "value", {
      get: function() {
        return this._getControlledValue() || this.state.inputValue || "";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "selectionStart", {
      get: function() {
        return this._inputElement.current ? this._inputElement.current.selectionStart : -1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "selectionEnd", {
      get: function() {
        return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "inputElement", {
      get: function() {
        return this._inputElement.current;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.componentDidUpdate = function(t, e, n) {
      var o, l, r = (o = this.props, o.suggestedDisplayValue), a = o.shouldSelectFullInputValueInComponentDidUpdate, v = o.preventValueSelection, s = 0;
      if (!v) {
        var f = ((l = this.context) === null || l === void 0 ? void 0 : l.window.document) || V(this._inputElement.current), E = this._inputElement.current && this._inputElement.current === (f == null ? void 0 : f.activeElement);
        if (E && this._autoFillEnabled && this.value && r && g(r, this.value)) {
          var h = !1;
          if (a && (h = a()), h)
            this._inputElement.current.setSelectionRange(0, r.length, _);
          else {
            for (; s < this.value.length && this.value[s].toLocaleLowerCase() === r[s].toLocaleLowerCase(); )
              s++;
            s > 0 && this._inputElement.current.setSelectionRange(s, r.length, _);
          }
        } else this._inputElement.current && n !== null && !this._autoFillEnabled && !this.state.isComposing && this._inputElement.current.setSelectionRange(n.start, n.end, n.dir);
      }
    }, i.prototype.componentWillUnmount = function() {
      this._async.dispose();
    }, i.prototype.render = function() {
      var t = S(this.props, D), e = p(p({}, this.props.style), { fontFamily: "inherit" });
      return d.createElement("input", p({ autoCapitalize: "off", autoComplete: "off", "aria-autocomplete": "both" }, t, {
        style: e,
        ref: this._inputElement,
        value: this._getDisplayValue(),
        onCompositionStart: this._onCompositionStart,
        onCompositionUpdate: this._onCompositionUpdate,
        onCompositionEnd: this._onCompositionEnd,
        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.
        onChange: this._onChanged,
        onInput: this._onInputChanged,
        onKeyDown: this._onKeyDown,
        onClick: this.props.onClick ? this.props.onClick : this._onClick,
        "data-lpignore": !0
      }));
    }, i.prototype.focus = function() {
      this._inputElement.current && this._inputElement.current.focus();
    }, i.prototype.clear = function() {
      this._autoFillEnabled = !0, this._updateValue("", !1), this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);
    }, i.prototype.getSnapshotBeforeUpdate = function() {
      var t, e, n = this._inputElement.current;
      return n && n.selectionStart !== this.value.length ? {
        start: (t = n.selectionStart) !== null && t !== void 0 ? t : n.value.length,
        end: (e = n.selectionEnd) !== null && e !== void 0 ? e : n.value.length,
        dir: n.selectionDirection || "backward"
      } : null;
    }, i.prototype._getCurrentInputValue = function(t) {
      return t && t.target && t.target.value ? t.target.value : this.inputElement && this.inputElement.value ? this.inputElement.value : "";
    }, i.prototype._tryEnableAutofill = function(t, e, n, o) {
      !n && t && this._inputElement.current && this._inputElement.current.selectionStart === t.length && !this._autoFillEnabled && (t.length > e.length || o) && (this._autoFillEnabled = !0);
    }, i.prototype._getDisplayValue = function() {
      return this._autoFillEnabled ? P(this.value, this.props.suggestedDisplayValue) : this.value;
    }, i.prototype._getControlledValue = function() {
      var t = this.props.value;
      return t === void 0 || typeof t == "string" ? t : (console.warn("props.value of Autofill should be a string, but it is ".concat(t, " with type of ").concat(typeof t)), t.toString());
    }, i.defaultProps = {
      enableAutofillOnKeyPress: [c.down, c.up]
    }, i.contextType = F, i;
  }(d.Component)
);
function P(u, i) {
  var t = u;
  return i && u && g(i, t) && (t = i), t;
}
function g(u, i) {
  if (!u || !i)
    return !1;
  if (process.env.NODE_ENV !== "production")
    for (var t = 0, e = [u, i]; t < e.length; t++) {
      var n = e[t];
      if (typeof n != "string")
        throw new Error("".concat(
          w.name,
          ' received non-string value "'
        ).concat(n, '" of type ').concat(typeof n, " from either input's value or suggestedDisplayValue"));
    }
  return u.toLocaleLowerCase().indexOf(i.toLocaleLowerCase()) === 0;
}
export {
  w as Autofill
};
//# sourceMappingURL=Autofill.js.map
