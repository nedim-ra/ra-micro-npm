{"version":3,"file":"BaseButton.js","sources":["../../../../../../../node_modules/@fluentui/react/lib/components/Button/BaseButton.js"],"sourcesContent":["import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { anchorProperties, assign, buttonProperties, createMergedRef, css, getId, getNativeProps, initializeComponentRef, memoizeFunction, mergeAriaAttributeValues, nullRender, portalContainsElement, setFocusVisibility, warnConditionallyRequiredProps, warnDeprecations, Async, EventGroup, FocusRects, FocusRectsContext, KeyCodes, } from '../../Utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu } from '../../ContextualMenu';\nimport { getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getSplitButtonClassNames as getBaseSplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport { composeComponentAs } from '../../Utilities';\nvar TouchIdleDelay = 500; /* ms */\nvar COMPONENT_NAME = 'BaseButton';\n/**\n * {@docCategory Button}\n */\nexport var BaseButton = /** @class */ (function (_super) {\n    __extends(BaseButton, _super);\n    function BaseButton(props) {\n        var _this = _super.call(this, props) || this;\n        _this._buttonElement = React.createRef();\n        _this._splitButtonContainer = React.createRef();\n        _this._mergedRef = createMergedRef();\n        _this._renderedVisibleMenu = false;\n        _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n            return __assign(__assign({}, keytipProps), { hasMenu: true });\n        });\n        _this._onRenderIcon = function (buttonProps, defaultRender) {\n            var iconProps = _this.props.iconProps;\n            if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n                var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest(iconProps, [\"className\", \"imageProps\"]);\n                // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon\n                // do not have this prop.\n                if (iconProps.styles) {\n                    return React.createElement(Icon, __assign({ className: css(_this._classNames.icon, className), imageProps: imageProps }, rest));\n                }\n                if (iconProps.iconName) {\n                    return React.createElement(FontIcon, __assign({ className: css(_this._classNames.icon, className) }, rest));\n                }\n                if (imageProps) {\n                    return React.createElement(ImageIcon, __assign({ className: css(_this._classNames.icon, className), imageProps: imageProps }, rest));\n                }\n            }\n            return null;\n        };\n        _this._onRenderTextContents = function () {\n            var _a, _b, _c, _d;\n            var text = (_a = _this.props, _a.text), children = _a.children, \n            // eslint-disable-next-line deprecation/deprecation\n            secondaryText = (_b = _a.secondaryText, _b === void 0 ? _this.props.description : _b), onRenderText = (_c = _a.onRenderText, _c === void 0 ? _this._onRenderText : _c), onRenderDescription = (_d = _a.onRenderDescription, _d === void 0 ? _this._onRenderDescription : _d);\n            if (text || typeof children === 'string' || secondaryText) {\n                return (React.createElement(\"span\", { className: _this._classNames.textContainer },\n                    onRenderText(_this.props, _this._onRenderText),\n                    onRenderDescription(_this.props, _this._onRenderDescription)));\n            }\n            return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];\n        };\n        _this._onRenderText = function () {\n            var text = _this.props.text;\n            var children = _this.props.children;\n            // For backwards compat, we should continue to take in the text content from children.\n            if (text === undefined && typeof children === 'string') {\n                text = children;\n            }\n            if (_this._hasText()) {\n                return (React.createElement(\"span\", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text));\n            }\n            return null;\n        };\n        _this._onRenderChildren = function () {\n            var children = _this.props.children;\n            // If children is just a string, either it or the text will be rendered via onRenderLabel\n            // If children is another component, it will be rendered after text\n            if (typeof children === 'string') {\n                return null;\n            }\n            return children;\n        };\n        _this._onRenderDescription = function (props) {\n            var _a;\n            // eslint-disable-next-line deprecation/deprecation\n            var secondaryText = (_a = props.secondaryText, _a === void 0 ? _this.props.description : _a);\n            // ms-Button-description is only shown when the button type is compound.\n            // In other cases it will not be displayed.\n            return secondaryText ? (React.createElement(\"span\", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText)) : null;\n        };\n        _this._onRenderAriaDescription = function () {\n            var ariaDescription = _this.props.ariaDescription;\n            // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n            // otherwise it will be assigned to descriptionSpan.\n            return ariaDescription ? (React.createElement(\"span\", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription)) : null;\n        };\n        _this._onRenderMenuIcon = function (props) {\n            var menuIconProps = _this.props.menuIconProps;\n            return React.createElement(FontIcon, __assign({ iconName: \"ChevronDown\" }, menuIconProps, { className: _this._classNames.menuIcon }));\n        };\n        _this._onRenderMenu = function (menuProps) {\n            var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;\n            return React.createElement(MenuType, __assign({}, menuProps));\n        };\n        _this._onDismissMenu = function (ev) {\n            var menuProps = _this.props.menuProps;\n            if (menuProps && menuProps.onDismiss) {\n                menuProps.onDismiss(ev);\n            }\n            if (!ev || !ev.defaultPrevented) {\n                _this._dismissMenu();\n            }\n        };\n        _this._dismissMenu = function () {\n            _this._menuShouldFocusOnMount = undefined;\n            _this._menuShouldFocusOnContainer = undefined;\n            _this.setState({ menuHidden: true });\n        };\n        _this._openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n            if (shouldFocusOnMount === void 0) { shouldFocusOnMount = true; }\n            if (_this.props.menuProps) {\n                _this._menuShouldFocusOnContainer = shouldFocusOnContainer;\n                _this._menuShouldFocusOnMount = shouldFocusOnMount;\n                _this._renderedVisibleMenu = true;\n                _this.setState({ menuHidden: false });\n            }\n        };\n        _this._onToggleMenu = function (shouldFocusOnContainer) {\n            var shouldFocusOnMount = true;\n            if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {\n                shouldFocusOnMount = false;\n            }\n            _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();\n        };\n        _this._onSplitContainerFocusCapture = function (ev) {\n            var container = _this._splitButtonContainer.current;\n            // If the target is coming from the portal we do not need to set focus on the container.\n            if (!container || (ev.target && portalContainsElement(ev.target, container))) {\n                return;\n            }\n            // We should never be able to focus the individual buttons in a split button. Focus\n            // should always remain on the container.\n            container.focus();\n        };\n        _this._onSplitButtonPrimaryClick = function (ev) {\n            if (!_this.state.menuHidden) {\n                _this._dismissMenu();\n            }\n            // toggle split buttons need two separate targets, even for touch\n            var singleTouchTarget = _this._processingTouch && !_this.props.toggle;\n            if (!singleTouchTarget && _this.props.onClick) {\n                _this.props.onClick(ev);\n            }\n            else if (singleTouchTarget) {\n                _this._onMenuClick(ev);\n            }\n        };\n        _this._onKeyDown = function (ev) {\n            // explicity cancelling event so click won't fire after this\n            // eslint-disable-next-line deprecation/deprecation\n            if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n            else if (!_this.props.disabled) {\n                if (_this.props.menuProps) {\n                    _this._onMenuKeyDown(ev);\n                }\n                else if (_this.props.onKeyDown !== undefined) {\n                    _this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n                }\n            }\n        };\n        _this._onKeyUp = function (ev) {\n            if (!_this.props.disabled && _this.props.onKeyUp !== undefined) {\n                _this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n            }\n        };\n        _this._onKeyPress = function (ev) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (!_this.props.disabled && _this.props.onKeyPress !== undefined) {\n                // eslint-disable-next-line deprecation/deprecation\n                _this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n            }\n        };\n        _this._onMouseUp = function (ev) {\n            if (!_this.props.disabled && _this.props.onMouseUp !== undefined) {\n                _this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n            }\n        };\n        _this._onMouseDown = function (ev) {\n            if (!_this.props.disabled && _this.props.onMouseDown !== undefined) {\n                _this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n            }\n        };\n        _this._onClick = function (ev) {\n            if (!_this.props.disabled) {\n                if (_this.props.menuProps) {\n                    _this._onMenuClick(ev);\n                }\n                else if (_this.props.onClick !== undefined) {\n                    _this.props.onClick(ev); // not cancelling event because it's not disabled\n                }\n            }\n        };\n        _this._onSplitButtonContainerKeyDown = function (ev) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n                if (_this._buttonElement.current) {\n                    _this._buttonElement.current.click();\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                }\n            }\n            else {\n                _this._onMenuKeyDown(ev);\n            }\n        };\n        _this._onMenuKeyDown = function (ev) {\n            var _a;\n            if (_this.props.disabled) {\n                return;\n            }\n            if (_this.props.onKeyDown) {\n                _this.props.onKeyDown(ev);\n            }\n            // eslint-disable-next-line deprecation/deprecation\n            var isUp = ev.which === KeyCodes.up;\n            // eslint-disable-next-line deprecation/deprecation\n            var isDown = ev.which === KeyCodes.down;\n            if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {\n                var onMenuClick = _this.props.onMenuClick;\n                if (onMenuClick) {\n                    onMenuClick(ev, _this.props);\n                }\n                _this._onToggleMenu(false);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n            // eslint-disable-next-line deprecation/deprecation\n            if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n                // We manually set the focus visibility to true if opening via Enter or Space to account for the scenario where\n                // a user clicks on the button, closes the menu and then opens it via keyboard. In this scenario our default logic\n                // for setting focus visibility is not triggered since there is no keyboard navigation present beforehand.\n                setFocusVisibility(true, ev.target, (_a = _this.context) === null || _a === void 0 ? void 0 : _a.registeredProviders);\n            }\n            if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n                // Suppose a menu, with shouldFocusOnMount: false, is open, and user wants to keyboard to the menu items\n                // We need to re-render the menu with shouldFocusOnMount as true.\n                if (!_this.state.menuHidden && _this.props.menuProps) {\n                    var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== undefined\n                        ? _this._menuShouldFocusOnMount\n                        : _this.props.menuProps.shouldFocusOnMount;\n                    if (!currentShouldFocusOnMount) {\n                        ev.preventDefault();\n                        ev.stopPropagation();\n                        _this._menuShouldFocusOnMount = true;\n                        _this.forceUpdate();\n                    }\n                }\n            }\n        };\n        _this._onTouchStart = function () {\n            if (_this._isSplitButton &&\n                _this._splitButtonContainer.current &&\n                !('onpointerdown' in _this._splitButtonContainer.current)) {\n                _this._handleTouchAndPointerEvent();\n            }\n        };\n        _this._onMenuClick = function (ev) {\n            var _a;\n            var onMenuClick = (_a = _this.props, _a.onMenuClick), menuProps = _a.menuProps;\n            if (onMenuClick) {\n                onMenuClick(ev, _this.props);\n            }\n            // focus on the container by default when the menu is opened with a click event\n            // this differentiates from a keyboard interaction triggering the click event\n            var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === 'boolean'\n                ? menuProps.shouldFocusOnContainer\n                : ev.nativeEvent.pointerType === 'mouse';\n            if (!ev.defaultPrevented) {\n                _this._onToggleMenu(shouldFocusOnContainer);\n                ev.preventDefault();\n                ev.stopPropagation();\n            }\n        };\n        initializeComponentRef(_this);\n        _this._async = new Async(_this);\n        _this._events = new EventGroup(_this);\n        warnConditionallyRequiredProps(COMPONENT_NAME, props, ['menuProps', 'onClick'], 'split', _this.props.split);\n        warnDeprecations(COMPONENT_NAME, props, {\n            rootProps: undefined,\n            description: 'secondaryText',\n            toggled: 'checked',\n        });\n        _this._labelId = getId();\n        _this._descriptionId = getId();\n        _this._ariaDescriptionId = getId();\n        _this.state = {\n            menuHidden: true,\n        };\n        return _this;\n    }\n    Object.defineProperty(BaseButton.prototype, \"_isSplitButton\", {\n        get: function () {\n            return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BaseButton.prototype.render = function () {\n        var _a, _b, _c, _d, _e;\n        var ariaDescription = (_a = this.props, _a.ariaDescription), ariaLabel = _a.ariaLabel, ariaHidden = _a.ariaHidden, className = _a.className, disabled = _a.disabled, allowDisabledFocus = _a.allowDisabledFocus, primaryDisabled = _a.primaryDisabled, \n        // eslint-disable-next-line deprecation/deprecation\n        secondaryText = (_b = _a.secondaryText, _b === void 0 ? this.props.description : _b), href = _a.href, iconProps = _a.iconProps, menuIconProps = _a.menuIconProps, styles = _a.styles, checked = _a.checked, variantClassName = _a.variantClassName, theme = _a.theme, toggle = _a.toggle, getClassNames = _a.getClassNames, role = _a.role;\n        var menuHidden = this.state.menuHidden;\n        // Button is disabled if the whole button (in case of splitButton is disabled) or if the primary action is disabled\n        var isPrimaryButtonDisabled = disabled || primaryDisabled;\n        this._classNames = getClassNames\n            ? getClassNames(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus)\n            : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);\n        var _ariaDescriptionId = (_c = this, _c._ariaDescriptionId), _labelId = _c._labelId, _descriptionId = _c._descriptionId;\n        // Anchor tag cannot be disabled hence in disabled state rendering\n        // anchor button as normal button\n        var renderAsAnchor = !isPrimaryButtonDisabled && !!href;\n        var tag = renderAsAnchor ? 'a' : 'button';\n        var nativeProps = getNativeProps(\n        // eslint-disable-next-line deprecation/deprecation\n        assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props), renderAsAnchor ? anchorProperties : buttonProperties, [\n            'disabled', // let disabled buttons be focused and styled as disabled.\n        ]);\n        // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n        var resolvedAriaLabel = ariaLabel || nativeProps['aria-label'];\n        // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of\n        // aria-describedby. Otherwise default to undefined so property does not appear in output.\n        var ariaDescribedBy = undefined;\n        if (ariaDescription) {\n            ariaDescribedBy = _ariaDescriptionId;\n        }\n        else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n            // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n            // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n            ariaDescribedBy = _descriptionId;\n        }\n        else if (nativeProps['aria-describedby']) {\n            ariaDescribedBy = nativeProps['aria-describedby'];\n        }\n        // If an explicit aria-labelledby is given, use that and we're done.\n        // If any kind of description is given (which will end up as an aria-describedby attribute)\n        // and no ariaLabel is specified, set the labelledby element.\n        // Otherwise, the button is labeled implicitly by the descendent text on the button (if it exists).\n        var ariaLabelledBy = undefined;\n        if (nativeProps['aria-labelledby']) {\n            ariaLabelledBy = nativeProps['aria-labelledby'];\n        }\n        else if (ariaDescribedBy && !resolvedAriaLabel) {\n            ariaLabelledBy = this._hasText() ? _labelId : undefined;\n        }\n        var dataIsFocusable = this.props['data-is-focusable'] === false || (disabled && !allowDisabledFocus) || this._isSplitButton\n            ? false\n            : true;\n        var isCheckboxTypeRole = role === 'menuitemcheckbox' || role === 'checkbox';\n        // if isCheckboxTypeRole, always return a checked value.\n        // Otherwise only return checked value if toggle is set to true.\n        // This is because role=\"checkbox\" always needs to have an aria-checked value\n        // but our checked prop only sets aria-pressed if we mark the button as a toggle=\"true\"\n        var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : undefined;\n        var buttonProps = assign(nativeProps, (_d = {\n                className: this._classNames.root,\n                // eslint-disable-next-line deprecation/deprecation\n                ref: this._mergedRef(this.props.elementRef, this._buttonElement),\n                disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n                onKeyDown: this._onKeyDown,\n                onKeyPress: this._onKeyPress,\n                onKeyUp: this._onKeyUp,\n                onMouseDown: this._onMouseDown,\n                onMouseUp: this._onMouseUp,\n                onClick: this._onClick,\n                'aria-label': resolvedAriaLabel,\n                'aria-labelledby': ariaLabelledBy,\n                'aria-describedby': ariaDescribedBy,\n                'aria-disabled': isPrimaryButtonDisabled,\n                'data-is-focusable': dataIsFocusable\n            },\n            // aria-pressed attribute should only be present for toggle buttons\n            // aria-checked attribute should only be present for toggle buttons with checkbox type role\n            _d[isCheckboxTypeRole ? 'aria-checked' : 'aria-pressed'] = checkedOrPressedValue,\n            _d));\n        if (ariaHidden) {\n            buttonProps['aria-hidden'] = true;\n        }\n        if (this._isSplitButton) {\n            return this._onRenderSplitButtonContent(tag, buttonProps);\n        }\n        else if (this.props.menuProps) {\n            var id = (_e = this.props.menuProps.id, _e === void 0 ? \"\".concat(this._labelId, \"-menu\") : _e);\n            assign(buttonProps, {\n                'aria-expanded': !menuHidden,\n                'aria-controls': !menuHidden ? id : null,\n                'aria-haspopup': true,\n            });\n        }\n        return this._onRenderContent(tag, buttonProps);\n    };\n    BaseButton.prototype.componentDidMount = function () {\n        // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the\n        // primary action. This gives more hit target space for touch environments. We're setting the onpointerdown here,\n        // because React does not support Pointer events yet.\n        if (this._isSplitButton && this._splitButtonContainer.current) {\n            if ('onpointerdown' in this._splitButtonContainer.current) {\n                this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n            }\n            if ('onpointerup' in this._splitButtonContainer.current && this.props.onPointerUp) {\n                this._events.on(this._splitButtonContainer.current, 'pointerup', this.props.onPointerUp, true);\n            }\n        }\n    };\n    BaseButton.prototype.componentDidUpdate = function (prevProps, prevState) {\n        // If Button's menu was closed, run onAfterMenuDismiss.\n        if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {\n            this.props.onAfterMenuDismiss();\n        }\n    };\n    BaseButton.prototype.componentWillUnmount = function () {\n        this._async.dispose();\n        this._events.dispose();\n    };\n    BaseButton.prototype.focus = function () {\n        var _a, _b;\n        if (this._isSplitButton && this._splitButtonContainer.current) {\n            setFocusVisibility(true, undefined, (_a = this.context) === null || _a === void 0 ? void 0 : _a.registeredProviders);\n            this._splitButtonContainer.current.focus();\n        }\n        else if (this._buttonElement.current) {\n            setFocusVisibility(true, undefined, (_b = this.context) === null || _b === void 0 ? void 0 : _b.registeredProviders);\n            this._buttonElement.current.focus();\n        }\n    };\n    BaseButton.prototype.dismissMenu = function () {\n        this._dismissMenu();\n    };\n    BaseButton.prototype.openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n        this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n    };\n    BaseButton.prototype._onRenderContent = function (tag, buttonProps) {\n        var _a, _b, _c, _d, _e;\n        var _this = this;\n        var props = this.props;\n        var Tag = tag;\n        var menuIconProps = props.menuIconProps, menuProps = props.menuProps, onRenderIcon = (_a = props.onRenderIcon, _a === void 0 ? this._onRenderIcon : _a), onRenderAriaDescription = (_b = props.onRenderAriaDescription, _b === void 0 ? this._onRenderAriaDescription : _b), onRenderChildren = (_c = props.onRenderChildren, _c === void 0 ? this._onRenderChildren : _c), \n        // eslint-disable-next-line deprecation/deprecation\n        onRenderMenu = (_d = props.onRenderMenu, _d === void 0 ? this._onRenderMenu : _d), onRenderMenuIcon = (_e = props.onRenderMenuIcon, _e === void 0 ? this._onRenderMenuIcon : _e), disabled = props.disabled;\n        var keytipProps = props.keytipProps;\n        if (keytipProps && menuProps) {\n            keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n        }\n        var Button = function (keytipAttributes) { return (React.createElement(Tag, __assign({}, buttonProps, keytipAttributes),\n            React.createElement(\"span\", { className: _this._classNames.flexContainer, \"data-automationid\": \"splitbuttonprimary\" },\n                onRenderIcon(props, _this._onRenderIcon),\n                _this._onRenderTextContents(),\n                onRenderAriaDescription(props, _this._onRenderAriaDescription),\n                onRenderChildren(props, _this._onRenderChildren),\n                !_this._isSplitButton &&\n                    (menuProps || menuIconProps || _this.props.onRenderMenuIcon) &&\n                    onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),\n                menuProps &&\n                    !menuProps.doNotLayer &&\n                    _this._shouldRenderMenu() &&\n                    onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)))); };\n        var Content = keytipProps ? (\n        // If we're making a split button, we won't put the keytip here\n        React.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : undefined, ariaDescribedBy: buttonProps['aria-describedby'], disabled: disabled }, function (keytipAttributes) { return Button(keytipAttributes); })) : (Button());\n        if (menuProps && menuProps.doNotLayer) {\n            return (React.createElement(React.Fragment, null,\n                Content,\n                this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)));\n        }\n        return (React.createElement(React.Fragment, null,\n            Content,\n            React.createElement(FocusRects, null)));\n    };\n    /**\n     * Method to help determine if the menu's component tree should\n     * be rendered. It takes into account whether the menu is expanded,\n     * whether it is a persisted menu and whether it has been shown to the user.\n     */\n    BaseButton.prototype._shouldRenderMenu = function () {\n        var _a;\n        var menuHidden = this.state.menuHidden;\n        // eslint-disable-next-line deprecation/deprecation\n        var persistMenu = (_a = this.props, _a.persistMenu), renderPersistedMenuHiddenOnMount = _a.renderPersistedMenuHiddenOnMount;\n        if (!menuHidden) {\n            // Always should render a menu when it is expanded\n            return true;\n        }\n        else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {\n            // _renderedVisibleMenu ensures that the first rendering of\n            // the menu happens on-screen, as edge's scrollbar calculations are off if done while hidden.\n            return true;\n        }\n        return false;\n    };\n    BaseButton.prototype._hasText = function () {\n        // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText\n        // used to have before the refactor that introduced this function. _onRenderTextContents does not require props.\n        // text to be undefined in order for props.children to be used as a fallback.\n        // Purely a code maintainability/reuse issue, but logged as Issue #4979.\n        return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n    };\n    BaseButton.prototype._getMenuProps = function (menuProps) {\n        var persistMenu = this.props.persistMenu;\n        var menuHidden = this.state.menuHidden;\n        // the accessible menu label (accessible name) has a relationship to the button.\n        // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n        // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n        if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {\n            menuProps = __assign(__assign({}, menuProps), { labelElementId: this._labelId });\n        }\n        return __assign(__assign({ id: this._labelId + '-menu', directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : undefined, className: css('ms-BaseButton-menuhost', menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });\n    };\n    BaseButton.prototype._onRenderSplitButtonContent = function (tag, buttonProps) {\n        var _a, _b;\n        var _this = this;\n        var styles = (_a = this.props, _b = _a.styles, _b === void 0 ? {} : _b), disabled = _a.disabled, allowDisabledFocus = _a.allowDisabledFocus, checked = _a.checked, getSplitButtonClassNames = _a.getSplitButtonClassNames, primaryDisabled = _a.primaryDisabled, menuProps = _a.menuProps, toggle = _a.toggle, role = _a.role, primaryActionButtonProps = _a.primaryActionButtonProps;\n        var keytipProps = this.props.keytipProps;\n        var menuHidden = this.state.menuHidden;\n        var classNames = getSplitButtonClassNames\n            ? getSplitButtonClassNames(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus)\n            : styles && getBaseSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);\n        assign(buttonProps, {\n            onClick: undefined,\n            onPointerDown: undefined,\n            onPointerUp: undefined,\n            tabIndex: -1,\n            'data-is-focusable': false,\n        });\n        if (keytipProps && menuProps) {\n            keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n        }\n        var containerProps = getNativeProps(buttonProps, [], ['disabled']);\n        // Add additional props to apply on primary action button\n        if (primaryActionButtonProps) {\n            assign(buttonProps, primaryActionButtonProps);\n        }\n        var SplitButton = function (keytipAttributes) { return (React.createElement(\"div\", __assign({}, containerProps, { \"data-ktp-target\": keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined, role: role ? role : 'button', \"aria-disabled\": disabled, \"aria-haspopup\": true, \"aria-expanded\": !menuHidden, \"aria-pressed\": toggle ? !!checked : undefined, \"aria-describedby\": mergeAriaAttributeValues(buttonProps['aria-describedby'], keytipAttributes ? keytipAttributes['aria-describedby'] : undefined), className: classNames && classNames.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, \"data-is-focusable\": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : undefined, tabIndex: (!disabled && !primaryDisabled) || allowDisabledFocus ? 0 : undefined, \"aria-roledescription\": buttonProps['aria-roledescription'], onFocusCapture: _this._onSplitContainerFocusCapture }),\n            React.createElement(\"span\", { style: { display: 'flex', width: '100%' } },\n                _this._onRenderContent(tag, buttonProps),\n                _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes),\n                _this._onRenderSplitButtonDivider(classNames)))); };\n        return keytipProps ? (React.createElement(KeytipData, { keytipProps: keytipProps, disabled: disabled }, function (keytipAttributes) { return SplitButton(keytipAttributes); })) : (SplitButton());\n    };\n    BaseButton.prototype._onRenderSplitButtonDivider = function (classNames) {\n        if (classNames && classNames.divider) {\n            var onClick = function (ev) {\n                ev.stopPropagation();\n            };\n            return React.createElement(\"span\", { className: classNames.divider, \"aria-hidden\": true, onClick: onClick });\n        }\n        return null;\n    };\n    BaseButton.prototype._onRenderSplitButtonMenuButton = function (classNames, keytipAttributes) {\n        var _a;\n        var allowDisabledFocus = (_a = this.props, _a.allowDisabledFocus), checked = _a.checked, disabled = _a.disabled, splitButtonMenuProps = _a.splitButtonMenuProps, splitButtonAriaLabel = _a.splitButtonAriaLabel, primaryDisabled = _a.primaryDisabled;\n        var menuHidden = this.state.menuHidden;\n        var menuIconProps = this.props.menuIconProps;\n        if (menuIconProps === undefined) {\n            menuIconProps = {\n                iconName: 'ChevronDown',\n            };\n        }\n        var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), { styles: classNames, checked: checked, disabled: disabled, allowDisabledFocus: allowDisabledFocus, onClick: this._onMenuClick, menuProps: undefined, iconProps: __assign(__assign({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, 'aria-haspopup': true, 'aria-expanded': !menuHidden, 'data-is-focusable': false });\n        // Add data-ktp-execute-target to the split button if the keytip is defined\n        return (React.createElement(BaseButton, __assign({}, splitButtonProps, { \"data-ktp-execute-target\": keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 })));\n    };\n    BaseButton.prototype._onPointerDown = function (ev) {\n        var onPointerDown = this.props.onPointerDown;\n        if (onPointerDown) {\n            onPointerDown(ev);\n        }\n        if (ev.pointerType === 'touch') {\n            this._handleTouchAndPointerEvent();\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n        }\n    };\n    BaseButton.prototype._handleTouchAndPointerEvent = function () {\n        var _this = this;\n        // If we already have an existing timeout from a previous touch and pointer event\n        // cancel that timeout so we can set a new one.\n        if (this._lastTouchTimeoutId !== undefined) {\n            this._async.clearTimeout(this._lastTouchTimeoutId);\n            this._lastTouchTimeoutId = undefined;\n        }\n        this._processingTouch = true;\n        this._lastTouchTimeoutId = this._async.setTimeout(function () {\n            _this._processingTouch = false;\n            _this._lastTouchTimeoutId = undefined;\n            // Touch and pointer events don't focus the button naturally,\n            // so adding an imperative focus call to guarantee this behavior.\n            // Only focus the button if a splitbutton menu is not open\n            if (_this.state.menuHidden) {\n                _this.focus();\n            }\n        }, TouchIdleDelay);\n    };\n    /**\n     * Returns if the user hits a valid keyboard key to open the menu\n     * @param ev - the keyboard event\n     * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n     */\n    BaseButton.prototype._isValidMenuOpenKey = function (ev) {\n        if (this.props.menuTriggerKeyCode) {\n            // eslint-disable-next-line deprecation/deprecation\n            return ev.which === this.props.menuTriggerKeyCode;\n        }\n        else if (this.props.menuProps) {\n            // eslint-disable-next-line deprecation/deprecation\n            return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n        }\n        // Note: When enter is pressed, we will let the event continue to propagate\n        // to trigger the onClick event on the button\n        return false;\n    };\n    BaseButton.defaultProps = {\n        baseClassName: 'ms-Button',\n        styles: {},\n        split: false,\n    };\n    // needed to access registeredProviders when manually setting focus visibility\n    BaseButton.contextType = FocusRectsContext;\n    return BaseButton;\n}(React.Component));\n//# sourceMappingURL=BaseButton.js.map"],"names":["TouchIdleDelay","COMPONENT_NAME","BaseButton","_super","__extends","props","_this","React","createMergedRef","memoizeFunction","keytipProps","__assign","buttonProps","defaultRender","iconProps","className","imageProps","rest","__rest","Icon","css","FontIcon","ImageIcon","_a","_b","_c","_d","text","children","secondaryText","onRenderText","onRenderDescription","ariaDescription","menuIconProps","menuProps","MenuType","composeComponentAs","ContextualMenu","ev","shouldFocusOnContainer","shouldFocusOnMount","container","portalContainsElement","singleTouchTarget","KeyCodes","isUp","isDown","onMenuClick","setFocusVisibility","currentShouldFocusOnMount","initializeComponentRef","Async","EventGroup","warnConditionallyRequiredProps","warnDeprecations","getId","_e","ariaLabel","ariaHidden","disabled","allowDisabledFocus","primaryDisabled","href","styles","checked","variantClassName","theme","toggle","getClassNames","role","menuHidden","isPrimaryButtonDisabled","getBaseButtonClassNames","_ariaDescriptionId","_labelId","_descriptionId","renderAsAnchor","tag","nativeProps","getNativeProps","assign","anchorProperties","buttonProperties","resolvedAriaLabel","ariaDescribedBy","nullRender","ariaLabelledBy","dataIsFocusable","isCheckboxTypeRole","checkedOrPressedValue","id","prevProps","prevState","Tag","onRenderIcon","onRenderAriaDescription","onRenderChildren","onRenderMenu","onRenderMenuIcon","Button","keytipAttributes","Content","KeytipData","FocusRects","persistMenu","renderPersistedMenuHiddenOnMount","DirectionalHint","getSplitButtonClassNames","primaryActionButtonProps","classNames","getBaseSplitButtonClassNames","containerProps","SplitButton","mergeAriaAttributeValues","onClick","splitButtonMenuProps","splitButtonAriaLabel","splitButtonProps","onPointerDown","FocusRectsContext"],"mappings":"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","x_google_ignoreList":[0]}