import { __extends as Z, __rest as ee, __assign as l } from "../../../../../tslib/tslib.es6.js";
import * as p from "react";
import { DirectionalHint as ne } from "../../common/DirectionalHint.js";
import { getBaseButtonClassNames as te } from "./BaseButton.classNames.js";
import { getSplitButtonClassNames as oe } from "./SplitButton/SplitButton.classNames.js";
import { createMergedRef as ie } from "../../../../utilities/lib/createMergedRef.js";
import { memoizeFunction as re } from "../../../../utilities/lib/memoize.js";
import { css as k } from "../../../../utilities/lib/css.js";
import { FontIcon as V } from "../Icon/FontIcon.js";
import { ImageIcon as se } from "../Icon/ImageIcon.js";
import { composeComponentAs as ae } from "../../../../utilities/lib/componentAs/composeComponentAs.js";
import { ContextualMenu as z } from "../ContextualMenu/ContextualMenu.js";
import { portalContainsElement as pe } from "../../../../dom-utilities/lib/portalContainsElement.js";
import { KeyCodes as P } from "../../../../utilities/lib/KeyCodes.js";
import { setFocusVisibility as K } from "../../../../utilities/lib/setFocusVisibility.js";
import { initializeComponentRef as ue } from "../../../../utilities/lib/initializeComponentRef.js";
import { Async as de } from "../../../../utilities/lib/Async.js";
import { EventGroup as le } from "../../../../utilities/lib/EventGroup.js";
import { warnConditionallyRequiredProps as ce } from "../../../../utilities/lib/warn/warnConditionallyRequiredProps.js";
import { warnDeprecations as me } from "../../../../utilities/lib/warn/warnDeprecations.js";
import { getId as F } from "../../../../utilities/lib/getId.js";
import { getNativeProps as j, anchorProperties as fe, buttonProperties as he } from "../../../../utilities/lib/properties.js";
import { assign as w } from "../../../../utilities/lib/object.js";
import { nullRender as _e } from "../../../../utilities/lib/BaseComponent.js";
import { FocusRects as ye, FocusRectsContext as be } from "../../../../utilities/lib/useFocusRects.js";
import { mergeAriaAttributeValues as Me } from "../../../../utilities/lib/aria.js";
import { Icon as Pe } from "../Icon/Icon.js";
import { KeytipData as q } from "../KeytipData/KeytipData.js";
var ve = 500, G = "BaseButton", Je = (
  /** @class */
  /* @__PURE__ */ function(H) {
    Z(u, H);
    function u(t) {
      var e = H.call(this, t) || this;
      return e._buttonElement = p.createRef(), e._splitButtonContainer = p.createRef(), e._mergedRef = ie(), e._renderedVisibleMenu = !1, e._getMemoizedMenuButtonKeytipProps = re(function(n) {
        return l(l({}, n), { hasMenu: !0 });
      }), e._onRenderIcon = function(n, o) {
        var i = e.props.iconProps;
        if (i && (i.iconName !== void 0 || i.imageProps)) {
          var s = i.className, a = i.imageProps, r = ee(i, ["className", "imageProps"]);
          if (i.styles)
            return p.createElement(Pe, l({ className: k(e._classNames.icon, s), imageProps: a }, r));
          if (i.iconName)
            return p.createElement(V, l({ className: k(e._classNames.icon, s) }, r));
          if (a)
            return p.createElement(se, l({ className: k(e._classNames.icon, s), imageProps: a }, r));
        }
        return null;
      }, e._onRenderTextContents = function() {
        var n, o, i, s, a = (n = e.props, n.text), r = n.children, d = (o = n.secondaryText, o === void 0 ? e.props.description : o), h = (i = n.onRenderText, i === void 0 ? e._onRenderText : i), c = (s = n.onRenderDescription, s === void 0 ? e._onRenderDescription : s);
        return a || typeof r == "string" || d ? p.createElement(
          "span",
          { className: e._classNames.textContainer },
          h(e.props, e._onRenderText),
          c(e.props, e._onRenderDescription)
        ) : [h(e.props, e._onRenderText), c(e.props, e._onRenderDescription)];
      }, e._onRenderText = function() {
        var n = e.props.text, o = e.props.children;
        return n === void 0 && typeof o == "string" && (n = o), e._hasText() ? p.createElement("span", { key: e._labelId, className: e._classNames.label, id: e._labelId }, n) : null;
      }, e._onRenderChildren = function() {
        var n = e.props.children;
        return typeof n == "string" ? null : n;
      }, e._onRenderDescription = function(n) {
        var o, i = (o = n.secondaryText, o === void 0 ? e.props.description : o);
        return i ? p.createElement("span", { key: e._descriptionId, className: e._classNames.description, id: e._descriptionId }, i) : null;
      }, e._onRenderAriaDescription = function() {
        var n = e.props.ariaDescription;
        return n ? p.createElement("span", { className: e._classNames.screenReaderText, id: e._ariaDescriptionId }, n) : null;
      }, e._onRenderMenuIcon = function(n) {
        var o = e.props.menuIconProps;
        return p.createElement(V, l({ iconName: "ChevronDown" }, o, { className: e._classNames.menuIcon }));
      }, e._onRenderMenu = function(n) {
        var o = e.props.menuAs ? ae(e.props.menuAs, z) : z;
        return p.createElement(o, l({}, n));
      }, e._onDismissMenu = function(n) {
        var o = e.props.menuProps;
        o && o.onDismiss && o.onDismiss(n), (!n || !n.defaultPrevented) && e._dismissMenu();
      }, e._dismissMenu = function() {
        e._menuShouldFocusOnMount = void 0, e._menuShouldFocusOnContainer = void 0, e.setState({ menuHidden: !0 });
      }, e._openMenu = function(n, o) {
        o === void 0 && (o = !0), e.props.menuProps && (e._menuShouldFocusOnContainer = n, e._menuShouldFocusOnMount = o, e._renderedVisibleMenu = !0, e.setState({ menuHidden: !1 }));
      }, e._onToggleMenu = function(n) {
        var o = !0;
        e.props.menuProps && e.props.menuProps.shouldFocusOnMount === !1 && (o = !1), e.state.menuHidden ? e._openMenu(n, o) : e._dismissMenu();
      }, e._onSplitContainerFocusCapture = function(n) {
        var o = e._splitButtonContainer.current;
        !o || n.target && pe(n.target, o) || o.focus();
      }, e._onSplitButtonPrimaryClick = function(n) {
        e.state.menuHidden || e._dismissMenu();
        var o = e._processingTouch && !e.props.toggle;
        !o && e.props.onClick ? e.props.onClick(n) : o && e._onMenuClick(n);
      }, e._onKeyDown = function(n) {
        e.props.disabled && (n.which === P.enter || n.which === P.space) ? (n.preventDefault(), n.stopPropagation()) : e.props.disabled || (e.props.menuProps ? e._onMenuKeyDown(n) : e.props.onKeyDown !== void 0 && e.props.onKeyDown(n));
      }, e._onKeyUp = function(n) {
        !e.props.disabled && e.props.onKeyUp !== void 0 && e.props.onKeyUp(n);
      }, e._onKeyPress = function(n) {
        !e.props.disabled && e.props.onKeyPress !== void 0 && e.props.onKeyPress(n);
      }, e._onMouseUp = function(n) {
        !e.props.disabled && e.props.onMouseUp !== void 0 && e.props.onMouseUp(n);
      }, e._onMouseDown = function(n) {
        !e.props.disabled && e.props.onMouseDown !== void 0 && e.props.onMouseDown(n);
      }, e._onClick = function(n) {
        e.props.disabled || (e.props.menuProps ? e._onMenuClick(n) : e.props.onClick !== void 0 && e.props.onClick(n));
      }, e._onSplitButtonContainerKeyDown = function(n) {
        n.which === P.enter || n.which === P.space ? e._buttonElement.current && (e._buttonElement.current.click(), n.preventDefault(), n.stopPropagation()) : e._onMenuKeyDown(n);
      }, e._onMenuKeyDown = function(n) {
        var o;
        if (!e.props.disabled) {
          e.props.onKeyDown && e.props.onKeyDown(n);
          var i = n.which === P.up, s = n.which === P.down;
          if (!n.defaultPrevented && e._isValidMenuOpenKey(n)) {
            var a = e.props.onMenuClick;
            a && a(n, e.props), e._onToggleMenu(!1), n.preventDefault(), n.stopPropagation();
          }
          if ((n.which === P.enter || n.which === P.space) && K(!0, n.target, (o = e.context) === null || o === void 0 ? void 0 : o.registeredProviders), !(n.altKey || n.metaKey) && (i || s) && !e.state.menuHidden && e.props.menuProps) {
            var r = e._menuShouldFocusOnMount !== void 0 ? e._menuShouldFocusOnMount : e.props.menuProps.shouldFocusOnMount;
            r || (n.preventDefault(), n.stopPropagation(), e._menuShouldFocusOnMount = !0, e.forceUpdate());
          }
        }
      }, e._onTouchStart = function() {
        e._isSplitButton && e._splitButtonContainer.current && !("onpointerdown" in e._splitButtonContainer.current) && e._handleTouchAndPointerEvent();
      }, e._onMenuClick = function(n) {
        var o, i = (o = e.props, o.onMenuClick), s = o.menuProps;
        i && i(n, e.props);
        var a = typeof (s == null ? void 0 : s.shouldFocusOnContainer) == "boolean" ? s.shouldFocusOnContainer : n.nativeEvent.pointerType === "mouse";
        n.defaultPrevented || (e._onToggleMenu(a), n.preventDefault(), n.stopPropagation());
      }, ue(e), e._async = new de(e), e._events = new le(e), ce(G, t, ["menuProps", "onClick"], "split", e.props.split), me(G, t, {
        rootProps: void 0,
        description: "secondaryText",
        toggled: "checked"
      }), e._labelId = F(), e._descriptionId = F(), e._ariaDescriptionId = F(), e.state = {
        menuHidden: !0
      }, e;
    }
    return Object.defineProperty(u.prototype, "_isSplitButton", {
      get: function() {
        return !!this.props.menuProps && !!this.props.onClick && this.props.split === !0;
      },
      enumerable: !1,
      configurable: !0
    }), u.prototype.render = function() {
      var t, e, n, o, i, s = (t = this.props, t.ariaDescription), a = t.ariaLabel, r = t.ariaHidden, d = t.className, h = t.disabled, c = t.allowDisabledFocus, m = t.primaryDisabled, B = (e = t.secondaryText, e === void 0 ? this.props.description : e), D = t.href, M = t.iconProps, f = t.menuIconProps, C = t.styles, y = t.checked, b = t.variantClassName, v = t.theme, _ = t.toggle, g = t.getClassNames, O = t.role, N = this.state.menuHidden, I = h || m;
      this._classNames = g ? g(v, d, b, M && M.className, f && f.className, I, y, !N, !!this.props.menuProps, this.props.split, !!c) : te(v, C, d, b, M && M.className, f && f.className, I, !!this.props.menuProps, y, !N, this.props.split);
      var W = (n = this, n._ariaDescriptionId), $ = n._labelId, J = n._descriptionId, S = !I && !!D, A = S ? "a" : "button", R = j(
        // eslint-disable-next-line deprecation/deprecation
        w(S ? {} : { type: "button" }, this.props.rootProps, this.props),
        S ? fe : he,
        [
          "disabled"
          // let disabled buttons be focused and styled as disabled.
        ]
      ), U = a || R["aria-label"], T = void 0;
      s ? T = W : B && this.props.onRenderDescription !== _e ? T = J : R["aria-describedby"] && (T = R["aria-describedby"]);
      var E = void 0;
      R["aria-labelledby"] ? E = R["aria-labelledby"] : T && !U && (E = this._hasText() ? $ : void 0);
      var Q = !(this.props["data-is-focusable"] === !1 || h && !c || this._isSplitButton), L = O === "menuitemcheckbox" || O === "checkbox", X = L || _ === !0 ? !!y : void 0, x = w(R, (o = {
        className: this._classNames.root,
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._buttonElement),
        disabled: I && !c,
        onKeyDown: this._onKeyDown,
        onKeyPress: this._onKeyPress,
        onKeyUp: this._onKeyUp,
        onMouseDown: this._onMouseDown,
        onMouseUp: this._onMouseUp,
        onClick: this._onClick,
        "aria-label": U,
        "aria-labelledby": E,
        "aria-describedby": T,
        "aria-disabled": I,
        "data-is-focusable": Q
      }, // aria-pressed attribute should only be present for toggle buttons
      // aria-checked attribute should only be present for toggle buttons with checkbox type role
      o[L ? "aria-checked" : "aria-pressed"] = X, o));
      if (r && (x["aria-hidden"] = !0), this._isSplitButton)
        return this._onRenderSplitButtonContent(A, x);
      if (this.props.menuProps) {
        var Y = (i = this.props.menuProps.id, i === void 0 ? "".concat(this._labelId, "-menu") : i);
        w(x, {
          "aria-expanded": !N,
          "aria-controls": N ? null : Y,
          "aria-haspopup": !0
        });
      }
      return this._onRenderContent(A, x);
    }, u.prototype.componentDidMount = function() {
      this._isSplitButton && this._splitButtonContainer.current && ("onpointerdown" in this._splitButtonContainer.current && this._events.on(this._splitButtonContainer.current, "pointerdown", this._onPointerDown, !0), "onpointerup" in this._splitButtonContainer.current && this.props.onPointerUp && this._events.on(this._splitButtonContainer.current, "pointerup", this.props.onPointerUp, !0));
    }, u.prototype.componentDidUpdate = function(t, e) {
      this.props.onAfterMenuDismiss && !e.menuHidden && this.state.menuHidden && this.props.onAfterMenuDismiss();
    }, u.prototype.componentWillUnmount = function() {
      this._async.dispose(), this._events.dispose();
    }, u.prototype.focus = function() {
      var t, e;
      this._isSplitButton && this._splitButtonContainer.current ? (K(!0, void 0, (t = this.context) === null || t === void 0 ? void 0 : t.registeredProviders), this._splitButtonContainer.current.focus()) : this._buttonElement.current && (K(!0, void 0, (e = this.context) === null || e === void 0 ? void 0 : e.registeredProviders), this._buttonElement.current.focus());
    }, u.prototype.dismissMenu = function() {
      this._dismissMenu();
    }, u.prototype.openMenu = function(t, e) {
      this._openMenu(t, e);
    }, u.prototype._onRenderContent = function(t, e) {
      var n, o, i, s, a, r = this, d = this.props, h = t, c = d.menuIconProps, m = d.menuProps, B = (n = d.onRenderIcon, n === void 0 ? this._onRenderIcon : n), D = (o = d.onRenderAriaDescription, o === void 0 ? this._onRenderAriaDescription : o), M = (i = d.onRenderChildren, i === void 0 ? this._onRenderChildren : i), f = (s = d.onRenderMenu, s === void 0 ? this._onRenderMenu : s), C = (a = d.onRenderMenuIcon, a === void 0 ? this._onRenderMenuIcon : a), y = d.disabled, b = d.keytipProps;
      b && m && (b = this._getMemoizedMenuButtonKeytipProps(b));
      var v = function(g) {
        return p.createElement(
          h,
          l({}, e, g),
          p.createElement(
            "span",
            { className: r._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
            B(d, r._onRenderIcon),
            r._onRenderTextContents(),
            D(d, r._onRenderAriaDescription),
            M(d, r._onRenderChildren),
            !r._isSplitButton && (m || c || r.props.onRenderMenuIcon) && C(r.props, r._onRenderMenuIcon),
            m && !m.doNotLayer && r._shouldRenderMenu() && f(r._getMenuProps(m), r._onRenderMenu)
          )
        );
      }, _ = b ? (
        // If we're making a split button, we won't put the keytip here
        p.createElement(q, { keytipProps: this._isSplitButton ? void 0 : b, ariaDescribedBy: e["aria-describedby"], disabled: y }, function(g) {
          return v(g);
        })
      ) : v();
      return m && m.doNotLayer ? p.createElement(
        p.Fragment,
        null,
        _,
        this._shouldRenderMenu() && f(this._getMenuProps(m), this._onRenderMenu)
      ) : p.createElement(
        p.Fragment,
        null,
        _,
        p.createElement(ye, null)
      );
    }, u.prototype._shouldRenderMenu = function() {
      var t, e = this.state.menuHidden, n = (t = this.props, t.persistMenu), o = t.renderPersistedMenuHiddenOnMount;
      if (e) {
        if (n && (this._renderedVisibleMenu || o))
          return !0;
      } else return !0;
      return !1;
    }, u.prototype._hasText = function() {
      return this.props.text !== null && (this.props.text !== void 0 || typeof this.props.children == "string");
    }, u.prototype._getMenuProps = function(t) {
      var e = this.props.persistMenu, n = this.state.menuHidden;
      return !t.ariaLabel && !t.labelElementId && this._hasText() && (t = l(l({}, t), { labelElementId: this._labelId })), l(l({ id: this._labelId + "-menu", directionalHint: ne.bottomLeftEdge }, t), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: e ? n : void 0, className: k("ms-BaseButton-menuhost", t.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
    }, u.prototype._onRenderSplitButtonContent = function(t, e) {
      var n, o, i = this, s = (n = this.props, o = n.styles, o === void 0 ? {} : o), a = n.disabled, r = n.allowDisabledFocus, d = n.checked, h = n.getSplitButtonClassNames, c = n.primaryDisabled, m = n.menuProps, B = n.toggle, D = n.role, M = n.primaryActionButtonProps, f = this.props.keytipProps, C = this.state.menuHidden, y = h ? h(!!a, !C, !!d, !!r) : s && oe(s, !!a, !C, !!d, !!c);
      w(e, {
        onClick: void 0,
        onPointerDown: void 0,
        onPointerUp: void 0,
        tabIndex: -1,
        "data-is-focusable": !1
      }), f && m && (f = this._getMemoizedMenuButtonKeytipProps(f));
      var b = j(e, [], ["disabled"]);
      M && w(e, M);
      var v = function(_) {
        return p.createElement(
          "div",
          l({}, b, { "data-ktp-target": _ ? _["data-ktp-target"] : void 0, role: D || "button", "aria-disabled": a, "aria-haspopup": !0, "aria-expanded": !C, "aria-pressed": B ? !!d : void 0, "aria-describedby": Me(e["aria-describedby"], _ ? _["aria-describedby"] : void 0), className: y && y.splitButtonContainer, onKeyDown: i._onSplitButtonContainerKeyDown, onTouchStart: i._onTouchStart, ref: i._splitButtonContainer, "data-is-focusable": !0, onClick: !a && !c ? i._onSplitButtonPrimaryClick : void 0, tabIndex: !a && !c || r ? 0 : void 0, "aria-roledescription": e["aria-roledescription"], onFocusCapture: i._onSplitContainerFocusCapture }),
          p.createElement(
            "span",
            { style: { display: "flex", width: "100%" } },
            i._onRenderContent(t, e),
            i._onRenderSplitButtonMenuButton(y, _),
            i._onRenderSplitButtonDivider(y)
          )
        );
      };
      return f ? p.createElement(q, { keytipProps: f, disabled: a }, function(_) {
        return v(_);
      }) : v();
    }, u.prototype._onRenderSplitButtonDivider = function(t) {
      if (t && t.divider) {
        var e = function(n) {
          n.stopPropagation();
        };
        return p.createElement("span", { className: t.divider, "aria-hidden": !0, onClick: e });
      }
      return null;
    }, u.prototype._onRenderSplitButtonMenuButton = function(t, e) {
      var n, o = (n = this.props, n.allowDisabledFocus), i = n.checked, s = n.disabled, a = n.splitButtonMenuProps, r = n.splitButtonAriaLabel, d = n.primaryDisabled, h = this.state.menuHidden, c = this.props.menuIconProps;
      c === void 0 && (c = {
        iconName: "ChevronDown"
      });
      var m = l(l({}, a), { styles: t, checked: i, disabled: s, allowDisabledFocus: o, onClick: this._onMenuClick, menuProps: void 0, iconProps: l(l({}, c), { className: this._classNames.menuIcon }), ariaLabel: r, "aria-haspopup": !0, "aria-expanded": !h, "data-is-focusable": !1 });
      return p.createElement(u, l({}, m, { "data-ktp-execute-target": e && e["data-ktp-execute-target"], onMouseDown: this._onMouseDown, tabIndex: d && !o ? 0 : -1 }));
    }, u.prototype._onPointerDown = function(t) {
      var e = this.props.onPointerDown;
      e && e(t), t.pointerType === "touch" && (this._handleTouchAndPointerEvent(), t.preventDefault(), t.stopImmediatePropagation());
    }, u.prototype._handleTouchAndPointerEvent = function() {
      var t = this;
      this._lastTouchTimeoutId !== void 0 && (this._async.clearTimeout(this._lastTouchTimeoutId), this._lastTouchTimeoutId = void 0), this._processingTouch = !0, this._lastTouchTimeoutId = this._async.setTimeout(function() {
        t._processingTouch = !1, t._lastTouchTimeoutId = void 0, t.state.menuHidden && t.focus();
      }, ve);
    }, u.prototype._isValidMenuOpenKey = function(t) {
      return this.props.menuTriggerKeyCode ? t.which === this.props.menuTriggerKeyCode : this.props.menuProps ? t.which === P.down && (t.altKey || t.metaKey) : !1;
    }, u.defaultProps = {
      baseClassName: "ms-Button",
      styles: {},
      split: !1
    }, u.contextType = be, u;
  }(p.Component)
);
export {
  Je as BaseButton
};
//# sourceMappingURL=BaseButton.js.map
