import { __extends as g, __assign as s } from "../../../../../../tslib/tslib.es6.js";
import * as m from "react";
import { ContextualMenuItem as y } from "../ContextualMenuItem.js";
import { getSplitButtonVerticalDividerClassNames as B } from "../ContextualMenu.classNames.js";
import { ContextualMenuItemWrapper as E } from "./ContextualMenuItemWrapper.js";
import { memoizeFunction as S } from "../../../../../utilities/lib/memoize.js";
import { KeyCodes as w } from "../../../../../utilities/lib/KeyCodes.js";
import { Async as A } from "../../../../../utilities/lib/Async.js";
import { EventGroup as K } from "../../../../../utilities/lib/EventGroup.js";
import { getId as C } from "../../../../../utilities/lib/getId.js";
import { mergeAriaAttributeValues as N } from "../../../../../utilities/lib/aria.js";
import { getNativeProps as k, buttonProperties as P } from "../../../../../utilities/lib/properties.js";
import { VerticalDivider as L } from "../../Divider/VerticalDivider.js";
import { composeComponentAs as x } from "../../../../../utilities/lib/componentAs/composeComponentAs.js";
import { hasSubmenu as R, getIsChecked as z, isItemDisabled as h, getMenuItemAriaRole as V } from "../../../utilities/contextualMenu/contextualMenuUtility.js";
import { KeytipData as W } from "../../KeytipData/KeytipData.js";
var F = 500, oe = (
  /** @class */
  /* @__PURE__ */ function(b) {
    g(p, b);
    function p(n) {
      var e = b.call(this, n) || this;
      return e._getMemoizedMenuButtonKeytipProps = S(function(t) {
        return s(s({}, t), { hasMenu: !0 });
      }), e._onItemKeyDown = function(t) {
        var o = e.props, i = o.item, r = o.onItemKeyDown;
        t.which === w.enter ? (e._executeItemClick(t), t.preventDefault(), t.stopPropagation()) : r && r(i, t);
      }, e._getSubmenuTarget = function() {
        return e._splitButton;
      }, e._renderAriaDescription = function(t, o) {
        return t ? m.createElement("span", { id: e._ariaDescriptionId, className: o }, t) : null;
      }, e._onItemMouseEnterPrimary = function(t) {
        var o = e.props, i = o.item, r = o.onItemMouseEnter;
        r && r(s(s({}, i), { subMenuProps: void 0, items: void 0 }), t, e._splitButton);
      }, e._onItemMouseEnterIcon = function(t) {
        var o = e.props, i = o.item, r = o.onItemMouseEnter;
        r && r(i, t, e._splitButton);
      }, e._onItemMouseMovePrimary = function(t) {
        var o = e.props, i = o.item, r = o.onItemMouseMove;
        r && r(s(s({}, i), { subMenuProps: void 0, items: void 0 }), t, e._splitButton);
      }, e._onItemMouseMoveIcon = function(t) {
        var o = e.props, i = o.item, r = o.onItemMouseMove;
        r && r(i, t, e._splitButton);
      }, e._onIconItemClick = function(t) {
        var o = e.props, i = o.item, r = o.onItemClickBase;
        r && r(i, t, e._splitButton ? e._splitButton : t.currentTarget);
      }, e._executeItemClick = function(t) {
        var o = e.props, i = o.item, r = o.executeItemClick, a = o.onItemClick;
        if (!(i.disabled || i.isDisabled)) {
          if (e._processingTouch && !i.canCheck && a)
            return a(i, t);
          r && r(i, t);
        }
      }, e._onTouchStart = function(t) {
        e._splitButton && !("onpointerdown" in e._splitButton) && e._handleTouchAndPointerEvent(t);
      }, e._onPointerDown = function(t) {
        t.pointerType === "touch" && (e._handleTouchAndPointerEvent(t), t.preventDefault(), t.stopImmediatePropagation());
      }, e._async = new A(e), e._events = new K(e), e._dismissLabelId = C(), e;
    }
    return p.prototype.componentDidMount = function() {
      this._splitButton && "onpointerdown" in this._splitButton && this._events.on(this._splitButton, "pointerdown", this._onPointerDown, !0);
    }, p.prototype.componentWillUnmount = function() {
      this._async.dispose(), this._events.dispose();
    }, p.prototype.render = function() {
      var n = this, e, t = this.props, o = t.item, i = t.classNames, r = t.index, a = t.focusableElementIndex, f = t.totalItemCount, c = t.hasCheckmarks, d = t.hasIcons, u = t.onItemMouseLeave, _ = t.expandedMenuItemKey, M = R(o), l = o.keytipProps;
      l && (l = this._getMemoizedMenuButtonKeytipProps(l));
      var I = o.ariaDescription;
      I && (this._ariaDescriptionId = C());
      var T = (e = z(o)) !== null && e !== void 0 ? e : void 0;
      return m.createElement(W, { keytipProps: l, disabled: h(o) }, function(v) {
        return m.createElement(
          "div",
          { "data-ktp-target": v["data-ktp-target"], ref: function(D) {
            return n._splitButton = D;
          }, role: V(o), "aria-label": o.ariaLabel, className: i.splitContainer, "aria-disabled": h(o), "aria-expanded": M ? o.key === _ : void 0, "aria-haspopup": !0, "aria-describedby": N(o.ariaDescribedBy, I ? n._ariaDescriptionId : void 0, v["aria-describedby"]), "aria-checked": T, "aria-posinset": a + 1, "aria-setsize": f, onMouseEnter: n._onItemMouseEnterPrimary, onMouseLeave: u ? u.bind(n, s(s({}, o), { subMenuProps: null, items: null })) : void 0, onMouseMove: n._onItemMouseMovePrimary, onKeyDown: n._onItemKeyDown, onClick: n._executeItemClick, onTouchStart: n._onTouchStart, tabIndex: 0, "data-is-focusable": !0, "aria-roledescription": o["aria-roledescription"] },
          n._renderSplitPrimaryButton(o, i, r, c, d),
          n._renderSplitDivider(o),
          n._renderSplitIconButton(o, i, r, v),
          n._renderAriaDescription(I, i.screenReaderText)
        );
      });
    }, p.prototype._renderSplitPrimaryButton = function(n, e, t, o, i) {
      var r = this.props, a = r.contextualMenuItemAs, f = a === void 0 ? y : a, c = r.onItemClick, d = {
        key: n.key,
        disabled: h(n) || n.primaryDisabled,
        /* eslint-disable deprecation/deprecation */
        name: n.name,
        text: n.text || n.name,
        secondaryText: n.secondaryText,
        /* eslint-enable deprecation/deprecation */
        className: e.splitPrimary,
        canCheck: n.canCheck,
        isChecked: n.isChecked,
        checked: n.checked,
        iconProps: n.iconProps,
        id: this._dismissLabelId,
        onClick: n.onClick,
        onRenderIcon: n.onRenderIcon,
        data: n.data,
        "data-is-focusable": !1
      }, u = n.itemProps;
      return m.createElement(
        "button",
        s({}, k(d, P)),
        m.createElement(f, s({ "data-is-focusable": !1, item: d, classNames: e, index: t, onCheckmarkClick: o && c ? c : void 0, hasIcons: i }, u))
      );
    }, p.prototype._renderSplitDivider = function(n) {
      var e = n.getSplitButtonVerticalDividerClassNames || B;
      return m.createElement(L, { getClassNames: e });
    }, p.prototype._renderSplitIconButton = function(n, e, t, o) {
      var i = this.props, r = i.onItemMouseLeave, a = i.onItemMouseDown, f = i.openSubMenu, c = i.dismissSubMenu, d = i.dismissMenu, u = y;
      this.props.item.contextualMenuItemAs && (u = x(this.props.item.contextualMenuItemAs, u)), this.props.contextualMenuItemAs && (u = x(this.props.contextualMenuItemAs, u));
      var _ = {
        onClick: this._onIconItemClick,
        disabled: h(n),
        className: e.splitMenu,
        subMenuProps: n.subMenuProps,
        submenuIconProps: n.submenuIconProps,
        split: !0,
        key: n.key,
        "aria-labelledby": this._dismissLabelId
      }, M = s(s({}, k(_, P)), {
        onMouseEnter: this._onItemMouseEnterIcon,
        onMouseLeave: r ? r.bind(this, n) : void 0,
        onMouseDown: function(I) {
          return a ? a(n, I) : void 0;
        },
        onMouseMove: this._onItemMouseMoveIcon,
        "data-is-focusable": !1,
        "data-ktp-execute-target": o["data-ktp-execute-target"],
        "aria-haspopup": !0
      }), l = n.itemProps;
      return m.createElement(
        "button",
        s({}, M),
        m.createElement(u, s({ componentRef: n.componentRef, item: _, classNames: e, index: t, hasIcons: !1, openSubMenu: f, dismissSubMenu: c, dismissMenu: d, getSubmenuTarget: this._getSubmenuTarget }, l))
      );
    }, p.prototype._handleTouchAndPointerEvent = function(n) {
      var e = this, t = this.props.onTap;
      t && t(n), this._lastTouchTimeoutId && (this._async.clearTimeout(this._lastTouchTimeoutId), this._lastTouchTimeoutId = void 0), this._processingTouch = !0, this._lastTouchTimeoutId = this._async.setTimeout(function() {
        e._processingTouch = !1, e._lastTouchTimeoutId = void 0;
      }, F);
    }, p;
  }(E)
);
export {
  oe as ContextualMenuSplitButton
};
//# sourceMappingURL=ContextualMenuSplitButton.js.map
