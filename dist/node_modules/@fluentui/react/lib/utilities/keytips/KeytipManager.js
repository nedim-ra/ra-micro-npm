import { __spreadArray as a, __assign as u } from "../../../../../tslib/tslib.es6.js";
import { KeytipEvents as s } from "./KeytipConstants.js";
import { EventGroup as r } from "../../../../utilities/lib/EventGroup.js";
import { getId as y } from "../../../../utilities/lib/getId.js";
var E = (
  /** @class */
  /* @__PURE__ */ function() {
    function p() {
      this.keytips = {}, this.persistedKeytips = {}, this.sequenceMapping = {}, this.inKeytipMode = !1, this.shouldEnterKeytipMode = !0, this.delayUpdatingKeytipChange = !1;
    }
    return p.getInstance = function() {
      return this._instance;
    }, p.prototype.init = function(t) {
      this.delayUpdatingKeytipChange = t;
    }, p.prototype.register = function(t, e) {
      e === void 0 && (e = !1);
      var i = t;
      e || (i = this.addParentOverflow(t), this.sequenceMapping[i.keySequences.toString()] = i);
      var n = this._getUniqueKtp(i);
      if (e ? this.persistedKeytips[n.uniqueID] = n : this.keytips[n.uniqueID] = n, this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        var o = e ? s.PERSISTED_KEYTIP_ADDED : s.KEYTIP_ADDED;
        r.raise(this, o, {
          keytip: i,
          uniqueID: n.uniqueID
        });
      }
      return n.uniqueID;
    }, p.prototype.update = function(t, e) {
      var i = this.addParentOverflow(t), n = this._getUniqueKtp(i, e), o = this.keytips[e];
      o && (n.keytip.visible = o.keytip.visible, this.keytips[e] = n, delete this.sequenceMapping[o.keytip.keySequences.toString()], this.sequenceMapping[n.keytip.keySequences.toString()] = n.keytip, (this.inKeytipMode || !this.delayUpdatingKeytipChange) && r.raise(this, s.KEYTIP_UPDATED, {
        keytip: n.keytip,
        uniqueID: n.uniqueID
      }));
    }, p.prototype.unregister = function(t, e, i) {
      i === void 0 && (i = !1), i ? delete this.persistedKeytips[e] : delete this.keytips[e], !i && delete this.sequenceMapping[t.keySequences.toString()];
      var n = i ? s.PERSISTED_KEYTIP_REMOVED : s.KEYTIP_REMOVED;
      (this.inKeytipMode || !this.delayUpdatingKeytipChange) && r.raise(this, n, {
        keytip: t,
        uniqueID: e
      });
    }, p.prototype.enterKeytipMode = function() {
      r.raise(this, s.ENTER_KEYTIP_MODE);
    }, p.prototype.exitKeytipMode = function() {
      r.raise(this, s.EXIT_KEYTIP_MODE);
    }, p.prototype.getKeytips = function() {
      var t = this;
      return Object.keys(this.keytips).map(function(e) {
        return t.keytips[e].keytip;
      });
    }, p.prototype.addParentOverflow = function(t) {
      var e = a([], t.keySequences, !0);
      if (e.pop(), e.length !== 0) {
        var i = this.sequenceMapping[e.toString()];
        if (i && i.overflowSetSequence)
          return u(u({}, t), { overflowSetSequence: i.overflowSetSequence });
      }
      return t;
    }, p.prototype.menuExecute = function(t, e) {
      r.raise(this, s.PERSISTED_KEYTIP_EXECUTE, {
        overflowButtonSequences: t,
        keytipSequences: e
      });
    }, p.prototype._getUniqueKtp = function(t, e) {
      return e === void 0 && (e = y()), { keytip: u({}, t), uniqueID: e };
    }, p._instance = new p(), p;
  }()
);
export {
  E as KeytipManager
};
//# sourceMappingURL=KeytipManager.js.map
