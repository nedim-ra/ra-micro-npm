import { __assign as p } from "../../../../../tslib/tslib.es6.js";
import { DirectionalHint as h } from "../../common/DirectionalHint.js";
import { RectangleEdge as o } from "./positioning.types.js";
import { getWindow as j } from "../../../../utilities/lib/dom/getWindow.js";
import { Rectangle as R } from "../../../../utilities/lib/Rectangle.js";
import { getScrollbarWidth as J } from "../../../../utilities/lib/scroll.js";
import { getRTL as z } from "../../../../utilities/lib/rtl.js";
var c;
function s(e, t, n) {
  return {
    targetEdge: e,
    alignmentEdge: t,
    isAuto: n
  };
}
var X = (c = {}, c[h.topLeftEdge] = /* @__PURE__ */ s(o.top, o.left), c[h.topCenter] = /* @__PURE__ */ s(o.top), c[h.topRightEdge] = /* @__PURE__ */ s(o.top, o.right), c[h.topAutoEdge] = /* @__PURE__ */ s(o.top, void 0, !0), c[h.bottomLeftEdge] = /* @__PURE__ */ s(o.bottom, o.left), c[h.bottomCenter] = /* @__PURE__ */ s(o.bottom), c[h.bottomRightEdge] = /* @__PURE__ */ s(o.bottom, o.right), c[h.bottomAutoEdge] = /* @__PURE__ */ s(o.bottom, void 0, !0), c[h.leftTopEdge] = /* @__PURE__ */ s(o.left, o.top), c[h.leftCenter] = /* @__PURE__ */ s(o.left), c[h.leftBottomEdge] = /* @__PURE__ */ s(o.left, o.bottom), c[h.rightTopEdge] = /* @__PURE__ */ s(o.right, o.top), c[h.rightCenter] = /* @__PURE__ */ s(o.right), c[h.rightBottomEdge] = /* @__PURE__ */ s(o.right, o.bottom), c);
function W(e, t) {
  return !(e.top < t.top || e.bottom > t.bottom || e.left < t.left || e.right > t.right);
}
function V(e, t) {
  var n = [];
  return e.top < t.top && n.push(o.top), e.bottom > t.bottom && n.push(o.bottom), e.left < t.left && n.push(o.left), e.right > t.right && n.push(o.right), n;
}
function m(e, t) {
  return e[o[t]];
}
function Y(e, t, n) {
  return e[o[t]] = n, e;
}
function C(e, t) {
  var n = w(t);
  return (m(e, n.positiveEdge) + m(e, n.negativeEdge)) / 2;
}
function A(e, t) {
  return e > 0 ? t : t * -1;
}
function y(e, t) {
  return A(e, m(t, e));
}
function B(e, t, n) {
  var r = m(e, n) - m(t, n);
  return A(n, r);
}
function T(e, t, n, r) {
  r === void 0 && (r = !0);
  var i = m(e, t) - n, a = Y(e, t, n);
  return r && (a = Y(e, t * -1, m(e, t * -1) - i)), a;
}
function x(e, t, n, r) {
  return r === void 0 && (r = 0), T(e, n, m(t, n) + A(n, r));
}
function K(e, t, n, r) {
  r === void 0 && (r = 0);
  var i = n * -1, a = A(i, r);
  return T(e, n * -1, m(t, n) + a);
}
function I(e, t, n) {
  var r = y(n, e);
  return r > y(n, t);
}
function N(e, t) {
  for (var n = V(e, t), r = 0, i = 0, a = n; i < a.length; i++) {
    var l = a[i];
    r += Math.pow(B(e, t, l), 2);
  }
  return r;
}
function Q(e, t, n, r) {
  return r === void 0 && (r = 200), n !== o.bottom && n !== o.top ? !1 : B(e, t, n) >= r;
}
function U(e, t, n, r, i, a, l) {
  i === void 0 && (i = !1), l === void 0 && (l = 0);
  var g = [
    o.left,
    o.right,
    o.bottom,
    o.top
  ];
  z() && (g[0] *= -1, g[1] *= -1);
  for (var f = e, u = r.targetEdge, v = r.alignmentEdge, d, E = u, _ = v, b = 0; b < 4; b++) {
    if (I(f, n, u))
      return {
        elementRectangle: f,
        targetEdge: u,
        alignmentEdge: v
      };
    if (i && Q(t, n, u, a)) {
      switch (u) {
        case o.bottom:
          f.bottom = n.bottom;
          break;
        case o.top:
          f.top = n.top;
          break;
      }
      return {
        elementRectangle: f,
        targetEdge: u,
        alignmentEdge: v,
        forcedInBounds: !0
      };
    } else {
      var F = N(f, n);
      (!d || F < d) && (d = F, E = u, _ = v), g.splice(g.indexOf(u), 1), g.length > 0 && (g.indexOf(u * -1) > -1 ? u = u * -1 : (v = u, u = g.slice(-1)[0]), f = k(e, t, { targetEdge: u, alignmentEdge: v }, l));
    }
  }
  return f = k(e, t, { targetEdge: E, alignmentEdge: _ }, l), {
    elementRectangle: f,
    targetEdge: E,
    alignmentEdge: _
  };
}
function Z(e, t, n, r) {
  var i = e.alignmentEdge, a = e.targetEdge, l = e.elementRectangle, g = i * -1, f = k(l, t, { targetEdge: a, alignmentEdge: g }, n, r);
  return {
    elementRectangle: f,
    targetEdge: a,
    alignmentEdge: g
  };
}
function $(e, t, n, r, i, a, l, g, f) {
  i === void 0 && (i = !1), l === void 0 && (l = 0);
  var u = r.alignmentEdge, v = r.alignTargetEdge, d = {
    elementRectangle: e,
    targetEdge: r.targetEdge,
    alignmentEdge: u
  };
  !g && !f && (d = U(e, t, n, r, i, a, l));
  var E = V(d.elementRectangle, n), _ = g ? -d.targetEdge : void 0;
  if (E.length > 0)
    if (v)
      if (d.alignmentEdge && E.indexOf(d.alignmentEdge * -1) > -1) {
        var b = Z(d, t, l, f);
        if (W(b.elementRectangle, n))
          return b;
        d = O(V(b.elementRectangle, n), d, n, _);
      } else
        d = O(E, d, n, _);
    else
      d = O(E, d, n, _);
  return d;
}
function O(e, t, n, r) {
  for (var i = 0, a = e; i < a.length; i++) {
    var l = a[i], g = void 0;
    if (r && r === l * -1)
      g = T(t.elementRectangle, l, m(n, l), !1), t.forcedInBounds = !0;
    else {
      g = x(t.elementRectangle, n, l);
      var f = I(g, n, l * -1);
      f || (g = T(g, l * -1, m(n, l * -1), !1), t.forcedInBounds = !0);
    }
    t.elementRectangle = g;
  }
  return t;
}
function G(e, t, n) {
  var r = w(t).positiveEdge, i = C(e, t), a = i - m(e, r);
  return T(e, r, n - a);
}
function k(e, t, n, r, i) {
  r === void 0 && (r = 0);
  var a = new R(e.left, e.right, e.top, e.bottom), l = n.alignmentEdge, g = n.targetEdge, f = i ? g : g * -1;
  if (a = i ? x(a, t, g, r) : K(a, t, g, r), l)
    a = x(a, t, l);
  else {
    var u = C(t, g);
    a = G(a, f, u);
  }
  return a;
}
function w(e) {
  return e === o.top || e === o.bottom ? {
    positiveEdge: o.left,
    negativeEdge: o.right
  } : {
    positiveEdge: o.top,
    negativeEdge: o.bottom
  };
}
function L(e, t, n) {
  return n && Math.abs(B(e, n, t)) > Math.abs(B(e, n, t * -1)) ? t * -1 : t;
}
function P(e, t, n) {
  return n !== void 0 && m(e, t) === m(n, t);
}
function S(e, t, n, r, i, a, l, g) {
  var f = {}, u = M(t), v = a ? n : n * -1, d = i || w(n).positiveEdge;
  return (!l || P(e, ve(d), r)) && (d = L(e, d, r)), f[o[v]] = B(e, u, v), f[o[d]] = B(e, u, d), g && (f[o[v * -1]] = B(e, u, v * -1), f[o[d * -1]] = B(e, u, d * -1)), f;
}
function ee(e) {
  return Math.sqrt(e * e * 2);
}
function te(e, t, n) {
  if (e === void 0 && (e = h.bottomAutoEdge), n)
    return {
      alignmentEdge: n.alignmentEdge,
      isAuto: n.isAuto,
      targetEdge: n.targetEdge
    };
  var r = p({}, X[e]);
  return z() ? (r.alignmentEdge && r.alignmentEdge % 2 === 0 && (r.alignmentEdge = r.alignmentEdge * -1), t !== void 0 ? X[t] : r) : r;
}
function ne(e, t, n, r, i) {
  return e.isAuto && (e.alignmentEdge = q(e.targetEdge, t, n)), e.alignTargetEdge = i, e;
}
function q(e, t, n) {
  var r = C(t, e), i = C(n, e), a = w(e), l = a.positiveEdge, g = a.negativeEdge;
  return r <= i ? l : g;
}
function re(e, t, n, r, i, a, l, g, f) {
  a === void 0 && (a = !1);
  var u = k(e, t, r, i, f);
  return W(u, n) ? {
    elementRectangle: u,
    targetEdge: r.targetEdge,
    alignmentEdge: r.alignmentEdge
  } : $(u, t, n, r, a, l, i, g, f);
}
function ie(e, t, n) {
  var r = e.targetEdge * -1, i = new R(0, e.elementRectangle.width, 0, e.elementRectangle.height), a = {}, l = L(e.elementRectangle, e.alignmentEdge ? e.alignmentEdge : w(r).positiveEdge, n), g = B(e.elementRectangle, e.targetRectangle, r), f = g > Math.abs(m(t, r));
  return a[o[r]] = m(t, r), a[o[l]] = B(t, i, l), {
    elementPosition: p({}, a),
    closestEdge: q(e.targetEdge, t, i),
    targetEdge: r,
    hideBeak: !f
  };
}
function ae(e, t) {
  var n = t.targetRectangle, r = w(t.targetEdge), i = r.positiveEdge, a = r.negativeEdge, l = C(n, t.targetEdge), g = new R(e / 2, t.elementRectangle.width - e / 2, e / 2, t.elementRectangle.height - e / 2), f = new R(0, e, 0, e);
  return f = T(f, t.targetEdge * -1, -e / 2), f = G(f, t.targetEdge * -1, l - y(i, t.elementRectangle)), I(f, g, i) ? I(f, g, a) || (f = x(f, g, a)) : f = x(f, g, i), f;
}
function M(e) {
  var t = e.getBoundingClientRect();
  return new R(t.left, t.right, t.top, t.bottom);
}
function ge(e) {
  return new R(e.left, e.right, e.top, e.bottom);
}
function fe(e, t) {
  var n;
  if (t) {
    if (t.preventDefault) {
      var r = t;
      n = new R(r.clientX, r.clientX, r.clientY, r.clientY);
    } else if (t.getBoundingClientRect)
      n = M(t);
    else {
      var i = t, a = i.left || i.x, l = i.top || i.y, g = i.right || a, f = i.bottom || l;
      n = new R(a, g, l, f);
    }
    if (!W(n, e))
      for (var u = V(n, e), v = 0, d = u; v < d.length; v++) {
        var E = d[v];
        n[o[E]] = e[o[E]];
      }
  } else
    n = new R(0, 0, 0, 0);
  return n;
}
function oe(e, t, n, r, i, a) {
  i === void 0 && (i = !1);
  var l = e.gapSpace ? e.gapSpace : 0, g = fe(n, e.target), f = ne(te(e.directionalHint, e.directionalHintForRTL, r), g, n, e.coverTarget, e.alignTargetEdge), u = re(M(t), g, n, f, l, i, a, e.directionalHintFixed, e.coverTarget);
  return p(p({}, u), { targetRectangle: g });
}
function le(e, t, n, r, i) {
  var a = S(e.elementRectangle, t, e.targetEdge, n, e.alignmentEdge, r, i, e.forcedInBounds);
  return {
    elementPosition: a,
    targetEdge: e.targetEdge,
    alignmentEdge: e.alignmentEdge
  };
}
function D(e, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = 0), ee(e ? t : 0) / 2 + n;
}
function H(e, t, n, r, i, a, l, g) {
  i === void 0 && (i = !1);
  var f = g ?? j(), u = e.isBeakVisible && e.beakWidth || 0, v = D(e.isBeakVisible, e.beakWidth, e.gapSpace), d = e;
  d.gapSpace = v;
  var E = e.bounds ? ge(e.bounds) : new R(0, f.innerWidth - J(), 0, f.innerHeight), _ = oe(d, n, E, r, i, a), b = ae(u, _), F = ie(_, b, E);
  return p(p({}, le(_, t, E, e.coverTarget, l)), { beakPosition: F });
}
function ue(e, t, n, r, i) {
  var a = i ?? j();
  return H(e, t, n, r, !1, void 0, !0, a);
}
function de(e) {
  var t, n, r, i, a = e, l = e, g = e, f, u = (t = g.left) !== null && t !== void 0 ? t : g.x, v = (n = g.top) !== null && n !== void 0 ? n : g.y, d = (r = g.right) !== null && r !== void 0 ? r : u, E = (i = g.bottom) !== null && i !== void 0 ? i : v;
  return a.stopPropagation ? f = new R(a.clientX, a.clientX, a.clientY, a.clientY) : u !== void 0 && v !== void 0 ? f = new R(u, d, v, E) : f = M(l), f;
}
function be(e, t, n, r, i, a, l) {
  return H(e, t, n, r, i, a, void 0, l);
}
function pe(e, t, n, r, i) {
  return ue(e, t, n, r, i);
}
function ve(e) {
  return e * -1;
}
function Ee(e, t) {
  var n = void 0;
  if (t.getWindowSegments && (n = t.getWindowSegments()), n === void 0 || n.length <= 1)
    return {
      top: 0,
      left: 0,
      right: t.innerWidth,
      bottom: t.innerHeight,
      width: t.innerWidth,
      height: t.innerHeight
    };
  var r = 0, i = 0;
  if (e !== null && e.getBoundingClientRect) {
    var a = e.getBoundingClientRect();
    r = (a.left + a.right) / 2, i = (a.top + a.bottom) / 2;
  } else e !== null && (r = e.left || e.x, i = e.top || e.y);
  for (var l = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 }, g = 0, f = n; g < f.length; g++) {
    var u = f[g];
    r && u.left <= r && u.right >= r && i && u.top <= i && u.bottom >= i && (l = {
      top: u.top,
      left: u.left,
      right: u.right,
      bottom: u.bottom,
      width: u.width,
      height: u.height
    });
  }
  return l;
}
function Te(e, t) {
  return Ee(e, t);
}
function we(e, t, n) {
  return D(e, t, n);
}
function Ce(e) {
  return de(e);
}
export {
  we as calculateGapSpace,
  Te as getBoundsFromTargetWindow,
  ve as getOppositeEdge,
  Ce as getRectangleFromTarget,
  be as positionCallout,
  pe as positionCard
};
//# sourceMappingURL=positioning.js.map
