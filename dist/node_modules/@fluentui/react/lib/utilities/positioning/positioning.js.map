{"version":3,"file":"positioning.js","sources":["../../../../../../../node_modules/@fluentui/react/lib/utilities/positioning/positioning.js"],"sourcesContent":["var _a;\nimport { __assign } from \"tslib\";\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { getScrollbarWidth, getRTL, getWindow } from '../../Utilities';\nimport { RectangleEdge } from './positioning.types';\nimport { Rectangle } from '../../Utilities';\nfunction _createPositionData(targetEdge, alignmentEdge, isAuto) {\n    return {\n        targetEdge: targetEdge,\n        alignmentEdge: alignmentEdge,\n        isAuto: isAuto,\n    };\n}\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\nvar DirectionalDictionary = (_a = {},\n    _a[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left),\n    _a[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top),\n    _a[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right),\n    _a[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, undefined, true),\n    _a[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left),\n    _a[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom),\n    _a[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right),\n    _a[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, undefined, true),\n    _a[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top),\n    _a[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left),\n    _a[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom),\n    _a[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top),\n    _a[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right),\n    _a[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom),\n    _a);\nfunction _isRectangleWithinBounds(rect, boundingRect) {\n    if (rect.top < boundingRect.top) {\n        return false;\n    }\n    if (rect.bottom > boundingRect.bottom) {\n        return false;\n    }\n    if (rect.left < boundingRect.left) {\n        return false;\n    }\n    if (rect.right > boundingRect.right) {\n        return false;\n    }\n    return true;\n}\n/**\n * Gets all of the edges of a rectangle that are outside of the given bounds.\n * If there are no out of bounds edges it returns an empty array.\n */\nfunction _getOutOfBoundsEdges(rect, boundingRect) {\n    var outOfBounds = [];\n    if (rect.top < boundingRect.top) {\n        outOfBounds.push(RectangleEdge.top);\n    }\n    if (rect.bottom > boundingRect.bottom) {\n        outOfBounds.push(RectangleEdge.bottom);\n    }\n    if (rect.left < boundingRect.left) {\n        outOfBounds.push(RectangleEdge.left);\n    }\n    if (rect.right > boundingRect.right) {\n        outOfBounds.push(RectangleEdge.right);\n    }\n    return outOfBounds;\n}\nfunction _getEdgeValue(rect, edge) {\n    return rect[RectangleEdge[edge]];\n}\nfunction _setEdgeValue(rect, edge, value) {\n    rect[RectangleEdge[edge]] = value;\n    return rect;\n}\n/**\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\n * the itself already contains the other coordinate.\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\n */\nfunction _getCenterValue(rect, edge) {\n    var edges = _getFlankingEdges(edge);\n    return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\n}\n/**\n * Flips the value depending on the edge.\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\n * This is to account for the fact that the coordinates are effectively reserved in certain cases for the\n * \"negative\" edges.\n *\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2:\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\n * If top edge 1 is less than edge 2 then it is out of bounds.\n */\nfunction _getRelativeEdgeValue(edge, value) {\n    if (edge > 0) {\n        return value;\n    }\n    else {\n        return value * -1;\n    }\n}\nfunction _getRelativeRectEdgeValue(edge, rect) {\n    return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\n}\nfunction _getRelativeEdgeDifference(rect, hostRect, edge) {\n    var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\n    return _getRelativeEdgeValue(edge, edgeDifference);\n}\n/**\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\n * For example, if it's a bottom edge it will only change y coordinates.\n * if maintainSize is set to false, it will only adjust the specified edge value\n */\nfunction _moveEdge(rect, edge, newValue, maintainSize) {\n    if (maintainSize === void 0) { maintainSize = true; }\n    var difference = _getEdgeValue(rect, edge) - newValue;\n    var returnRect = _setEdgeValue(rect, edge, newValue);\n    if (maintainSize) {\n        returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\n    }\n    return returnRect;\n}\n/**\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\n */\nfunction _alignEdges(rect, target, edge, gap) {\n    if (gap === void 0) { gap = 0; }\n    return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\n}\n/**\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\n */\nfunction _alignOppositeEdges(rect, target, targetEdge, gap) {\n    if (gap === void 0) { gap = 0; }\n    var oppositeEdge = targetEdge * -1;\n    var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\n    return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\n}\n/**\n * Tests to see if the given edge is within the bounds of the given rectangle.\n */\nfunction _isEdgeInBounds(rect, bounds, edge) {\n    var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\n    return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\n}\n/**\n * Returns a measure of how much a rectangle is out of bounds for a given alignment;\n * this can be used to compare which rectangle is more or less out of bounds.\n * A value of 0 means the rectangle is entirely in bounds\n */\nfunction _getOutOfBoundsDegree(rect, bounds) {\n    var breakingEdges = _getOutOfBoundsEdges(rect, bounds);\n    var total = 0;\n    for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {\n        var edge = breakingEdges_1[_i];\n        total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);\n    }\n    return total;\n}\n/**\n * Returns true if scroll-resizing will move the target edge within the bounding rectangle,\n * and there is room between the target edge and the bounding edge for scrolled content.\n * Returns false otherwise.\n */\nfunction _canScrollResizeToFitEdge(target, bounding, targetEdge, minimumScrollResizeHeight) {\n    if (minimumScrollResizeHeight === void 0) { minimumScrollResizeHeight = 200; }\n    // Only scroll vertically to fit - cannot scroll to fit right or left edges\n    if (targetEdge !== RectangleEdge.bottom && targetEdge !== RectangleEdge.top) {\n        return false;\n    }\n    return _getRelativeEdgeDifference(target, bounding, targetEdge) >= minimumScrollResizeHeight;\n}\n/**\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\n * If no fit is found, the least bad option should be returned.\n */\nfunction _flipToFit(rect, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap) {\n    if (shouldScroll === void 0) { shouldScroll = false; }\n    if (gap === void 0) { gap = 0; }\n    var directions = [\n        RectangleEdge.left,\n        RectangleEdge.right,\n        RectangleEdge.bottom,\n        RectangleEdge.top,\n    ];\n    // In RTL page, RectangleEdge.right has a higher priority than RectangleEdge.left, so the order should be updated.\n    if (getRTL()) {\n        directions[0] *= -1;\n        directions[1] *= -1;\n    }\n    var currentEstimate = rect;\n    var currentEdge = positionData.targetEdge;\n    var currentAlignment = positionData.alignmentEdge;\n    // keep track of least bad option, in case no sides fit\n    var oobDegree;\n    var bestEdge = currentEdge;\n    var bestAlignment = currentAlignment;\n    // Keep switching sides until one is found with enough space.\n    // If all sides don't fit then return the unmodified element.\n    for (var i = 0; i < 4; i++) {\n        if (_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\n            // Edge is in bounds, return current estimate\n            return {\n                elementRectangle: currentEstimate,\n                targetEdge: currentEdge,\n                alignmentEdge: currentAlignment,\n            };\n        }\n        else if (shouldScroll && _canScrollResizeToFitEdge(target, bounding, currentEdge, minimumScrollResizeHeight)) {\n            // Scrolling will allow edge to fit, move the estimate currentEdge inside the bounds and return\n            switch (currentEdge) {\n                case RectangleEdge.bottom:\n                    currentEstimate.bottom = bounding.bottom;\n                    break;\n                case RectangleEdge.top:\n                    currentEstimate.top = bounding.top;\n                    break;\n            }\n            return {\n                elementRectangle: currentEstimate,\n                targetEdge: currentEdge,\n                alignmentEdge: currentAlignment,\n                forcedInBounds: true,\n            };\n        }\n        else {\n            // update least-bad edges\n            var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);\n            if (!oobDegree || currentOOBDegree < oobDegree) {\n                oobDegree = currentOOBDegree;\n                bestEdge = currentEdge;\n                bestAlignment = currentAlignment;\n            }\n            directions.splice(directions.indexOf(currentEdge), 1);\n            if (directions.length > 0) {\n                if (directions.indexOf(currentEdge * -1) > -1) {\n                    currentEdge = currentEdge * -1;\n                }\n                else {\n                    currentAlignment = currentEdge;\n                    currentEdge = directions.slice(-1)[0];\n                }\n                currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);\n            }\n        }\n    }\n    // nothing fits, use least-bad option\n    currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);\n    return {\n        elementRectangle: currentEstimate,\n        targetEdge: bestEdge,\n        alignmentEdge: bestAlignment,\n    };\n}\n/**\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges\n * into position, when `alignTargetEdge` is specified.\n */\nfunction _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {\n    var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;\n    var oppositeEdge = alignmentEdge * -1;\n    var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge: targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);\n    return {\n        elementRectangle: newEstimate,\n        targetEdge: targetEdge,\n        alignmentEdge: oppositeEdge,\n    };\n}\n/**\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\n */\nfunction _adjustFitWithinBounds(element, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap, directionalHintFixed, coverTarget) {\n    if (shouldScroll === void 0) { shouldScroll = false; }\n    if (gap === void 0) { gap = 0; }\n    var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;\n    var elementEstimate = {\n        elementRectangle: element,\n        targetEdge: positionData.targetEdge,\n        alignmentEdge: alignmentEdge,\n    };\n    if (!directionalHintFixed && !coverTarget) {\n        elementEstimate = _flipToFit(element, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap);\n    }\n    var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);\n    // if directionalHintFixed is specified, we need to force the target edge to not change\n    // we need *-1 because targetEdge refers to the target's edge; the callout edge is the opposite\n    var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : undefined;\n    if (outOfBounds.length > 0) {\n        if (alignTargetEdge) {\n            // The edge opposite to the alignment edge might be out of bounds.\n            // Flip alignment to see if we can get it within bounds.\n            if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\n                var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\n                if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\n                    return flippedElementEstimate;\n                }\n                else {\n                    // If the flipped elements edges are still out of bounds, try nudging it.\n                    elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);\n                }\n            }\n            else {\n                elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n            }\n        }\n        else {\n            elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);\n        }\n    }\n    return elementEstimate;\n}\n/**\n * Iterates through a list of out of bounds edges and tries to nudge and align them.\n * @param outOfBoundsEdges - Array of edges that are out of bounds\n * @param elementEstimate - The current element positioning estimate\n * @param bounding - The current bounds\n * @param preserveEdge - Specify an edge that should not be modified\n */\nfunction _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {\n    for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {\n        var direction = outOfBoundsEdges_1[_i];\n        var edgeAttempt = void 0;\n        // if preserveEdge is specified, do not call _alignEdges, skip directly to _moveEdge\n        // this is because _alignEdges will move the opposite edge\n        if (preserveEdge && preserveEdge === direction * -1) {\n            edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);\n            elementEstimate.forcedInBounds = true;\n        }\n        else {\n            edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\n            var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);\n            // only update estimate if the attempt didn't break out of the opposite bounding edge\n            if (!inBounds) {\n                edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);\n                elementEstimate.forcedInBounds = true;\n            }\n        }\n        elementEstimate.elementRectangle = edgeAttempt;\n    }\n    return elementEstimate;\n}\n/**\n * Moves the middle point on an edge to the point given.\n * Only moves in one direction. For instance if a bottom edge is passed in, then\n * the bottom edge will be moved in the x axis to match the point.\n */\nfunction _centerEdgeToPoint(rect, edge, point) {\n    var positiveEdge = _getFlankingEdges(edge).positiveEdge;\n    var elementMiddle = _getCenterValue(rect, edge);\n    var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\n    return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\n}\n/**\n * Moves the element rectangle to be appropriately positioned relative to a given target.\n * Does not flip or adjust the element.\n */\nfunction _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {\n    if (gap === void 0) { gap = 0; }\n    var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);\n    var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;\n    var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n    estimatedElementPosition = coverTarget\n        ? _alignEdges(estimatedElementPosition, target, targetEdge, gap)\n        : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);\n    // if no alignment edge is provided it's supposed to be centered.\n    if (!alignmentEdge) {\n        var targetMiddlePoint = _getCenterValue(target, targetEdge);\n        estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\n    }\n    else {\n        estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\n    }\n    return estimatedElementPosition;\n}\n/**\n * Returns the non-opposite edges of the target edge.\n * For instance if bottom is passed in then left and right will be returned.\n */\nfunction _getFlankingEdges(edge) {\n    if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\n        return {\n            positiveEdge: RectangleEdge.left,\n            negativeEdge: RectangleEdge.right,\n        };\n    }\n    else {\n        return {\n            positiveEdge: RectangleEdge.top,\n            negativeEdge: RectangleEdge.bottom,\n        };\n    }\n}\n/**\n * Retrieve the final value for the return edge of `elementRectangle`. If the `elementRectangle` is closer to one side\n * of the bounds versus the other, the return edge is flipped to grow inward.\n */\nfunction _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {\n    if (bounds &&\n        Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >\n            Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {\n        return returnEdge * -1;\n    }\n    return returnEdge;\n}\n/**\n * Whether or not the considered edge of the elementRectangle is lying on the edge of the bounds\n * @param elementRectangle The rectangle whose edge we are considering\n * @param bounds The rectangle marking the bounds\n * @param edge The target edge we're considering\n * @returns If the target edge of the elementRectangle is in the same location as that edge of the bounds\n */\nfunction _isEdgeOnBounds(elementRectangle, edge, bounds) {\n    return bounds !== undefined && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);\n}\n/**\n * Finalizes the element position based on the hostElement. Only returns the\n * rectangle values to position such that they are anchored to the target.\n * This helps prevent resizing from looking very strange.\n * For instance, if the target edge is top and aligned with the left side then\n * the bottom and left values are returned so as the Callout shrinks it shrinks towards that corner.\n */\nfunction _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {\n    var returnValue = {};\n    var hostRect = _getRectangleFromElement(hostElement);\n    var elementEdge = coverTarget ? targetEdge : targetEdge * -1;\n    var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;\n    // If we are finalizing the return edge, choose the edge such that we grow away from the bounds\n    // If we are not finalizing the return edge but the opposite edge is flush against the bounds,\n    // choose that as the anchor edge so the element rect can grow away from the bounds' edge\n    // In this case there will not be a visual difference because there is no more room for the elementRectangle to grow\n    // in the usual direction\n    if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {\n        returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);\n    }\n    returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\n    returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\n    // if the positioned element will still overflow, return all four edges with in-bounds values\n    if (forceWithinBounds) {\n        returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);\n        returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);\n    }\n    return returnValue;\n}\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\n// We still want to position the beak based on it's midpoint which does not change. It will\n// be at (beakwidth / 2, beakwidth / 2)\nfunction _calculateActualBeakWidthInPixels(beakWidth) {\n    return Math.sqrt(beakWidth * beakWidth * 2);\n}\n/**\n * Returns the appropriate IPositionData based on the props altered for RTL.\n * If directionalHintForRTL is passed in that is used if the page is RTL.\n * If directionalHint is specified, no directionalHintForRTL is available, and the page is RTL, the hint will be\n * flipped (e.g. bottomLeftEdge would become bottomRightEdge).\n *\n * If there is no directionalHint passed in, bottomAutoEdge is chosen automatically.\n */\nfunction _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {\n    if (directionalHint === void 0) { directionalHint = DirectionalHint.bottomAutoEdge; }\n    if (previousPositions) {\n        return {\n            alignmentEdge: previousPositions.alignmentEdge,\n            isAuto: previousPositions.isAuto,\n            targetEdge: previousPositions.targetEdge,\n        };\n    }\n    var positionInformation = __assign({}, DirectionalDictionary[directionalHint]);\n    if (getRTL()) {\n        // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\n        if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\n            positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\n        }\n        return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\n    }\n    return positionInformation;\n}\n/**\n * Gets the alignment data for the given information. This only really matters if the positioning is Auto.\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\n * the center of the page.\n */\nfunction _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {\n    if (positionData.isAuto) {\n        positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\n    }\n    positionData.alignTargetEdge = alignTargetEdge;\n    return positionData;\n}\nfunction getClosestEdge(targetEdge, target, boundingRect) {\n    var targetCenter = _getCenterValue(target, targetEdge);\n    var boundingCenter = _getCenterValue(boundingRect, targetEdge);\n    var _a = _getFlankingEdges(targetEdge), positiveEdge = _a.positiveEdge, negativeEdge = _a.negativeEdge;\n    if (targetCenter <= boundingCenter) {\n        return positiveEdge;\n    }\n    else {\n        return negativeEdge;\n    }\n}\nfunction _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, shouldScroll, minimumScrollResizeHeight, directionalHintFixed, coverTarget) {\n    if (shouldScroll === void 0) { shouldScroll = false; }\n    var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);\n    if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\n        return {\n            elementRectangle: estimatedElementPosition,\n            targetEdge: positionData.targetEdge,\n            alignmentEdge: positionData.alignmentEdge,\n        };\n    }\n    else {\n        return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, shouldScroll, minimumScrollResizeHeight, gap, directionalHintFixed, coverTarget);\n    }\n}\nfunction _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {\n    var targetEdge = elementPosition.targetEdge * -1;\n    // The \"host\" element that we will use to help position the beak.\n    var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);\n    var returnValue = {};\n    var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);\n    // only show the beak if the callout is not fully covering the target\n    var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);\n    var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));\n    returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\n    returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\n    return {\n        elementPosition: __assign({}, returnValue),\n        closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\n        targetEdge: targetEdge,\n        hideBeak: !showBeak,\n    };\n}\nfunction _positionBeak(beakWidth, elementPosition) {\n    var target = elementPosition.targetRectangle;\n    /**\n     * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\n     * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\n     * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\n     * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\n     */\n    var _a = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a.positiveEdge, negativeEdge = _a.negativeEdge;\n    var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\n    var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);\n    var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);\n    beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);\n    beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));\n    if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {\n        beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);\n    }\n    else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {\n        beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);\n    }\n    return beakPosition;\n}\nfunction _getRectangleFromElement(element) {\n    // eslint-disable-next-line deprecation/deprecation\n    var clientRect = element.getBoundingClientRect();\n    return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\n}\nfunction _getRectangleFromIRect(rect) {\n    return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\n}\nfunction _getTargetRect(bounds, target) {\n    var targetRectangle;\n    if (target) {\n        // eslint-disable-next-line no-extra-boolean-cast\n        if (!!target.preventDefault) {\n            var ev = target;\n            targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\n            // eslint-disable-next-line no-extra-boolean-cast\n        }\n        else if (!!target.getBoundingClientRect) {\n            targetRectangle = _getRectangleFromElement(target);\n            // HTMLImgElements can have x and y values. The check for it being a point must go last.\n        }\n        else {\n            var rectOrPoint = target;\n            // eslint-disable-next-line deprecation/deprecation\n            var left = rectOrPoint.left || rectOrPoint.x;\n            // eslint-disable-next-line deprecation/deprecation\n            var top_1 = rectOrPoint.top || rectOrPoint.y;\n            var right = rectOrPoint.right || left;\n            var bottom = rectOrPoint.bottom || top_1;\n            targetRectangle = new Rectangle(left, right, top_1, bottom);\n        }\n        if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\n            var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);\n            for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {\n                var direction = outOfBounds_1[_i];\n                targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];\n            }\n        }\n    }\n    else {\n        targetRectangle = new Rectangle(0, 0, 0, 0);\n    }\n    return targetRectangle;\n}\n/**\n * If max height is less than zero it returns the bounds height instead.\n */\nfunction _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds, coverTarget) {\n    var maxHeight = 0;\n    var directionalHint = DirectionalDictionary[targetEdge];\n    // If cover target is set, then the max height should be calculated using the opposite of the target edge since\n    // that's the direction that the callout will expand in.\n    // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\n    // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\n    // is (bottom of target) - (top of screen) - gapSpace.\n    var target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\n    if (target === RectangleEdge.top) {\n        maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\n    }\n    else if (target === RectangleEdge.bottom) {\n        maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\n    }\n    else {\n        maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\n    }\n    return maxHeight > 0 ? maxHeight : bounds.height;\n}\nfunction _positionElementRelative(props, elementToPosition, boundingRect, previousPositions, shouldScroll, minimumScrollResizeHeight) {\n    if (shouldScroll === void 0) { shouldScroll = false; }\n    var gap = props.gapSpace ? props.gapSpace : 0;\n    var targetRect = _getTargetRect(boundingRect, props.target);\n    var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);\n    var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, shouldScroll, minimumScrollResizeHeight, props.directionalHintFixed, props.coverTarget);\n    return __assign(__assign({}, positionedElement), { targetRectangle: targetRect });\n}\nfunction _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {\n    var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);\n    return {\n        elementPosition: finalizedElement,\n        targetEdge: positionedElement.targetEdge,\n        alignmentEdge: positionedElement.alignmentEdge,\n    };\n}\nfunction _positionElement(props, hostElement, elementToPosition, previousPositions, win) {\n    var theWin = win !== null && win !== void 0 ? win : getWindow();\n    var boundingRect = props.bounds\n        ? _getRectangleFromIRect(props.bounds)\n        : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n    var positionedElement = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);\n    return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\n}\nfunction _calculateGapSpace(isBeakVisible, beakWidth, gapSpace) {\n    if (beakWidth === void 0) { beakWidth = 0; }\n    if (gapSpace === void 0) { gapSpace = 0; }\n    return _calculateActualBeakWidthInPixels(isBeakVisible ? beakWidth : 0) / 2 + gapSpace;\n}\nfunction _positionCallout(props, hostElement, callout, previousPositions, shouldScroll, minimumScrollResizeHeight, doNotFinalizeReturnEdge, win) {\n    if (shouldScroll === void 0) { shouldScroll = false; }\n    var theWin = win !== null && win !== void 0 ? win : getWindow();\n    var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;\n    var gap = _calculateGapSpace(props.isBeakVisible, props.beakWidth, props.gapSpace);\n    var positionProps = props;\n    positionProps.gapSpace = gap;\n    var boundingRect = props.bounds\n        ? _getRectangleFromIRect(props.bounds)\n        : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n    var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions, shouldScroll, minimumScrollResizeHeight);\n    var beakPositioned = _positionBeak(beakWidth, positionedElement);\n    var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);\n    return __assign(__assign({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });\n}\nfunction _positionCard(props, hostElement, callout, previousPositions, win) {\n    var theWin = win !== null && win !== void 0 ? win : getWindow();\n    return _positionCallout(props, hostElement, callout, previousPositions, false, undefined, true, theWin);\n}\nfunction _getRectangleFromTarget(target) {\n    var _a, _b, _c, _d;\n    var mouseTarget = target;\n    var elementTarget = target;\n    var rectOrPointTarget = target;\n    var targetRect;\n    // eslint-disable-next-line deprecation/deprecation\n    var left = (_a = rectOrPointTarget.left) !== null && _a !== void 0 ? _a : rectOrPointTarget.x;\n    // eslint-disable-next-line deprecation/deprecation\n    var top = (_b = rectOrPointTarget.top) !== null && _b !== void 0 ? _b : rectOrPointTarget.y;\n    var right = (_c = rectOrPointTarget.right) !== null && _c !== void 0 ? _c : left;\n    var bottom = (_d = rectOrPointTarget.bottom) !== null && _d !== void 0 ? _d : top;\n    // eslint-disable-next-line no-extra-boolean-cast -- may not actually be a MouseEvent\n    if (!!mouseTarget.stopPropagation) {\n        targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\n    }\n    else if (left !== undefined && top !== undefined) {\n        targetRect = new Rectangle(left, right, top, bottom);\n    }\n    else {\n        targetRect = _getRectangleFromElement(elementTarget);\n    }\n    return targetRect;\n}\n// END PRIVATE FUNCTIONS\nexport var __positioningTestPackage = {\n    _finalizePositionData: _finalizePositionData,\n    _finalizeBeakPosition: _finalizeBeakPosition,\n    _calculateActualBeakWidthInPixels: _calculateActualBeakWidthInPixels,\n    _positionElementWithinBounds: _positionElementWithinBounds,\n    _positionBeak: _positionBeak,\n    _getPositionData: _getPositionData,\n    _getMaxHeightFromTargetRectangle: _getMaxHeightFromTargetRectangle,\n};\n/**\n * Used to position an element relative to the given positioning props.\n * If positioning has been completed before, previousPositions can be passed to ensure that the positioning element\n * repositions based on its previous targets rather than starting with directionalhint.\n */\nexport function positionElement(props, hostElement, elementToPosition, previousPositions, win) {\n    return _positionElement(props, hostElement, elementToPosition, previousPositions, win);\n}\nexport function positionCallout(props, hostElement, elementToPosition, previousPositions, shouldScroll, minimumScrollResizeHeight, win) {\n    return _positionCallout(props, hostElement, elementToPosition, previousPositions, shouldScroll, minimumScrollResizeHeight, undefined, win);\n}\nexport function positionCard(props, hostElement, elementToPosition, previousPositions, win) {\n    return _positionCard(props, hostElement, elementToPosition, previousPositions, win);\n}\n/**\n * Gets the maximum height that a rectangle can have in order to fit below or above a target.\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\n * of the target given.\n * If no bounds are provided then the window is treated as the bounds.\n */\nexport function getMaxHeight(target, targetEdge, gapSpace, bounds, coverTarget, win) {\n    if (gapSpace === void 0) { gapSpace = 0; }\n    var theWin = win !== null && win !== void 0 ? win : getWindow();\n    var targetRect = _getRectangleFromTarget(target);\n    var boundingRectangle = bounds\n        ? _getRectangleFromIRect(bounds)\n        : new Rectangle(0, theWin.innerWidth - getScrollbarWidth(), 0, theWin.innerHeight);\n    return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\n}\n/**\n * Returns the opposite edge of the given RectangleEdge.\n */\nexport function getOppositeEdge(edge) {\n    return edge * -1;\n}\nfunction _getBoundsFromTargetWindow(target, targetWindow) {\n    var segments = undefined;\n    if (targetWindow.getWindowSegments) {\n        segments = targetWindow.getWindowSegments();\n    }\n    // Identify if we're dealing with single screen scenarios.\n    if (segments === undefined || segments.length <= 1) {\n        return {\n            top: 0,\n            left: 0,\n            right: targetWindow.innerWidth,\n            bottom: targetWindow.innerHeight,\n            width: targetWindow.innerWidth,\n            height: targetWindow.innerHeight,\n        };\n    }\n    // Logic for determining dual screen scenarios.\n    var x = 0;\n    var y = 0;\n    // If the target is an Element get coordinates for its center.\n    if (target !== null && !!target.getBoundingClientRect) {\n        var clientRect = target.getBoundingClientRect();\n        x = (clientRect.left + clientRect.right) / 2;\n        y = (clientRect.top + clientRect.bottom) / 2;\n    }\n    // If the target is not null get x-axis and y-axis coordinates directly.\n    else if (target !== null) {\n        // eslint-disable-next-line deprecation/deprecation\n        x = target.left || target.x;\n        // eslint-disable-next-line deprecation/deprecation\n        y = target.top || target.y;\n    }\n    var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };\n    // Define which window segment are the coordinates in and calculate bounds based on that.\n    for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n        var segment = segments_1[_i];\n        if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {\n            bounds = {\n                top: segment.top,\n                left: segment.left,\n                right: segment.right,\n                bottom: segment.bottom,\n                width: segment.width,\n                height: segment.height,\n            };\n        }\n    }\n    return bounds;\n}\nexport function getBoundsFromTargetWindow(target, targetWindow) {\n    return _getBoundsFromTargetWindow(target, targetWindow);\n}\nexport function calculateGapSpace(isBeakVisible, beakWidth, gapSpace) {\n    return _calculateGapSpace(isBeakVisible, beakWidth, gapSpace);\n}\nexport function getRectangleFromTarget(target) {\n    return _getRectangleFromTarget(target);\n}\n//# sourceMappingURL=positioning.js.map"],"names":["_a","_createPositionData","targetEdge","alignmentEdge","isAuto","DirectionalDictionary","DirectionalHint","RectangleEdge","_isRectangleWithinBounds","rect","boundingRect","_getOutOfBoundsEdges","outOfBounds","_getEdgeValue","edge","_setEdgeValue","value","_getCenterValue","edges","_getFlankingEdges","_getRelativeEdgeValue","_getRelativeRectEdgeValue","_getRelativeEdgeDifference","hostRect","edgeDifference","_moveEdge","newValue","maintainSize","difference","returnRect","_alignEdges","target","gap","_alignOppositeEdges","oppositeEdge","adjustedGap","_isEdgeInBounds","bounds","adjustedRectValue","_getOutOfBoundsDegree","breakingEdges","total","_i","breakingEdges_1","_canScrollResizeToFitEdge","bounding","minimumScrollResizeHeight","_flipToFit","positionData","shouldScroll","directions","getRTL","currentEstimate","currentEdge","currentAlignment","oobDegree","bestEdge","bestAlignment","i","currentOOBDegree","_estimatePosition","_flipAlignmentEdge","elementEstimate","coverTarget","elementRectangle","newEstimate","_adjustFitWithinBounds","element","directionalHintFixed","alignTargetEdge","fixedEdge","flippedElementEstimate","_alignOutOfBoundsEdges","outOfBoundsEdges","preserveEdge","outOfBoundsEdges_1","direction","edgeAttempt","inBounds","_centerEdgeToPoint","point","positiveEdge","elementMiddle","distanceToMiddle","elementToPosition","estimatedElementPosition","Rectangle","elementEdge","targetMiddlePoint","_finalizeReturnEdge","returnEdge","_isEdgeOnBounds","_finalizeElementPosition","hostElement","doNotFinalizeReturnEdge","forceWithinBounds","returnValue","_getRectangleFromElement","getOppositeEdge","_calculateActualBeakWidthInPixels","beakWidth","_getPositionData","directionalHint","directionalHintForRTL","previousPositions","positionInformation","__assign","_getAlignmentData","getClosestEdge","targetCenter","boundingCenter","negativeEdge","_positionElementWithinBounds","_finalizeBeakPosition","elementPosition","positionedBeak","actualElement","beakEdgeDifference","showBeak","_positionBeak","beakTargetPoint","elementBounds","beakPosition","clientRect","_getRectangleFromIRect","_getTargetRect","targetRectangle","ev","rectOrPoint","left","top_1","right","bottom","outOfBounds_1","_positionElementRelative","props","targetRect","positionedElement","_finalizePositionData","finalizedElement","_calculateGapSpace","isBeakVisible","gapSpace","_positionCallout","callout","win","theWin","getWindow","positionProps","getScrollbarWidth","beakPositioned","finalizedBeakPosition","_positionCard","_getRectangleFromTarget","_b","_c","_d","mouseTarget","elementTarget","rectOrPointTarget","top","positionCallout","positionCard","_getBoundsFromTargetWindow","targetWindow","segments","x","y","segments_1","segment","getBoundsFromTargetWindow","calculateGapSpace","getRectangleFromTarget"],"mappings":"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","x_google_ignoreList":[0]}