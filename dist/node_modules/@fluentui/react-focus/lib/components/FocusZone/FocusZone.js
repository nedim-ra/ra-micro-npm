import { __extends as V, __assign as G } from "../../../../../tslib/tslib.es6.js";
import * as L from "react";
import { FocusZoneTabbableElements as H, FocusZoneDirection as E } from "./FocusZone.types.js";
import "../../../../style-utilities/lib/index.js";
import { createMergedRef as j } from "../../../../utilities/lib/createMergedRef.js";
import { isElementTabbable as k, isElementFocusZone as T, isElementFocusSubZone as q, getNextElement as I, getPreviousElement as D, getFocusableByIndexPath as X, isElementVisibleAndNotHidden as Y, getElementIndexPath as J, shouldWrapFocus as Q } from "../../../../utilities/lib/focus.js";
import { getParent as C } from "../../../../dom-utilities/lib/getParent.js";
import { KeyCodes as m } from "../../../../utilities/lib/KeyCodes.js";
import { getRTL as x } from "../../../../utilities/lib/rtl.js";
import { initializeComponentRef as $ } from "../../../../utilities/lib/initializeComponentRef.js";
import { warnDeprecations as tt } from "../../../../utilities/lib/warn/warnDeprecations.js";
import { getId as et } from "../../../../utilities/lib/getId.js";
import { elementContains as N } from "../../../../dom-utilities/lib/elementContains.js";
import { getNativeProps as rt, htmlElementProperties as ot } from "../../../../utilities/lib/properties.js";
import { getTheme as it } from "../../../../style-utilities/lib/styles/theme.js";
import { css as nt } from "../../../../utilities/lib/css.js";
import { findScrollableParent as st } from "../../../../utilities/lib/scroll.js";
import { portalContainsElement as at } from "../../../../dom-utilities/lib/portalContainsElement.js";
import { getDocument as ut } from "../../../../utilities/lib/dom/getDocument.js";
import { MergeStylesShadowRootContext as lt } from "../../../../utilities/lib/shadowDom/contexts/MergeStylesShadowRootContext.js";
import { mergeStyles as ft } from "../../../../merge-styles/lib/mergeStyles.js";
var P = "data-is-focusable", ct = "data-disable-click-on-enter", B = "data-focuszone-id", g = "tabindex", M = "data-no-vertical-wrap", S = "data-no-horizontal-wrap", W = 999999999, K = -999999999, U, ht = "ms-FocusZone";
function _t(O, o) {
  var e;
  typeof MouseEvent == "function" ? e = new MouseEvent("click", {
    ctrlKey: o == null ? void 0 : o.ctrlKey,
    metaKey: o == null ? void 0 : o.metaKey,
    shiftKey: o == null ? void 0 : o.shiftKey,
    altKey: o == null ? void 0 : o.altKey,
    bubbles: o == null ? void 0 : o.bubbles,
    cancelable: o == null ? void 0 : o.cancelable
  }) : (e = document.createEvent("MouseEvents"), e.initMouseEvent(
    "click",
    o ? o.bubbles : !1,
    o ? o.cancelable : !1,
    // eslint-disable-next-line no-restricted-globals
    window,
    // not using getWindow() since this can only be run client side
    0,
    // detail
    0,
    // screen x
    0,
    // screen y
    0,
    // client x
    0,
    // client y
    o ? o.ctrlKey : !1,
    o ? o.altKey : !1,
    o ? o.shiftKey : !1,
    o ? o.metaKey : !1,
    0,
    // button
    null
  )), O.dispatchEvent(e);
}
function dt() {
  return U || (U = ft({
    selectors: {
      ":focus": {
        outline: "none"
      }
    }
  }, ht)), U;
}
var R = {}, Z = /* @__PURE__ */ new Set(), pt = ["text", "number", "password", "email", "tel", "url", "search", "textarea"], y = !1, Zt = (
  /** @class */
  /* @__PURE__ */ function(O) {
    V(o, O);
    function o(e) {
      var t = this, r, i, n, a;
      t = O.call(this, e) || this, t._root = L.createRef(), t._mergedRef = j(), t._onFocus = function(s) {
        var f;
        if (!t._portalContainsElement(s.target)) {
          var u = (f = t.props, f.onActiveElementChanged), c = f.doNotAllowFocusEventToPropagate, h = f.stopFocusPropagation, F = f.onFocusNotification, v = f.onFocus, A = f.shouldFocusInnerElementWhenReceivedFocus, _ = f.defaultTabbableElement, b = t._isImmediateDescendantOfZone(s.target), p;
          if (b)
            p = s.target;
          else
            for (var d = s.target; d && d !== t._root.current; ) {
              if (k(d, void 0, t._inShadowRoot) && t._isImmediateDescendantOfZone(d)) {
                p = d;
                break;
              }
              d = C(d, y);
            }
          if (A && s.target === t._root.current) {
            var w = _ && typeof _ == "function" && t._root.current && _(t._root.current);
            w && k(w, void 0, t._inShadowRoot) ? (p = w, w.focus()) : (t.focus(!0), t._activeElement && (p = null));
          }
          var z = !t._activeElement;
          p && p !== t._activeElement && ((b || z) && t._setFocusAlignment(p, !0, !0), t._activeElement = p, z && t._updateTabIndexes()), u && u(t._activeElement, s), (h || c) && s.stopPropagation(), v ? v(s) : F && F();
        }
      }, t._onBlur = function() {
        t._setParkedFocus(!1);
      }, t._onMouseDown = function(s) {
        if (!t._portalContainsElement(s.target)) {
          var f = t.props.disabled;
          if (!f) {
            for (var u = s.target, c = []; u && u !== t._root.current; )
              c.push(u), u = C(u, y);
            for (; c.length && (u = c.pop(), u && k(u, void 0, t._inShadowRoot) && t._setActiveElement(u, !0), !T(u)); )
              ;
          }
        }
      }, t._onKeyDown = function(s, f) {
        var u;
        if (!t._portalContainsElement(s.target)) {
          var c = (u = t.props, u.direction), h = u.disabled, F = u.isInnerZoneKeystroke, v = u.pagingSupportDisabled, A = u.shouldEnterInnerZone;
          if (!h && (t.props.onKeyDown && t.props.onKeyDown(s), !s.isDefaultPrevented() && !(t._getDocument().activeElement === t._root.current && t._isInnerZone))) {
            if ((A && A(s) || F && F(s)) && t._isImmediateDescendantOfZone(s.target)) {
              var _ = t._getFirstInnerZone();
              if (_) {
                if (!_.focus(!0))
                  return;
              } else if (q(s.target)) {
                if (!t.focusElement(I(s.target, s.target.firstChild, !0)))
                  return;
              } else
                return;
            } else {
              if (s.altKey)
                return;
              switch (s.which) {
                case m.space:
                  if (t._shouldRaiseClicksOnSpace && t._tryInvokeClickForFocusable(s.target, s))
                    break;
                  return;
                case m.left:
                  if (c !== E.vertical && (t._preventDefaultWhenHandled(s), t._moveFocusLeft(f)))
                    break;
                  return;
                case m.right:
                  if (c !== E.vertical && (t._preventDefaultWhenHandled(s), t._moveFocusRight(f)))
                    break;
                  return;
                case m.up:
                  if (c !== E.horizontal && (t._preventDefaultWhenHandled(s), t._moveFocusUp()))
                    break;
                  return;
                case m.down:
                  if (c !== E.horizontal && (t._preventDefaultWhenHandled(s), t._moveFocusDown()))
                    break;
                  return;
                case m.pageDown:
                  if (!v && t._moveFocusPaging(!0))
                    break;
                  return;
                case m.pageUp:
                  if (!v && t._moveFocusPaging(!1))
                    break;
                  return;
                case m.tab:
                  if (
                    // eslint-disable-next-line deprecation/deprecation
                    t.props.allowTabKey || t.props.handleTabKey === H.all || t.props.handleTabKey === H.inputOnly && t._isElementInput(s.target)
                  ) {
                    var b = !1;
                    if (t._processingTabKey = !0, c === E.vertical || !t._shouldWrapFocus(t._activeElement, S))
                      b = s.shiftKey ? t._moveFocusUp() : t._moveFocusDown();
                    else {
                      var p = x(f) ? !s.shiftKey : s.shiftKey;
                      b = p ? t._moveFocusLeft(f) : t._moveFocusRight(f);
                    }
                    if (t._processingTabKey = !1, b)
                      break;
                    t.props.shouldResetActiveElementWhenTabFromZone && (t._activeElement = null);
                  }
                  return;
                case m.home:
                  if (t._isContentEditableElement(s.target) || t._isElementInput(s.target) && !t._shouldInputLoseFocus(s.target, !1))
                    return !1;
                  var d = t._root.current && t._root.current.firstChild;
                  if (t._root.current && d && t.focusElement(I(t._root.current, d, !0)))
                    break;
                  return;
                case m.end:
                  if (t._isContentEditableElement(s.target) || t._isElementInput(s.target) && !t._shouldInputLoseFocus(s.target, !0))
                    return !1;
                  var w = t._root.current && t._root.current.lastChild;
                  if (t._root.current && t.focusElement(D(t._root.current, w, !0, !0, !0)))
                    break;
                  return;
                case m.enter:
                  if (t._shouldRaiseClicksOnEnter && t._tryInvokeClickForFocusable(s.target, s))
                    break;
                  return;
                default:
                  return;
              }
            }
            s.preventDefault(), s.stopPropagation();
          }
        }
      }, t._getHorizontalDistanceFromCenter = function(s, f, u) {
        var c = t._focusAlignment.left || t._focusAlignment.x || 0, h = Math.floor(u.top), F = Math.floor(f.bottom), v = Math.floor(u.bottom), A = Math.floor(f.top), _ = s && h > F, b = !s && v < A;
        return _ || b ? c >= u.left && c <= u.left + u.width ? 0 : Math.abs(u.left + u.width / 2 - c) : t._shouldWrapFocus(t._activeElement, M) ? W : K;
      }, $(t), process.env.NODE_ENV !== "production" && tt("FocusZone", e, {
        rootProps: void 0,
        allowTabKey: "handleTabKey",
        elementType: "as",
        ariaDescribedBy: "aria-describedby",
        ariaLabelledBy: "aria-labelledby"
      }), t._id = et("FocusZone"), t._focusAlignment = {
        left: 0,
        top: 0
      }, t._processingTabKey = !1;
      var l = (i = (r = e.shouldRaiseClicks) !== null && r !== void 0 ? r : o.defaultProps.shouldRaiseClicks) !== null && i !== void 0 ? i : !0;
      return t._shouldRaiseClicksOnEnter = (n = e.shouldRaiseClicksOnEnter) !== null && n !== void 0 ? n : l, t._shouldRaiseClicksOnSpace = (a = e.shouldRaiseClicksOnSpace) !== null && a !== void 0 ? a : l, t;
    }
    return o.getOuterZones = function() {
      return Z.size;
    }, o._onKeyDownCapture = function(e) {
      e.which === m.tab && Z.forEach(function(t) {
        return t._updateTabIndexes();
      });
    }, o.prototype.componentDidMount = function() {
      var e, t = this._root.current;
      if (this._inShadowRoot = !!(!((e = this.context) === null || e === void 0) && e.shadowRoot), R[this._id] = this, t) {
        for (var r = C(t, y); r && r !== this._getDocument().body && r.nodeType === 1; ) {
          if (T(r)) {
            this._isInnerZone = !0;
            break;
          }
          r = C(r, y);
        }
        this._isInnerZone || (Z.add(this), this._root.current && this._root.current.addEventListener("keydown", o._onKeyDownCapture, !0)), this._root.current && this._root.current.addEventListener("blur", this._onBlur, !0), this._updateTabIndexes(), this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement == "string" ? this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement) : this.props.defaultActiveElement && (this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement)), this.props.shouldFocusOnMount && this.focus();
      }
    }, o.prototype.componentDidUpdate = function() {
      var e, t = this._root.current, r = this._getDocument();
      if (this._inShadowRoot = !!(!((e = this.context) === null || e === void 0) && e.shadowRoot), (this._activeElement && !N(this._root.current, this._activeElement, y) || this._defaultFocusElement && !N(this._root.current, this._defaultFocusElement, y)) && (this._activeElement = null, this._defaultFocusElement = null, this._updateTabIndexes()), !this.props.preventFocusRestoration && r && this._lastIndexPath && (r.activeElement === r.body || r.activeElement === null || r.activeElement === t)) {
        var i = X(t, this._lastIndexPath);
        i ? (this._setActiveElement(i, !0), i.focus(), this._setParkedFocus(!1)) : this._setParkedFocus(!0);
      }
    }, o.prototype.componentWillUnmount = function() {
      delete R[this._id], this._isInnerZone || (Z.delete(this), this._root.current && this._root.current.removeEventListener("keydown", o._onKeyDownCapture, !0)), this._root.current && this._root.current.removeEventListener("blur", this._onBlur, !0), this._activeElement = null, this._defaultFocusElement = null;
    }, o.prototype.render = function() {
      var e, t = this, r = (e = this.props, e.as), i = e.elementType, n = e.rootProps, a = e.ariaDescribedBy, l = e.ariaLabelledBy, s = e.className, f = rt(this.props, ot), u = r || i || "div";
      this._evaluateFocusBeforeRender();
      var c = it();
      return L.createElement(u, G({ "aria-labelledby": l, "aria-describedby": a }, f, n, {
        // Once the getClassName correctly memoizes inputs this should
        // be replaced so that className is passed to getRootClass and is included there so
        // the class names will always be in the same order.
        className: nt(dt(), s),
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._root),
        "data-focuszone-id": this._id,
        // eslint-disable-next-line react/jsx-no-bind
        onKeyDown: function(h) {
          return t._onKeyDown(h, c);
        },
        onFocus: this._onFocus,
        onMouseDownCapture: this._onMouseDown
      }), this.props.children);
    }, o.prototype.focus = function(e, t) {
      if (e === void 0 && (e = !1), t === void 0 && (t = !1), this._root.current)
        if (!e && this._root.current.getAttribute(P) === "true" && this._isInnerZone) {
          var r = this._getOwnerZone(this._root.current);
          if (r !== this._root.current) {
            var i = R[r.getAttribute(B)];
            return !!i && i.focusElement(this._root.current);
          }
          return !1;
        } else {
          if (!e && this._activeElement && N(this._root.current, this._activeElement) && k(this._activeElement, void 0, this._inShadowRoot) && (!t || Y(this._activeElement)))
            return this._activeElement.focus(), !0;
          var n = this._root.current.firstChild;
          return this.focusElement(I(this._root.current, n, !0, void 0, void 0, void 0, void 0, void 0, t));
        }
      return !1;
    }, o.prototype.focusLast = function() {
      if (this._root.current) {
        var e = this._root.current && this._root.current.lastChild;
        return this.focusElement(D(this._root.current, e, !0, !0, !0));
      }
      return !1;
    }, o.prototype.focusElement = function(e, t) {
      var r, i = (r = this.props, r.onBeforeFocus), n = r.shouldReceiveFocus;
      return n && !n(e) || i && !i(e) ? !1 : e ? (this._setActiveElement(e, t), this._activeElement && this._activeElement.focus(), !0) : !1;
    }, o.prototype.setFocusAlignment = function(e) {
      this._focusAlignment = e;
    }, Object.defineProperty(o.prototype, "defaultFocusElement", {
      get: function() {
        return this._defaultFocusElement;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "activeElement", {
      get: function() {
        return this._activeElement;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype._evaluateFocusBeforeRender = function() {
      var e = this._root.current, t = this._getDocument();
      if (t) {
        var r = t.activeElement;
        if (r !== e) {
          var i = N(e, r, !1);
          this._lastIndexPath = i ? J(e, r) : void 0;
        }
      }
    }, o.prototype._setParkedFocus = function(e) {
      var t = this._root.current;
      t && this._isParked !== e && (this._isParked = e, e ? (this.props.allowFocusRoot || (this._parkedTabIndex = t.getAttribute("tabindex"), t.setAttribute("tabindex", "-1")), t.focus()) : this.props.allowFocusRoot || (this._parkedTabIndex ? (t.setAttribute("tabindex", this._parkedTabIndex), this._parkedTabIndex = void 0) : t.removeAttribute("tabindex")));
    }, o.prototype._setActiveElement = function(e, t) {
      var r = this._activeElement;
      this._activeElement = e, r && (T(r) && this._updateTabIndexes(r), r.tabIndex = -1), this._activeElement && ((!this._focusAlignment || t) && this._setFocusAlignment(e, !0, !0), this._activeElement.tabIndex = 0);
    }, o.prototype._preventDefaultWhenHandled = function(e) {
      this.props.preventDefaultWhenHandled && e.preventDefault();
    }, o.prototype._tryInvokeClickForFocusable = function(e, t) {
      var r = e;
      if (r === this._root.current)
        return !1;
      do {
        if (r.tagName === "BUTTON" || r.tagName === "A" || r.tagName === "INPUT" || r.tagName === "TEXTAREA" || r.tagName === "SUMMARY")
          return !1;
        if (this._isImmediateDescendantOfZone(r) && r.getAttribute(P) === "true" && r.getAttribute(ct) !== "true")
          return _t(r, t), !0;
        r = C(r, y);
      } while (r !== this._root.current);
      return !1;
    }, o.prototype._getFirstInnerZone = function(e) {
      if (e = e || this._activeElement || this._root.current, !e)
        return null;
      if (T(e))
        return R[e.getAttribute(B)];
      for (var t = e.firstElementChild; t; ) {
        if (T(t))
          return R[t.getAttribute(B)];
        var r = this._getFirstInnerZone(t);
        if (r)
          return r;
        t = t.nextElementSibling;
      }
      return null;
    }, o.prototype._moveFocus = function(e, t, r, i) {
      i === void 0 && (i = !0);
      var n = this._activeElement, a = -1, l = void 0, s = !1, f = this.props.direction === E.bidirectional;
      if (!n || !this._root.current || this._isElementInput(n) && !this._shouldInputLoseFocus(n, e))
        return !1;
      var u = f ? n.getBoundingClientRect() : null;
      do
        if (n = e ? I(this._root.current, n) : D(this._root.current, n), f) {
          if (n) {
            var c = n.getBoundingClientRect(), h = t(u, c);
            if (h === -1 && a === -1) {
              l = n;
              break;
            }
            if (h > -1 && (a === -1 || h < a) && (a = h, l = n), a >= 0 && h < 0)
              break;
          }
        } else {
          l = n;
          break;
        }
      while (n);
      if (l && l !== this._activeElement)
        s = !0, this.focusElement(l);
      else if (this.props.isCircularNavigation && i)
        return e ? this.focusElement(I(this._root.current, this._root.current.firstElementChild, !0)) : this.focusElement(D(this._root.current, this._root.current.lastElementChild, !0, !0, !0));
      return s;
    }, o.prototype._moveFocusDown = function() {
      var e = this, t = -1, r = this._focusAlignment.left || this._focusAlignment.x || 0;
      return (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(!0, function(i, n) {
          var a = -1, l = Math.floor(n.top), s = Math.floor(i.bottom);
          return l < s ? e._shouldWrapFocus(e._activeElement, M) ? W : K : ((t === -1 && l >= s || l === t) && (t = l, r >= n.left && r <= n.left + n.width ? a = 0 : a = Math.abs(n.left + n.width / 2 - r)), a);
        }) ? (this._setFocusAlignment(this._activeElement, !1, !0), !0) : !1
      );
    }, o.prototype._moveFocusUp = function() {
      var e = this, t = -1, r = this._focusAlignment.left || this._focusAlignment.x || 0;
      return (
        // eslint-disable-next-line deprecation/deprecation
        this._moveFocus(!1, function(i, n) {
          var a = -1, l = Math.floor(n.bottom), s = Math.floor(n.top), f = Math.floor(i.top);
          return l > f ? e._shouldWrapFocus(e._activeElement, M) ? W : K : ((t === -1 && l <= f || s === t) && (t = s, r >= n.left && r <= n.left + n.width ? a = 0 : a = Math.abs(n.left + n.width / 2 - r)), a);
        }) ? (this._setFocusAlignment(this._activeElement, !1, !0), !0) : !1
      );
    }, o.prototype._moveFocusLeft = function(e) {
      var t = this, r = this._shouldWrapFocus(this._activeElement, S);
      return this._moveFocus(
        x(e),
        // eslint-disable-next-line deprecation/deprecation
        function(i, n) {
          var a = -1, l;
          return x(e) ? l = parseFloat(n.top.toFixed(3)) < parseFloat(i.bottom.toFixed(3)) : l = parseFloat(n.bottom.toFixed(3)) > parseFloat(i.top.toFixed(3)), l && n.right <= i.right && t.props.direction !== E.vertical ? a = i.right - n.right : r || (a = K), a;
        },
        void 0,
        r
      ) ? (this._setFocusAlignment(this._activeElement, !0, !1), !0) : !1;
    }, o.prototype._moveFocusRight = function(e) {
      var t = this, r = this._shouldWrapFocus(this._activeElement, S);
      return this._moveFocus(
        !x(e),
        // eslint-disable-next-line deprecation/deprecation
        function(i, n) {
          var a = -1, l;
          return x(e) ? l = parseFloat(n.bottom.toFixed(3)) > parseFloat(i.top.toFixed(3)) : l = parseFloat(n.top.toFixed(3)) < parseFloat(i.bottom.toFixed(3)), l && n.left >= i.left && t.props.direction !== E.vertical ? a = n.left - i.left : r || (a = K), a;
        },
        void 0,
        r
      ) ? (this._setFocusAlignment(this._activeElement, !0, !1), !0) : !1;
    }, o.prototype._moveFocusPaging = function(e, t) {
      t === void 0 && (t = !0);
      var r = this._activeElement;
      if (!r || !this._root.current || this._isElementInput(r) && !this._shouldInputLoseFocus(r, e))
        return !1;
      var i = st(r);
      if (!i)
        return !1;
      var n = -1, a = void 0, l = -1, s = -1, f = i.clientHeight, u = r.getBoundingClientRect();
      do
        if (r = e ? I(this._root.current, r) : D(this._root.current, r), r) {
          var c = r.getBoundingClientRect(), h = Math.floor(c.top), F = Math.floor(u.bottom), v = Math.floor(c.bottom), A = Math.floor(u.top), _ = this._getHorizontalDistanceFromCenter(e, u, c), b = e && h > F + f, p = !e && v < A - f;
          if (b || p)
            break;
          _ > -1 && (e && h > l ? (l = h, n = _, a = r) : !e && v < s ? (s = v, n = _, a = r) : (n === -1 || _ <= n) && (n = _, a = r));
        }
      while (r);
      var d = !1;
      if (a && a !== this._activeElement)
        d = !0, this.focusElement(a), this._setFocusAlignment(a, !1, !0);
      else if (this.props.isCircularNavigation && t)
        return e ? this.focusElement(I(this._root.current, this._root.current.firstElementChild, !0)) : this.focusElement(D(this._root.current, this._root.current.lastElementChild, !0, !0, !0));
      return d;
    }, o.prototype._setFocusAlignment = function(e, t, r) {
      if (this.props.direction === E.bidirectional && (!this._focusAlignment || t || r)) {
        var i = e.getBoundingClientRect(), n = i.left + i.width / 2, a = i.top + i.height / 2;
        this._focusAlignment || (this._focusAlignment = { left: n, top: a }), t && (this._focusAlignment.left = n), r && (this._focusAlignment.top = a);
      }
    }, o.prototype._isImmediateDescendantOfZone = function(e) {
      return this._getOwnerZone(e) === this._root.current;
    }, o.prototype._getOwnerZone = function(e) {
      for (var t = C(e, y); t && t !== this._root.current && t !== this._getDocument().body; ) {
        if (T(t))
          return t;
        t = C(t, y);
      }
      return t;
    }, o.prototype._updateTabIndexes = function(e) {
      !this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement == "function" && (this._activeElement = this.props.defaultTabbableElement(this._root.current)), !e && this._root.current && (this._defaultFocusElement = null, e = this._root.current, this._activeElement && !N(e, this._activeElement) && (this._activeElement = null)), this._activeElement && !k(this._activeElement, void 0, this._inShadowRoot) && (this._activeElement = null);
      for (var t = e && e.children, r = 0; t && r < t.length; r++) {
        var i = t[r];
        T(i) ? i.getAttribute(P) === "true" && (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === i) ? (this._defaultFocusElement = i, i.getAttribute(g) !== "0" && i.setAttribute(g, "0")) : i.getAttribute(g) !== "-1" && i.setAttribute(g, "-1")) : (i.getAttribute && i.getAttribute(P) === "false" && i.setAttribute(g, "-1"), k(i, void 0, this._inShadowRoot) ? this.props.disabled ? i.setAttribute(g, "-1") : !this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === i) ? (this._defaultFocusElement = i, i.getAttribute(g) !== "0" && i.setAttribute(g, "0")) : i.getAttribute(g) !== "-1" && i.setAttribute(g, "-1") : i.tagName === "svg" && i.getAttribute("focusable") !== "false" && i.setAttribute("focusable", "false")), this._updateTabIndexes(i);
      }
    }, o.prototype._isContentEditableElement = function(e) {
      return e && e.getAttribute("contenteditable") === "true";
    }, o.prototype._isElementInput = function(e) {
      return !!(e && e.tagName && (e.tagName.toLowerCase() === "input" || e.tagName.toLowerCase() === "textarea"));
    }, o.prototype._shouldInputLoseFocus = function(e, t) {
      if (!this._processingTabKey && e && e.type && pt.indexOf(e.type.toLowerCase()) > -1) {
        var r = e.selectionStart, i = e.selectionEnd, n = r !== i, a = e.value, l = e.readOnly;
        if (n || r > 0 && !t && !l || r !== a.length && t && !l || this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(e)))
          return !1;
      }
      return !0;
    }, o.prototype._shouldWrapFocus = function(e, t) {
      return this.props.checkForNoWrap ? Q(e, t) : !0;
    }, o.prototype._portalContainsElement = function(e) {
      return e && !!this._root.current && at(e, this._root.current);
    }, o.prototype._getDocument = function() {
      return ut(this._root.current);
    }, o.contextType = lt, o.defaultProps = {
      isCircularNavigation: !1,
      direction: E.bidirectional,
      shouldRaiseClicks: !0,
      // Hardcoding uncontrolled flag for proper interop with FluentUI V9.
      "data-tabster": '{"uncontrolled": {}}'
    }, o;
  }(L.Component)
);
export {
  Zt as FocusZone
};
//# sourceMappingURL=FocusZone.js.map
