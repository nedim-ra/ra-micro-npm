{"version":3,"file":"FocusZone.js","sources":["../../../../../../../node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport { KeyCodes, css, elementContains, getDocument, getElementIndexPath, getFocusableByIndexPath, getId, getNativeProps, getNextElement, getParent, getPreviousElement, getRTL, htmlElementProperties, initializeComponentRef, isElementFocusSubZone, isElementFocusZone, isElementTabbable, shouldWrapFocus, warnDeprecations, portalContainsElement, findScrollableParent, createMergedRef, isElementVisibleAndNotHidden, MergeStylesShadowRootContext, } from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar TABINDEX = 'tabindex';\nvar NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nvar NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nvar LARGE_DISTANCE_FROM_CENTER = 999999999;\nvar LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\nvar focusZoneStyles;\nvar focusZoneClass = 'ms-FocusZone';\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction raiseClickFromKeyboardEvent(target, ev) {\n    var event;\n    if (typeof MouseEvent === 'function') {\n        event = new MouseEvent('click', {\n            ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,\n            metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,\n            shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,\n            altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,\n            bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,\n            cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable,\n        });\n    }\n    else {\n        // eslint-disable-next-line no-restricted-globals\n        event = document.createEvent('MouseEvents');\n        // eslint-disable-next-line deprecation/deprecation\n        event.initMouseEvent('click', ev ? ev.bubbles : false, ev ? ev.cancelable : false, \n        // eslint-disable-next-line no-restricted-globals\n        window, // not using getWindow() since this can only be run client side\n        0, // detail\n        0, // screen x\n        0, // screen y\n        0, // client x\n        0, // client y\n        ev ? ev.ctrlKey : false, ev ? ev.altKey : false, ev ? ev.shiftKey : false, ev ? ev.metaKey : false, 0, // button\n        null);\n    }\n    target.dispatchEvent(event);\n}\n// Helper function that will return a class for when the root is focused\nfunction getRootClass() {\n    if (!focusZoneStyles) {\n        focusZoneStyles = mergeStyles({\n            selectors: {\n                ':focus': {\n                    outline: 'none',\n                },\n            },\n        }, focusZoneClass);\n    }\n    return focusZoneStyles;\n}\nvar _allInstances = {};\nvar _outerZones = new Set();\nvar ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search', 'textarea'];\nvar ALLOW_VIRTUAL_ELEMENTS = false;\nexport var FocusZone = /** @class */ (function (_super) {\n    __extends(FocusZone, _super);\n    function FocusZone(props) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        _this = _super.call(this, props) || this;\n        _this._root = React.createRef();\n        _this._mergedRef = createMergedRef();\n        _this._onFocus = function (ev) {\n            var _a;\n            if (_this._portalContainsElement(ev.target)) {\n                // If the event target is inside a portal do not process the event.\n                return;\n            }\n            var onActiveElementChanged = (_a = _this.props, _a.onActiveElementChanged), \n            // eslint-disable-next-line deprecation/deprecation\n            doNotAllowFocusEventToPropagate = _a.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a.stopFocusPropagation, \n            // eslint-disable-next-line deprecation/deprecation\n            onFocusNotification = _a.onFocusNotification, onFocus = _a.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a.defaultTabbableElement;\n            var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);\n            var newActiveElement;\n            if (isImmediateDescendant) {\n                newActiveElement = ev.target;\n            }\n            else {\n                var parentElement = ev.target;\n                while (parentElement && parentElement !== _this._root.current) {\n                    if (isElementTabbable(parentElement, undefined, _this._inShadowRoot) &&\n                        _this._isImmediateDescendantOfZone(parentElement)) {\n                        newActiveElement = parentElement;\n                        break;\n                    }\n                    parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n                }\n            }\n            // If an inner focusable element should be focused when FocusZone container receives focus\n            if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {\n                var maybeElementToFocus = defaultTabbableElement &&\n                    typeof defaultTabbableElement === 'function' &&\n                    _this._root.current &&\n                    defaultTabbableElement(_this._root.current);\n                // try to focus defaultTabbable element\n                if (maybeElementToFocus && isElementTabbable(maybeElementToFocus, undefined, _this._inShadowRoot)) {\n                    newActiveElement = maybeElementToFocus;\n                    maybeElementToFocus.focus();\n                }\n                else {\n                    // force focus on first focusable element\n                    _this.focus(true);\n                    if (_this._activeElement) {\n                        // set to null as new active element was handled in method above\n                        newActiveElement = null;\n                    }\n                }\n            }\n            var initialElementFocused = !_this._activeElement;\n            // If the new active element is a child of this zone and received focus,\n            // update alignment an immediate descendant\n            if (newActiveElement && newActiveElement !== _this._activeElement) {\n                if (isImmediateDescendant || initialElementFocused) {\n                    _this._setFocusAlignment(newActiveElement, true, true);\n                }\n                _this._activeElement = newActiveElement;\n                if (initialElementFocused) {\n                    _this._updateTabIndexes();\n                }\n            }\n            if (onActiveElementChanged) {\n                onActiveElementChanged(_this._activeElement, ev);\n            }\n            if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n                ev.stopPropagation();\n            }\n            if (onFocus) {\n                onFocus(ev);\n            }\n            else if (onFocusNotification) {\n                onFocusNotification();\n            }\n        };\n        _this._onBlur = function () {\n            _this._setParkedFocus(false);\n        };\n        _this._onMouseDown = function (ev) {\n            if (_this._portalContainsElement(ev.target)) {\n                // If the event target is inside a portal do not process the event.\n                return;\n            }\n            var disabled = _this.props.disabled;\n            if (disabled) {\n                return;\n            }\n            var target = ev.target;\n            var path = [];\n            while (target && target !== _this._root.current) {\n                path.push(target);\n                target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n            }\n            while (path.length) {\n                target = path.pop();\n                if (target && isElementTabbable(target, undefined, _this._inShadowRoot)) {\n                    _this._setActiveElement(target, true);\n                }\n                if (isElementFocusZone(target)) {\n                    // Stop here since the focus zone will take care of its own children.\n                    break;\n                }\n            }\n        };\n        /**\n         * Handle the keystrokes.\n         */\n        _this._onKeyDown = function (ev, theme) {\n            var _a;\n            if (_this._portalContainsElement(ev.target)) {\n                // If the event target is inside a portal do not process the event.\n                return;\n            }\n            // eslint-disable-next-line deprecation/deprecation\n            var direction = (_a = _this.props, _a.direction), disabled = _a.disabled, isInnerZoneKeystroke = _a.isInnerZoneKeystroke, pagingSupportDisabled = _a.pagingSupportDisabled, shouldEnterInnerZone = _a.shouldEnterInnerZone;\n            if (disabled) {\n                return;\n            }\n            if (_this.props.onKeyDown) {\n                _this.props.onKeyDown(ev);\n            }\n            // If the default has been prevented, do not process keyboard events.\n            if (ev.isDefaultPrevented()) {\n                return;\n            }\n            if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {\n                // If this element has focus, it is being controlled by a parent.\n                // Ignore the keystroke.\n                return;\n            }\n            if (((shouldEnterInnerZone && shouldEnterInnerZone(ev)) || (isInnerZoneKeystroke && isInnerZoneKeystroke(ev))) &&\n                _this._isImmediateDescendantOfZone(ev.target)) {\n                // Try to focus\n                var innerZone = _this._getFirstInnerZone();\n                if (innerZone) {\n                    if (!innerZone.focus(true)) {\n                        return;\n                    }\n                }\n                else if (isElementFocusSubZone(ev.target)) {\n                    if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {\n                        return;\n                    }\n                }\n                else {\n                    return;\n                }\n            }\n            else if (ev.altKey) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n                switch (ev.which) {\n                    case KeyCodes.space:\n                        if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.left:\n                        if (direction !== FocusZoneDirection.vertical) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusLeft(theme)) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.right:\n                        if (direction !== FocusZoneDirection.vertical) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusRight(theme)) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.up:\n                        if (direction !== FocusZoneDirection.horizontal) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusUp()) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.down:\n                        if (direction !== FocusZoneDirection.horizontal) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusDown()) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.pageDown:\n                        if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.pageUp:\n                        if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.tab:\n                        if (\n                        // eslint-disable-next-line deprecation/deprecation\n                        _this.props.allowTabKey ||\n                            _this.props.handleTabKey === FocusZoneTabbableElements.all ||\n                            (_this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n                                _this._isElementInput(ev.target))) {\n                            var focusChanged = false;\n                            _this._processingTabKey = true;\n                            if (direction === FocusZoneDirection.vertical ||\n                                !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {\n                                focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();\n                            }\n                            else {\n                                var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n                                focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);\n                            }\n                            _this._processingTabKey = false;\n                            if (focusChanged) {\n                                break;\n                            }\n                            else if (_this.props.shouldResetActiveElementWhenTabFromZone) {\n                                _this._activeElement = null;\n                            }\n                        }\n                        return;\n                    case KeyCodes.home:\n                        if (_this._isContentEditableElement(ev.target) ||\n                            (_this._isElementInput(ev.target) &&\n                                !_this._shouldInputLoseFocus(ev.target, false))) {\n                            return false;\n                        }\n                        var firstChild = _this._root.current && _this._root.current.firstChild;\n                        if (_this._root.current &&\n                            firstChild &&\n                            _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.end:\n                        if (_this._isContentEditableElement(ev.target) ||\n                            (_this._isElementInput(ev.target) &&\n                                !_this._shouldInputLoseFocus(ev.target, true))) {\n                            return false;\n                        }\n                        var lastChild = _this._root.current && _this._root.current.lastChild;\n                        if (_this._root.current &&\n                            _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.enter:\n                        if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n                            break;\n                        }\n                        return;\n                    default:\n                        return;\n                }\n            }\n            ev.preventDefault();\n            ev.stopPropagation();\n        };\n        _this._getHorizontalDistanceFromCenter = function (isForward, \n        // eslint-disable-next-line deprecation/deprecation\n        activeRect, \n        // eslint-disable-next-line deprecation/deprecation\n        targetRect) {\n            // eslint-disable-next-line deprecation/deprecation\n            var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;\n            // ClientRect values can be floats that differ by very small fractions of a decimal.\n            // If the difference between top and bottom are within a pixel then we should treat\n            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n            // but without Math.Floor they will be handled incorrectly.\n            var targetRectTop = Math.floor(targetRect.top);\n            var activeRectBottom = Math.floor(activeRect.bottom);\n            var targetRectBottom = Math.floor(targetRect.bottom);\n            var activeRectTop = Math.floor(activeRect.top);\n            var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n            var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n            if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n                    return 0;\n                }\n                return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n            }\n            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n                return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n            }\n            return LARGE_DISTANCE_FROM_CENTER;\n        };\n        // Manage componentRef resolution.\n        initializeComponentRef(_this);\n        if (process.env.NODE_ENV !== 'production') {\n            warnDeprecations('FocusZone', props, {\n                rootProps: undefined,\n                allowTabKey: 'handleTabKey',\n                elementType: 'as',\n                ariaDescribedBy: 'aria-describedby',\n                ariaLabelledBy: 'aria-labelledby',\n            });\n        }\n        _this._id = getId('FocusZone');\n        _this._focusAlignment = {\n            left: 0,\n            top: 0,\n        };\n        _this._processingTabKey = false;\n        var shouldRaiseClicksFallback = (_b = (_a = props.shouldRaiseClicks) !== null && _a !== void 0 ? _a : FocusZone.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;\n        _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;\n        _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;\n        return _this;\n    }\n    /** Used for testing purposes only. */\n    FocusZone.getOuterZones = function () {\n        return _outerZones.size;\n    };\n    /**\n     * Handle global tab presses so that we can patch tabindexes on the fly.\n     * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n     * for ref counting to work correctly!\n     */\n    FocusZone._onKeyDownCapture = function (ev) {\n        // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n        if (ev.which === KeyCodes.tab) {\n            _outerZones.forEach(function (zone) { return zone._updateTabIndexes(); });\n        }\n    };\n    FocusZone.prototype.componentDidMount = function () {\n        var _a;\n        var root = this._root.current;\n        this._inShadowRoot = !!((_a = this.context) === null || _a === void 0 ? void 0 : _a.shadowRoot);\n        _allInstances[this._id] = this;\n        if (root) {\n            var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n            while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n                if (isElementFocusZone(parentElement)) {\n                    this._isInnerZone = true;\n                    break;\n                }\n                parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n            }\n            if (!this._isInnerZone) {\n                _outerZones.add(this);\n                this._root.current && this._root.current.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n            }\n            this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);\n            // Assign initial tab indexes so that we can set initial focus as appropriate.\n            this._updateTabIndexes();\n            if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n                this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);\n                // eslint-disable-next-line deprecation/deprecation\n            }\n            else if (this.props.defaultActiveElement) {\n                // eslint-disable-next-line deprecation/deprecation\n                this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);\n            }\n            if (this.props.shouldFocusOnMount) {\n                this.focus();\n            }\n        }\n    };\n    FocusZone.prototype.componentDidUpdate = function () {\n        var _a;\n        var root = this._root.current;\n        var doc = this._getDocument();\n        this._inShadowRoot = !!((_a = this.context) === null || _a === void 0 ? void 0 : _a.shadowRoot);\n        // If either _activeElement or _defaultFocusElement are no longer contained by _root,\n        // reset those variables (and update tab indexes) to avoid memory leaks\n        if ((this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) ||\n            (this._defaultFocusElement &&\n                !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS))) {\n            this._activeElement = null;\n            this._defaultFocusElement = null;\n            this._updateTabIndexes();\n        }\n        if (!this.props.preventFocusRestoration &&\n            doc &&\n            this._lastIndexPath &&\n            (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {\n            // The element has been removed after the render, attempt to restore focus.\n            var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);\n            if (elementToFocus) {\n                this._setActiveElement(elementToFocus, true);\n                elementToFocus.focus();\n                this._setParkedFocus(false);\n            }\n            else {\n                // We had a focus path to restore, but now that path is unresolvable. Park focus\n                // on the container until we can try again.\n                this._setParkedFocus(true);\n            }\n        }\n    };\n    FocusZone.prototype.componentWillUnmount = function () {\n        delete _allInstances[this._id];\n        if (!this._isInnerZone) {\n            _outerZones.delete(this);\n            this._root.current && this._root.current.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n        }\n        if (this._root.current) {\n            this._root.current.removeEventListener('blur', this._onBlur, true);\n        }\n        this._activeElement = null;\n        this._defaultFocusElement = null;\n    };\n    FocusZone.prototype.render = function () {\n        var _a;\n        var _this = this;\n        // eslint-disable-next-line deprecation/deprecation\n        var tag = (_a = this.props, _a.as), elementType = _a.elementType, rootProps = _a.rootProps, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className;\n        var divProps = getNativeProps(this.props, htmlElementProperties);\n        var Tag = tag || elementType || 'div';\n        // Note, right before rendering/reconciling proceeds, we need to record if focus\n        // was in the zone before the update. This helper will track this and, if focus\n        // was actually in the zone, what the index path to the element is at this time.\n        // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n        // the case the element was removed.\n        this._evaluateFocusBeforeRender();\n        // Only support RTL defined in global theme, not contextual theme/RTL.\n        var theme = getTheme();\n        return (React.createElement(Tag, __assign({ \"aria-labelledby\": ariaLabelledBy, \"aria-describedby\": ariaDescribedBy }, divProps, rootProps, { \n            // Once the getClassName correctly memoizes inputs this should\n            // be replaced so that className is passed to getRootClass and is included there so\n            // the class names will always be in the same order.\n            className: css(getRootClass(), className), \n            // eslint-disable-next-line deprecation/deprecation\n            ref: this._mergedRef(this.props.elementRef, this._root), \"data-focuszone-id\": this._id, \n            // eslint-disable-next-line react/jsx-no-bind\n            onKeyDown: function (ev) { return _this._onKeyDown(ev, theme); }, onFocus: this._onFocus, onMouseDownCapture: this._onMouseDown }), this.props.children));\n    };\n    /**\n     * Sets focus to the first tabbable item in the zone.\n     * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n     * if focus is already in the focus zone.\n     * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n     * @returns True if focus could be set to an active element, false if no operation was taken.\n     */\n    FocusZone.prototype.focus = function (forceIntoFirstElement, bypassHiddenElements) {\n        if (forceIntoFirstElement === void 0) { forceIntoFirstElement = false; }\n        if (bypassHiddenElements === void 0) { bypassHiddenElements = false; }\n        if (this._root.current) {\n            if (!forceIntoFirstElement &&\n                this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n                this._isInnerZone) {\n                var ownerZoneElement = this._getOwnerZone(this._root.current);\n                if (ownerZoneElement !== this._root.current) {\n                    var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n                    return !!ownerZone && ownerZone.focusElement(this._root.current);\n                }\n                return false;\n            }\n            else if (!forceIntoFirstElement &&\n                this._activeElement &&\n                elementContains(this._root.current, this._activeElement) &&\n                isElementTabbable(this._activeElement, undefined, this._inShadowRoot) &&\n                (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {\n                this._activeElement.focus();\n                return true;\n            }\n            else {\n                var firstChild = this._root.current.firstChild;\n                return this.focusElement(getNextElement(this._root.current, firstChild, true, undefined, undefined, undefined, undefined, undefined, bypassHiddenElements));\n            }\n        }\n        return false;\n    };\n    /**\n     * Sets focus to the last tabbable item in the zone.\n     * @returns True if focus could be set to an active element, false if no operation was taken.\n     */\n    FocusZone.prototype.focusLast = function () {\n        if (this._root.current) {\n            var lastChild = this._root.current && this._root.current.lastChild;\n            return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));\n        }\n        return false;\n    };\n    /**\n     * Sets focus to a specific child element within the zone. This can be used in conjunction with\n     * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n     * location and then focus.)\n     * @param element - The child element within the zone to focus.\n     * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n     * @returns True if focus could be set to an active element, false if no operation was taken.\n     */\n    FocusZone.prototype.focusElement = function (element, forceAlignment) {\n        var _a;\n        // eslint-disable-next-line deprecation/deprecation\n        var onBeforeFocus = (_a = this.props, _a.onBeforeFocus), shouldReceiveFocus = _a.shouldReceiveFocus;\n        if ((shouldReceiveFocus && !shouldReceiveFocus(element)) || (onBeforeFocus && !onBeforeFocus(element))) {\n            return false;\n        }\n        if (element) {\n            // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n            this._setActiveElement(element, forceAlignment);\n            if (this._activeElement) {\n                this._activeElement.focus();\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n     * rather than a center based on the last horizontal motion.\n     * @param point - the new reference point.\n     */\n    FocusZone.prototype.setFocusAlignment = function (point) {\n        this._focusAlignment = point;\n    };\n    Object.defineProperty(FocusZone.prototype, \"defaultFocusElement\", {\n        get: function () {\n            return this._defaultFocusElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FocusZone.prototype, \"activeElement\", {\n        get: function () {\n            return this._activeElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FocusZone.prototype._evaluateFocusBeforeRender = function () {\n        var root = this._root.current;\n        var doc = this._getDocument();\n        if (doc) {\n            var focusedElement = doc.activeElement;\n            // Only update the index path if we are not parked on the root.\n            if (focusedElement !== root) {\n                var shouldRestoreFocus = elementContains(root, focusedElement, false);\n                this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : undefined;\n            }\n        }\n    };\n    /**\n     * When focus is in the zone at render time but then all focusable elements are removed,\n     * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n     * focus to the closest path from previous. If the user tabs away from the parked container,\n     * we restore focusability to the pre-parked state.\n     */\n    FocusZone.prototype._setParkedFocus = function (isParked) {\n        var root = this._root.current;\n        if (root && this._isParked !== isParked) {\n            this._isParked = isParked;\n            if (isParked) {\n                if (!this.props.allowFocusRoot) {\n                    this._parkedTabIndex = root.getAttribute('tabindex');\n                    root.setAttribute('tabindex', '-1');\n                }\n                root.focus();\n            }\n            else if (!this.props.allowFocusRoot) {\n                if (this._parkedTabIndex) {\n                    root.setAttribute('tabindex', this._parkedTabIndex);\n                    this._parkedTabIndex = undefined;\n                }\n                else {\n                    root.removeAttribute('tabindex');\n                }\n            }\n        }\n    };\n    FocusZone.prototype._setActiveElement = function (element, forceAlignment) {\n        var previousActiveElement = this._activeElement;\n        this._activeElement = element;\n        if (previousActiveElement) {\n            if (isElementFocusZone(previousActiveElement)) {\n                this._updateTabIndexes(previousActiveElement);\n            }\n            previousActiveElement.tabIndex = -1;\n        }\n        if (this._activeElement) {\n            if (!this._focusAlignment || forceAlignment) {\n                this._setFocusAlignment(element, true, true);\n            }\n            this._activeElement.tabIndex = 0;\n        }\n    };\n    FocusZone.prototype._preventDefaultWhenHandled = function (ev) {\n        this.props.preventDefaultWhenHandled && ev.preventDefault();\n    };\n    /**\n     * Walk up the dom try to find a focusable element.\n     */\n    FocusZone.prototype._tryInvokeClickForFocusable = function (targetElement, ev) {\n        var target = targetElement;\n        if (target === this._root.current) {\n            return false;\n        }\n        do {\n            if (target.tagName === 'BUTTON' ||\n                target.tagName === 'A' ||\n                target.tagName === 'INPUT' ||\n                target.tagName === 'TEXTAREA' ||\n                target.tagName === 'SUMMARY') {\n                return false;\n            }\n            if (this._isImmediateDescendantOfZone(target) &&\n                target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n                target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {\n                raiseClickFromKeyboardEvent(target, ev);\n                return true;\n            }\n            target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n        } while (target !== this._root.current);\n        return false;\n    };\n    /**\n     * Traverse to find first child zone.\n     */\n    FocusZone.prototype._getFirstInnerZone = function (rootElement) {\n        rootElement = rootElement || this._activeElement || this._root.current;\n        if (!rootElement) {\n            return null;\n        }\n        if (isElementFocusZone(rootElement)) {\n            return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n        }\n        var child = rootElement.firstElementChild;\n        while (child) {\n            if (isElementFocusZone(child)) {\n                return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n            }\n            var match = this._getFirstInnerZone(child);\n            if (match) {\n                return match;\n            }\n            child = child.nextElementSibling;\n        }\n        return null;\n    };\n    FocusZone.prototype._moveFocus = function (isForward, \n    // eslint-disable-next-line deprecation/deprecation\n    getDistanceFromCenter, ev, useDefaultWrap) {\n        if (useDefaultWrap === void 0) { useDefaultWrap = true; }\n        var element = this._activeElement;\n        var candidateDistance = -1;\n        var candidateElement = undefined;\n        var changedFocus = false;\n        var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n        if (!element || !this._root.current) {\n            return false;\n        }\n        if (this._isElementInput(element)) {\n            if (!this._shouldInputLoseFocus(element, isForward)) {\n                return false;\n            }\n        }\n        var activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n        do {\n            element = (isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element));\n            if (isBidirectional) {\n                if (element) {\n                    var targetRect = element.getBoundingClientRect();\n                    // eslint-disable-next-line deprecation/deprecation\n                    var elementDistance = getDistanceFromCenter(activeRect, targetRect);\n                    if (elementDistance === -1 && candidateDistance === -1) {\n                        candidateElement = element;\n                        break;\n                    }\n                    if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                    if (candidateDistance >= 0 && elementDistance < 0) {\n                        break;\n                    }\n                }\n            }\n            else {\n                candidateElement = element;\n                break;\n            }\n        } while (element);\n        // Focus the closest candidate\n        if (candidateElement && candidateElement !== this._activeElement) {\n            changedFocus = true;\n            this.focusElement(candidateElement);\n        }\n        else if (this.props.isCircularNavigation && useDefaultWrap) {\n            if (isForward) {\n                return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n            }\n            else {\n                return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n            }\n        }\n        return changedFocus;\n    };\n    FocusZone.prototype._moveFocusDown = function () {\n        var _this = this;\n        var targetTop = -1;\n        // eslint-disable-next-line deprecation/deprecation\n        var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n        if (\n        // eslint-disable-next-line deprecation/deprecation\n        this._moveFocus(true, function (activeRect, targetRect) {\n            var distance = -1;\n            // ClientRect values can be floats that differ by very small fractions of a decimal.\n            // If the difference between top and bottom are within a pixel then we should treat\n            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n            // but without Math.Floor they will be handled incorrectly.\n            var targetRectTop = Math.floor(targetRect.top);\n            var activeRectBottom = Math.floor(activeRect.bottom);\n            if (targetRectTop < activeRectBottom) {\n                if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n                }\n                return LARGE_DISTANCE_FROM_CENTER;\n            }\n            if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n                targetTop = targetRectTop;\n                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n                    distance = 0;\n                }\n                else {\n                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n                }\n            }\n            return distance;\n        })) {\n            this._setFocusAlignment(this._activeElement, false, true);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusUp = function () {\n        var _this = this;\n        var targetTop = -1;\n        // eslint-disable-next-line deprecation/deprecation\n        var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n        if (\n        // eslint-disable-next-line deprecation/deprecation\n        this._moveFocus(false, function (activeRect, targetRect) {\n            var distance = -1;\n            // ClientRect values can be floats that differ by very small fractions of a decimal.\n            // If the difference between top and bottom are within a pixel then we should treat\n            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n            // but without Math.Floor they will be handled incorrectly.\n            var targetRectBottom = Math.floor(targetRect.bottom);\n            var targetRectTop = Math.floor(targetRect.top);\n            var activeRectTop = Math.floor(activeRect.top);\n            if (targetRectBottom > activeRectTop) {\n                if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n                }\n                return LARGE_DISTANCE_FROM_CENTER;\n            }\n            if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n                targetTop = targetRectTop;\n                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n                    distance = 0;\n                }\n                else {\n                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n                }\n            }\n            return distance;\n        })) {\n            this._setFocusAlignment(this._activeElement, false, true);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusLeft = function (theme) {\n        var _this = this;\n        var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n        if (this._moveFocus(getRTL(theme), \n        // eslint-disable-next-line deprecation/deprecation\n        function (activeRect, targetRect) {\n            var distance = -1;\n            var topBottomComparison;\n            if (getRTL(theme)) {\n                // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n                // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n                // This is important, because we want to be comparing the top of the target rect\n                // with the bottom of the active rect.\n                topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n            }\n            else {\n                topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n            }\n            if (topBottomComparison &&\n                targetRect.right <= activeRect.right &&\n                _this.props.direction !== FocusZoneDirection.vertical) {\n                distance = activeRect.right - targetRect.right;\n            }\n            else if (!shouldWrap) {\n                distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n            }\n            return distance;\n        }, undefined /*ev*/, shouldWrap)) {\n            this._setFocusAlignment(this._activeElement, true, false);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusRight = function (theme) {\n        var _this = this;\n        var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n        if (this._moveFocus(!getRTL(theme), \n        // eslint-disable-next-line deprecation/deprecation\n        function (activeRect, targetRect) {\n            var distance = -1;\n            var topBottomComparison;\n            if (getRTL(theme)) {\n                // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n                // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n                // This is important, because we want to be comparing the bottom of the target rect\n                // with the top of the active rect.\n                topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n            }\n            else {\n                topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n            }\n            if (topBottomComparison &&\n                targetRect.left >= activeRect.left &&\n                _this.props.direction !== FocusZoneDirection.vertical) {\n                distance = targetRect.left - activeRect.left;\n            }\n            else if (!shouldWrap) {\n                distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n            }\n            return distance;\n        }, undefined /*ev*/, shouldWrap)) {\n            this._setFocusAlignment(this._activeElement, true, false);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusPaging = function (isForward, useDefaultWrap) {\n        if (useDefaultWrap === void 0) { useDefaultWrap = true; }\n        var element = this._activeElement;\n        if (!element || !this._root.current) {\n            return false;\n        }\n        if (this._isElementInput(element)) {\n            if (!this._shouldInputLoseFocus(element, isForward)) {\n                return false;\n            }\n        }\n        var scrollableParent = findScrollableParent(element);\n        if (!scrollableParent) {\n            return false;\n        }\n        var candidateDistance = -1;\n        var candidateElement = undefined;\n        var targetTop = -1;\n        var targetBottom = -1;\n        var pagesize = scrollableParent.clientHeight;\n        var activeRect = element.getBoundingClientRect();\n        do {\n            element = isForward\n                ? getNextElement(this._root.current, element)\n                : getPreviousElement(this._root.current, element);\n            if (element) {\n                var targetRect = element.getBoundingClientRect();\n                var targetRectTop = Math.floor(targetRect.top);\n                var activeRectBottom = Math.floor(activeRect.bottom);\n                var targetRectBottom = Math.floor(targetRect.bottom);\n                var activeRectTop = Math.floor(activeRect.top);\n                var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n                var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n                var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n                if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n                    break;\n                }\n                if (elementDistance > -1) {\n                    // for paging down\n                    if (isForward && targetRectTop > targetTop) {\n                        targetTop = targetRectTop;\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                    else if (!isForward && targetRectBottom < targetBottom) {\n                        // for paging up\n                        targetBottom = targetRectBottom;\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                    else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                }\n            }\n        } while (element);\n        var changedFocus = false;\n        // Focus the closest candidate\n        if (candidateElement && candidateElement !== this._activeElement) {\n            changedFocus = true;\n            this.focusElement(candidateElement);\n            this._setFocusAlignment(candidateElement, false, true);\n        }\n        else if (this.props.isCircularNavigation && useDefaultWrap) {\n            if (isForward) {\n                return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n            }\n            return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n        }\n        return changedFocus;\n    };\n    FocusZone.prototype._setFocusAlignment = function (element, isHorizontal, isVertical) {\n        if (this.props.direction === FocusZoneDirection.bidirectional &&\n            (!this._focusAlignment || isHorizontal || isVertical)) {\n            var rect = element.getBoundingClientRect();\n            var left = rect.left + rect.width / 2;\n            var top_1 = rect.top + rect.height / 2;\n            if (!this._focusAlignment) {\n                this._focusAlignment = { left: left, top: top_1 };\n            }\n            if (isHorizontal) {\n                this._focusAlignment.left = left;\n            }\n            if (isVertical) {\n                this._focusAlignment.top = top_1;\n            }\n        }\n    };\n    FocusZone.prototype._isImmediateDescendantOfZone = function (element) {\n        return this._getOwnerZone(element) === this._root.current;\n    };\n    FocusZone.prototype._getOwnerZone = function (element) {\n        var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);\n        while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n            if (isElementFocusZone(parentElement)) {\n                return parentElement;\n            }\n            parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n        }\n        return parentElement;\n    };\n    FocusZone.prototype._updateTabIndexes = function (element) {\n        if (!this._activeElement &&\n            this.props.defaultTabbableElement &&\n            typeof this.props.defaultTabbableElement === 'function') {\n            this._activeElement = this.props.defaultTabbableElement(this._root.current);\n        }\n        if (!element && this._root.current) {\n            this._defaultFocusElement = null;\n            element = this._root.current;\n            if (this._activeElement && !elementContains(element, this._activeElement)) {\n                this._activeElement = null;\n            }\n        }\n        // If active element changes state to disabled, set it to null.\n        // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n        if (this._activeElement && !isElementTabbable(this._activeElement, undefined, this._inShadowRoot)) {\n            this._activeElement = null;\n        }\n        var childNodes = element && element.children;\n        for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n            var child = childNodes[childIndex];\n            if (!isElementFocusZone(child)) {\n                // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n                if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n                    child.setAttribute(TABINDEX, '-1');\n                }\n                if (isElementTabbable(child, undefined, this._inShadowRoot)) {\n                    if (this.props.disabled) {\n                        child.setAttribute(TABINDEX, '-1');\n                    }\n                    else if (!this._isInnerZone &&\n                        ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {\n                        this._defaultFocusElement = child;\n                        if (child.getAttribute(TABINDEX) !== '0') {\n                            child.setAttribute(TABINDEX, '0');\n                        }\n                    }\n                    else if (child.getAttribute(TABINDEX) !== '-1') {\n                        child.setAttribute(TABINDEX, '-1');\n                    }\n                }\n                else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n                    // Disgusting IE hack. Sad face.\n                    child.setAttribute('focusable', 'false');\n                }\n            }\n            else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n                if (!this._isInnerZone &&\n                    ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {\n                    this._defaultFocusElement = child;\n                    if (child.getAttribute(TABINDEX) !== '0') {\n                        child.setAttribute(TABINDEX, '0');\n                    }\n                }\n                else if (child.getAttribute(TABINDEX) !== '-1') {\n                    child.setAttribute(TABINDEX, '-1');\n                }\n            }\n            this._updateTabIndexes(child);\n        }\n    };\n    FocusZone.prototype._isContentEditableElement = function (element) {\n        return element && element.getAttribute('contenteditable') === 'true';\n    };\n    FocusZone.prototype._isElementInput = function (element) {\n        if (element &&\n            element.tagName &&\n            (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._shouldInputLoseFocus = function (element, isForward) {\n        // If a tab was used, we want to focus on the next element.\n        if (!this._processingTabKey &&\n            element &&\n            element.type &&\n            ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {\n            var selectionStart = element.selectionStart;\n            var selectionEnd = element.selectionEnd;\n            var isRangeSelected = selectionStart !== selectionEnd;\n            var inputValue = element.value;\n            var isReadonly = element.readOnly;\n            // We shouldn't lose focus in the following cases:\n            // 1. There is range selected.\n            // 2. When selection start is larger than 0 and it is backward and not readOnly.\n            // 3. when selection start is not the end of length, it is forward and not readOnly.\n            // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n            // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n            // determined by calling the callback shouldInputLoseFocusOnArrowKey\n            if (isRangeSelected ||\n                (selectionStart > 0 && !isForward && !isReadonly) ||\n                (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n                (!!this.props.handleTabKey &&\n                    !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    FocusZone.prototype._shouldWrapFocus = function (element, noWrapDataAttribute) {\n        return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n    };\n    /**\n     * Returns true if the element is a descendant of the FocusZone through a React portal.\n     */\n    FocusZone.prototype._portalContainsElement = function (element) {\n        return element && !!this._root.current && portalContainsElement(element, this._root.current);\n    };\n    FocusZone.prototype._getDocument = function () {\n        return getDocument(this._root.current);\n    };\n    FocusZone.contextType = MergeStylesShadowRootContext;\n    FocusZone.defaultProps = {\n        isCircularNavigation: false,\n        direction: FocusZoneDirection.bidirectional,\n        shouldRaiseClicks: true,\n        // Hardcoding uncontrolled flag for proper interop with FluentUI V9.\n        'data-tabster': '{\"uncontrolled\": {}}',\n    };\n    return FocusZone;\n}(React.Component));\n//# sourceMappingURL=FocusZone.js.map"],"names":["IS_FOCUSABLE_ATTRIBUTE","IS_ENTER_DISABLED_ATTRIBUTE","FOCUSZONE_ID_ATTRIBUTE","TABINDEX","NO_VERTICAL_WRAP","NO_HORIZONTAL_WRAP","LARGE_DISTANCE_FROM_CENTER","LARGE_NEGATIVE_DISTANCE_FROM_CENTER","focusZoneStyles","focusZoneClass","raiseClickFromKeyboardEvent","target","ev","event","getRootClass","mergeStyles","_allInstances","_outerZones","ALLOWED_INPUT_TYPES","ALLOW_VIRTUAL_ELEMENTS","FocusZone","_super","__extends","props","_this","_a","_b","_c","_d","React","createMergedRef","onActiveElementChanged","doNotAllowFocusEventToPropagate","stopFocusPropagation","onFocusNotification","onFocus","shouldFocusInnerElementWhenReceivedFocus","defaultTabbableElement","isImmediateDescendant","newActiveElement","parentElement","isElementTabbable","getParent","maybeElementToFocus","initialElementFocused","disabled","path","isElementFocusZone","theme","direction","isInnerZoneKeystroke","pagingSupportDisabled","shouldEnterInnerZone","innerZone","isElementFocusSubZone","getNextElement","KeyCodes","FocusZoneDirection","FocusZoneTabbableElements","focusChanged","tabWithDirection","getRTL","firstChild","lastChild","getPreviousElement","isForward","activeRect","targetRect","leftAlignment","targetRectTop","activeRectBottom","targetRectBottom","activeRectTop","isValidCandidateOnpagingDown","isValidCandidateOnpagingUp","initializeComponentRef","warnDeprecations","getId","shouldRaiseClicksFallback","zone","root","doc","elementContains","elementToFocus","getFocusableByIndexPath","tag","elementType","rootProps","ariaDescribedBy","ariaLabelledBy","className","divProps","getNativeProps","htmlElementProperties","Tag","getTheme","__assign","css","forceIntoFirstElement","bypassHiddenElements","ownerZoneElement","ownerZone","isElementVisibleAndNotHidden","element","forceAlignment","onBeforeFocus","shouldReceiveFocus","point","focusedElement","shouldRestoreFocus","getElementIndexPath","isParked","previousActiveElement","targetElement","rootElement","child","match","getDistanceFromCenter","useDefaultWrap","candidateDistance","candidateElement","changedFocus","isBidirectional","elementDistance","targetTop","distance","shouldWrap","topBottomComparison","scrollableParent","findScrollableParent","targetBottom","pagesize","isElementPassedPageSizeOnPagingDown","isElementPassedPageSizeOnPagingUp","isHorizontal","isVertical","rect","left","top_1","childNodes","childIndex","selectionStart","selectionEnd","isRangeSelected","inputValue","isReadonly","noWrapDataAttribute","shouldWrapFocus","portalContainsElement","getDocument","MergeStylesShadowRootContext"],"mappings":"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","x_google_ignoreList":[0]}